From f0a8d7abb0b3a8f089a943261de5f87fcc92dfef Mon Sep 17 00:00:00 2001
From: ystarnaud <ystarnaud@gmail.com>
Date: Fri, 6 Apr 2018 11:43:29 -0400
Subject: [PATCH 1/5] moneromoo cryptonight v7 variant changes

---
 crypto/cn_aes.cuh          | 1267 +++++++++++---------------------------------
 crypto/cryptonight-core.cu |  309 ++++++-----
 crypto/cryptonight-cpu.cpp |   26 +-
 crypto/cryptonight.cu      |    7 +-
 crypto/cryptonight.h       |    2 +-
 miner.h                    |    2 +-
 6 files changed, 512 insertions(+), 1101 deletions(-)

diff --git a/crypto/cn_aes.cuh b/crypto/cn_aes.cuh
index df419b37d..5db1666ae 100644
--- a/crypto/cn_aes.cuh
+++ b/crypto/cn_aes.cuh
@@ -1,989 +1,322 @@
 
 #define N_COLS          4
 #define WPOLY           0x011b
-/*
-static const __device__ __align__(16) uint32_t d_t_fn[1024] = {
-	0xa56363c6U, 0x847c7cf8U, 0x997777eeU, 0x8d7b7bf6U, 0x0df2f2ffU, 0xbd6b6bd6U, 0xb16f6fdeU, 0x54c5c591U,
-	0x50303060U, 0x03010102U, 0xa96767ceU, 0x7d2b2b56U, 0x19fefee7U, 0x62d7d7b5U, 0xe6abab4dU, 0x9a7676ecU,
-	0x45caca8fU, 0x9d82821fU, 0x40c9c989U, 0x877d7dfaU, 0x15fafaefU, 0xeb5959b2U, 0xc947478eU, 0x0bf0f0fbU,
-	0xecadad41U, 0x67d4d4b3U, 0xfda2a25fU, 0xeaafaf45U, 0xbf9c9c23U, 0xf7a4a453U, 0x967272e4U, 0x5bc0c09bU,
-	0xc2b7b775U, 0x1cfdfde1U, 0xae93933dU, 0x6a26264cU, 0x5a36366cU, 0x413f3f7eU, 0x02f7f7f5U, 0x4fcccc83U,
-	0x5c343468U, 0xf4a5a551U, 0x34e5e5d1U, 0x08f1f1f9U, 0x937171e2U, 0x73d8d8abU, 0x53313162U, 0x3f15152aU,
-	0x0c040408U, 0x52c7c795U, 0x65232346U, 0x5ec3c39dU, 0x28181830U, 0xa1969637U, 0x0f05050aU, 0xb59a9a2fU,
-	0x0907070eU, 0x36121224U, 0x9b80801bU, 0x3de2e2dfU, 0x26ebebcdU, 0x6927274eU, 0xcdb2b27fU, 0x9f7575eaU,
-	0x1b090912U, 0x9e83831dU, 0x742c2c58U, 0x2e1a1a34U, 0x2d1b1b36U, 0xb26e6edcU, 0xee5a5ab4U, 0xfba0a05bU,
-	0xf65252a4U, 0x4d3b3b76U, 0x61d6d6b7U, 0xceb3b37dU, 0x7b292952U, 0x3ee3e3ddU, 0x712f2f5eU, 0x97848413U,
-	0xf55353a6U, 0x68d1d1b9U, 0x00000000U, 0x2cededc1U, 0x60202040U, 0x1ffcfce3U, 0xc8b1b179U, 0xed5b5bb6U,
-	0xbe6a6ad4U, 0x46cbcb8dU, 0xd9bebe67U, 0x4b393972U, 0xde4a4a94U, 0xd44c4c98U, 0xe85858b0U, 0x4acfcf85U,
-	0x6bd0d0bbU, 0x2aefefc5U, 0xe5aaaa4fU, 0x16fbfbedU, 0xc5434386U, 0xd74d4d9aU, 0x55333366U, 0x94858511U,
-	0xcf45458aU, 0x10f9f9e9U, 0x06020204U, 0x817f7ffeU, 0xf05050a0U, 0x443c3c78U, 0xba9f9f25U, 0xe3a8a84bU,
-	0xf35151a2U, 0xfea3a35dU, 0xc0404080U, 0x8a8f8f05U, 0xad92923fU, 0xbc9d9d21U, 0x48383870U, 0x04f5f5f1U,
-	0xdfbcbc63U, 0xc1b6b677U, 0x75dadaafU, 0x63212142U, 0x30101020U, 0x1affffe5U, 0x0ef3f3fdU, 0x6dd2d2bfU,
-	0x4ccdcd81U, 0x140c0c18U, 0x35131326U, 0x2fececc3U, 0xe15f5fbeU, 0xa2979735U, 0xcc444488U, 0x3917172eU,
-	0x57c4c493U, 0xf2a7a755U, 0x827e7efcU, 0x473d3d7aU, 0xac6464c8U, 0xe75d5dbaU, 0x2b191932U, 0x957373e6U,
-	0xa06060c0U, 0x98818119U, 0xd14f4f9eU, 0x7fdcdca3U, 0x66222244U, 0x7e2a2a54U, 0xab90903bU, 0x8388880bU,
-	0xca46468cU, 0x29eeeec7U, 0xd3b8b86bU, 0x3c141428U, 0x79dedea7U, 0xe25e5ebcU, 0x1d0b0b16U, 0x76dbdbadU,
-	0x3be0e0dbU, 0x56323264U, 0x4e3a3a74U, 0x1e0a0a14U, 0xdb494992U, 0x0a06060cU, 0x6c242448U, 0xe45c5cb8U,
-	0x5dc2c29fU, 0x6ed3d3bdU, 0xefacac43U, 0xa66262c4U, 0xa8919139U, 0xa4959531U, 0x37e4e4d3U, 0x8b7979f2U,
-	0x32e7e7d5U, 0x43c8c88bU, 0x5937376eU, 0xb76d6ddaU, 0x8c8d8d01U, 0x64d5d5b1U, 0xd24e4e9cU, 0xe0a9a949U,
-	0xb46c6cd8U, 0xfa5656acU, 0x07f4f4f3U, 0x25eaeacfU, 0xaf6565caU, 0x8e7a7af4U, 0xe9aeae47U, 0x18080810U,
-	0xd5baba6fU, 0x887878f0U, 0x6f25254aU, 0x722e2e5cU, 0x241c1c38U, 0xf1a6a657U, 0xc7b4b473U, 0x51c6c697U,
-	0x23e8e8cbU, 0x7cdddda1U, 0x9c7474e8U, 0x211f1f3eU, 0xdd4b4b96U, 0xdcbdbd61U, 0x868b8b0dU, 0x858a8a0fU,
-	0x907070e0U, 0x423e3e7cU, 0xc4b5b571U, 0xaa6666ccU, 0xd8484890U, 0x05030306U, 0x01f6f6f7U, 0x120e0e1cU,
-	0xa36161c2U, 0x5f35356aU, 0xf95757aeU, 0xd0b9b969U, 0x91868617U, 0x58c1c199U, 0x271d1d3aU, 0xb99e9e27U,
-	0x38e1e1d9U, 0x13f8f8ebU, 0xb398982bU, 0x33111122U, 0xbb6969d2U, 0x70d9d9a9U, 0x898e8e07U, 0xa7949433U,
-	0xb69b9b2dU, 0x221e1e3cU, 0x92878715U, 0x20e9e9c9U, 0x49cece87U, 0xff5555aaU, 0x78282850U, 0x7adfdfa5U,
-	0x8f8c8c03U, 0xf8a1a159U, 0x80898909U, 0x170d0d1aU, 0xdabfbf65U, 0x31e6e6d7U, 0xc6424284U, 0xb86868d0U,
-	0xc3414182U, 0xb0999929U, 0x772d2d5aU, 0x110f0f1eU, 0xcbb0b07bU, 0xfc5454a8U, 0xd6bbbb6dU, 0x3a16162cU,
 
-	0x6363c6a5U, 0x7c7cf884U, 0x7777ee99U, 0x7b7bf68dU, 0xf2f2ff0dU, 0x6b6bd6bdU, 0x6f6fdeb1U, 0xc5c59154U,
-	0x30306050U, 0x01010203U, 0x6767cea9U, 0x2b2b567dU, 0xfefee719U, 0xd7d7b562U, 0xabab4de6U, 0x7676ec9aU,
-	0xcaca8f45U, 0x82821f9dU, 0xc9c98940U, 0x7d7dfa87U, 0xfafaef15U, 0x5959b2ebU, 0x47478ec9U, 0xf0f0fb0bU,
-	0xadad41ecU, 0xd4d4b367U, 0xa2a25ffdU, 0xafaf45eaU, 0x9c9c23bfU, 0xa4a453f7U, 0x7272e496U, 0xc0c09b5bU,
-	0xb7b775c2U, 0xfdfde11cU, 0x93933daeU, 0x26264c6aU, 0x36366c5aU, 0x3f3f7e41U, 0xf7f7f502U, 0xcccc834fU,
-	0x3434685cU, 0xa5a551f4U, 0xe5e5d134U, 0xf1f1f908U, 0x7171e293U, 0xd8d8ab73U, 0x31316253U, 0x15152a3fU,
-	0x0404080cU, 0xc7c79552U, 0x23234665U, 0xc3c39d5eU, 0x18183028U, 0x969637a1U, 0x05050a0fU, 0x9a9a2fb5U,
-	0x07070e09U, 0x12122436U, 0x80801b9bU, 0xe2e2df3dU, 0xebebcd26U, 0x27274e69U, 0xb2b27fcdU, 0x7575ea9fU,
-	0x0909121bU, 0x83831d9eU, 0x2c2c5874U, 0x1a1a342eU, 0x1b1b362dU, 0x6e6edcb2U, 0x5a5ab4eeU, 0xa0a05bfbU,
-	0x5252a4f6U, 0x3b3b764dU, 0xd6d6b761U, 0xb3b37dceU, 0x2929527bU, 0xe3e3dd3eU, 0x2f2f5e71U, 0x84841397U,
-	0x5353a6f5U, 0xd1d1b968U, 0x00000000U, 0xededc12cU, 0x20204060U, 0xfcfce31fU, 0xb1b179c8U, 0x5b5bb6edU,
-	0x6a6ad4beU, 0xcbcb8d46U, 0xbebe67d9U, 0x3939724bU, 0x4a4a94deU, 0x4c4c98d4U, 0x5858b0e8U, 0xcfcf854aU,
-	0xd0d0bb6bU, 0xefefc52aU, 0xaaaa4fe5U, 0xfbfbed16U, 0x434386c5U, 0x4d4d9ad7U, 0x33336655U, 0x85851194U,
-	0x45458acfU, 0xf9f9e910U, 0x02020406U, 0x7f7ffe81U, 0x5050a0f0U, 0x3c3c7844U, 0x9f9f25baU, 0xa8a84be3U,
-	0x5151a2f3U, 0xa3a35dfeU, 0x404080c0U, 0x8f8f058aU, 0x92923fadU, 0x9d9d21bcU, 0x38387048U, 0xf5f5f104U,
-	0xbcbc63dfU, 0xb6b677c1U, 0xdadaaf75U, 0x21214263U, 0x10102030U, 0xffffe51aU, 0xf3f3fd0eU, 0xd2d2bf6dU,
-	0xcdcd814cU, 0x0c0c1814U, 0x13132635U, 0xececc32fU, 0x5f5fbee1U, 0x979735a2U, 0x444488ccU, 0x17172e39U,
-	0xc4c49357U, 0xa7a755f2U, 0x7e7efc82U, 0x3d3d7a47U, 0x6464c8acU, 0x5d5dbae7U, 0x1919322bU, 0x7373e695U,
-	0x6060c0a0U, 0x81811998U, 0x4f4f9ed1U, 0xdcdca37fU, 0x22224466U, 0x2a2a547eU, 0x90903babU, 0x88880b83U,
-	0x46468ccaU, 0xeeeec729U, 0xb8b86bd3U, 0x1414283cU, 0xdedea779U, 0x5e5ebce2U, 0x0b0b161dU, 0xdbdbad76U,
-	0xe0e0db3bU, 0x32326456U, 0x3a3a744eU, 0x0a0a141eU, 0x494992dbU, 0x06060c0aU, 0x2424486cU, 0x5c5cb8e4U,
-	0xc2c29f5dU, 0xd3d3bd6eU, 0xacac43efU, 0x6262c4a6U, 0x919139a8U, 0x959531a4U, 0xe4e4d337U, 0x7979f28bU,
-	0xe7e7d532U, 0xc8c88b43U, 0x37376e59U, 0x6d6ddab7U, 0x8d8d018cU, 0xd5d5b164U, 0x4e4e9cd2U, 0xa9a949e0U,
-	0x6c6cd8b4U, 0x5656acfaU, 0xf4f4f307U, 0xeaeacf25U, 0x6565caafU, 0x7a7af48eU, 0xaeae47e9U, 0x08081018U,
-	0xbaba6fd5U, 0x7878f088U, 0x25254a6fU, 0x2e2e5c72U, 0x1c1c3824U, 0xa6a657f1U, 0xb4b473c7U, 0xc6c69751U,
-	0xe8e8cb23U, 0xdddda17cU, 0x7474e89cU, 0x1f1f3e21U, 0x4b4b96ddU, 0xbdbd61dcU, 0x8b8b0d86U, 0x8a8a0f85U,
-	0x7070e090U, 0x3e3e7c42U, 0xb5b571c4U, 0x6666ccaaU, 0x484890d8U, 0x03030605U, 0xf6f6f701U, 0x0e0e1c12U,
-	0x6161c2a3U, 0x35356a5fU, 0x5757aef9U, 0xb9b969d0U, 0x86861791U, 0xc1c19958U, 0x1d1d3a27U, 0x9e9e27b9U,
-	0xe1e1d938U, 0xf8f8eb13U, 0x98982bb3U, 0x11112233U, 0x6969d2bbU, 0xd9d9a970U, 0x8e8e0789U, 0x949433a7U,
-	0x9b9b2db6U, 0x1e1e3c22U, 0x87871592U, 0xe9e9c920U, 0xcece8749U, 0x5555aaffU, 0x28285078U, 0xdfdfa57aU,
-	0x8c8c038fU, 0xa1a159f8U, 0x89890980U, 0x0d0d1a17U, 0xbfbf65daU, 0xe6e6d731U, 0x424284c6U, 0x6868d0b8U,
-	0x414182c3U, 0x999929b0U, 0x2d2d5a77U, 0x0f0f1e11U, 0xb0b07bcbU, 0x5454a8fcU, 0xbbbb6dd6U, 0x16162c3aU,
-
-	0x63c6a563U, 0x7cf8847cU, 0x77ee9977U, 0x7bf68d7bU, 0xf2ff0df2U, 0x6bd6bd6bU, 0x6fdeb16fU, 0xc59154c5U,
-	0x30605030U, 0x01020301U, 0x67cea967U, 0x2b567d2bU, 0xfee719feU, 0xd7b562d7U, 0xab4de6abU, 0x76ec9a76U,
-	0xca8f45caU, 0x821f9d82U, 0xc98940c9U, 0x7dfa877dU, 0xfaef15faU, 0x59b2eb59U, 0x478ec947U, 0xf0fb0bf0U,
-	0xad41ecadU, 0xd4b367d4U, 0xa25ffda2U, 0xaf45eaafU, 0x9c23bf9cU, 0xa453f7a4U, 0x72e49672U, 0xc09b5bc0U,
-	0xb775c2b7U, 0xfde11cfdU, 0x933dae93U, 0x264c6a26U, 0x366c5a36U, 0x3f7e413fU, 0xf7f502f7U, 0xcc834fccU,
-	0x34685c34U, 0xa551f4a5U, 0xe5d134e5U, 0xf1f908f1U, 0x71e29371U, 0xd8ab73d8U, 0x31625331U, 0x152a3f15U,
-	0x04080c04U, 0xc79552c7U, 0x23466523U, 0xc39d5ec3U, 0x18302818U, 0x9637a196U, 0x050a0f05U, 0x9a2fb59aU,
-	0x070e0907U, 0x12243612U, 0x801b9b80U, 0xe2df3de2U, 0xebcd26ebU, 0x274e6927U, 0xb27fcdb2U, 0x75ea9f75U,
-	0x09121b09U, 0x831d9e83U, 0x2c58742cU, 0x1a342e1aU, 0x1b362d1bU, 0x6edcb26eU, 0x5ab4ee5aU, 0xa05bfba0U,
-	0x52a4f652U, 0x3b764d3bU, 0xd6b761d6U, 0xb37dceb3U, 0x29527b29U, 0xe3dd3ee3U, 0x2f5e712fU, 0x84139784U,
-	0x53a6f553U, 0xd1b968d1U, 0x00000000U, 0xedc12cedU, 0x20406020U, 0xfce31ffcU, 0xb179c8b1U, 0x5bb6ed5bU,
-	0x6ad4be6aU, 0xcb8d46cbU, 0xbe67d9beU, 0x39724b39U, 0x4a94de4aU, 0x4c98d44cU, 0x58b0e858U, 0xcf854acfU,
-	0xd0bb6bd0U, 0xefc52aefU, 0xaa4fe5aaU, 0xfbed16fbU, 0x4386c543U, 0x4d9ad74dU, 0x33665533U, 0x85119485U,
-	0x458acf45U, 0xf9e910f9U, 0x02040602U, 0x7ffe817fU, 0x50a0f050U, 0x3c78443cU, 0x9f25ba9fU, 0xa84be3a8U,
-	0x51a2f351U, 0xa35dfea3U, 0x4080c040U, 0x8f058a8fU, 0x923fad92U, 0x9d21bc9dU, 0x38704838U, 0xf5f104f5U,
-	0xbc63dfbcU, 0xb677c1b6U, 0xdaaf75daU, 0x21426321U, 0x10203010U, 0xffe51affU, 0xf3fd0ef3U, 0xd2bf6dd2U,
-	0xcd814ccdU, 0x0c18140cU, 0x13263513U, 0xecc32fecU, 0x5fbee15fU, 0x9735a297U, 0x4488cc44U, 0x172e3917U,
-	0xc49357c4U, 0xa755f2a7U, 0x7efc827eU, 0x3d7a473dU, 0x64c8ac64U, 0x5dbae75dU, 0x19322b19U, 0x73e69573U,
-	0x60c0a060U, 0x81199881U, 0x4f9ed14fU, 0xdca37fdcU, 0x22446622U, 0x2a547e2aU, 0x903bab90U, 0x880b8388U,
-	0x468cca46U, 0xeec729eeU, 0xb86bd3b8U, 0x14283c14U, 0xdea779deU, 0x5ebce25eU, 0x0b161d0bU, 0xdbad76dbU,
-	0xe0db3be0U, 0x32645632U, 0x3a744e3aU, 0x0a141e0aU, 0x4992db49U, 0x060c0a06U, 0x24486c24U, 0x5cb8e45cU,
-	0xc29f5dc2U, 0xd3bd6ed3U, 0xac43efacU, 0x62c4a662U, 0x9139a891U, 0x9531a495U, 0xe4d337e4U, 0x79f28b79U,
-	0xe7d532e7U, 0xc88b43c8U, 0x376e5937U, 0x6ddab76dU, 0x8d018c8dU, 0xd5b164d5U, 0x4e9cd24eU, 0xa949e0a9U,
-	0x6cd8b46cU, 0x56acfa56U, 0xf4f307f4U, 0xeacf25eaU, 0x65caaf65U, 0x7af48e7aU, 0xae47e9aeU, 0x08101808U,
-	0xba6fd5baU, 0x78f08878U, 0x254a6f25U, 0x2e5c722eU, 0x1c38241cU, 0xa657f1a6U, 0xb473c7b4U, 0xc69751c6U,
-	0xe8cb23e8U, 0xdda17cddU, 0x74e89c74U, 0x1f3e211fU, 0x4b96dd4bU, 0xbd61dcbdU, 0x8b0d868bU, 0x8a0f858aU,
-	0x70e09070U, 0x3e7c423eU, 0xb571c4b5U, 0x66ccaa66U, 0x4890d848U, 0x03060503U, 0xf6f701f6U, 0x0e1c120eU,
-	0x61c2a361U, 0x356a5f35U, 0x57aef957U, 0xb969d0b9U, 0x86179186U, 0xc19958c1U, 0x1d3a271dU, 0x9e27b99eU,
-	0xe1d938e1U, 0xf8eb13f8U, 0x982bb398U, 0x11223311U, 0x69d2bb69U, 0xd9a970d9U, 0x8e07898eU, 0x9433a794U,
-	0x9b2db69bU, 0x1e3c221eU, 0x87159287U, 0xe9c920e9U, 0xce8749ceU, 0x55aaff55U, 0x28507828U, 0xdfa57adfU,
-	0x8c038f8cU, 0xa159f8a1U, 0x89098089U, 0x0d1a170dU, 0xbf65dabfU, 0xe6d731e6U, 0x4284c642U, 0x68d0b868U,
-	0x4182c341U, 0x9929b099U, 0x2d5a772dU, 0x0f1e110fU, 0xb07bcbb0U, 0x54a8fc54U, 0xbb6dd6bbU, 0x162c3a16U,
-
-	0xc6a56363U, 0xf8847c7cU, 0xee997777U, 0xf68d7b7bU, 0xff0df2f2U, 0xd6bd6b6bU, 0xdeb16f6fU, 0x9154c5c5U,
-	0x60503030U, 0x02030101U, 0xcea96767U, 0x567d2b2bU, 0xe719fefeU, 0xb562d7d7U, 0x4de6ababU, 0xec9a7676U,
-	0x8f45cacaU, 0x1f9d8282U, 0x8940c9c9U, 0xfa877d7dU, 0xef15fafaU, 0xb2eb5959U, 0x8ec94747U, 0xfb0bf0f0U,
-	0x41ecadadU, 0xb367d4d4U, 0x5ffda2a2U, 0x45eaafafU, 0x23bf9c9cU, 0x53f7a4a4U, 0xe4967272U, 0x9b5bc0c0U,
-	0x75c2b7b7U, 0xe11cfdfdU, 0x3dae9393U, 0x4c6a2626U, 0x6c5a3636U, 0x7e413f3fU, 0xf502f7f7U, 0x834fccccU,
-	0x685c3434U, 0x51f4a5a5U, 0xd134e5e5U, 0xf908f1f1U, 0xe2937171U, 0xab73d8d8U, 0x62533131U, 0x2a3f1515U,
-	0x080c0404U, 0x9552c7c7U, 0x46652323U, 0x9d5ec3c3U, 0x30281818U, 0x37a19696U, 0x0a0f0505U, 0x2fb59a9aU,
-	0x0e090707U, 0x24361212U, 0x1b9b8080U, 0xdf3de2e2U, 0xcd26ebebU, 0x4e692727U, 0x7fcdb2b2U, 0xea9f7575U,
-	0x121b0909U, 0x1d9e8383U, 0x58742c2cU, 0x342e1a1aU, 0x362d1b1bU, 0xdcb26e6eU, 0xb4ee5a5aU, 0x5bfba0a0U,
-	0xa4f65252U, 0x764d3b3bU, 0xb761d6d6U, 0x7dceb3b3U, 0x527b2929U, 0xdd3ee3e3U, 0x5e712f2fU, 0x13978484U,
-	0xa6f55353U, 0xb968d1d1U, 0x00000000U, 0xc12cededU, 0x40602020U, 0xe31ffcfcU, 0x79c8b1b1U, 0xb6ed5b5bU,
-	0xd4be6a6aU, 0x8d46cbcbU, 0x67d9bebeU, 0x724b3939U, 0x94de4a4aU, 0x98d44c4cU, 0xb0e85858U, 0x854acfcfU,
-	0xbb6bd0d0U, 0xc52aefefU, 0x4fe5aaaaU, 0xed16fbfbU, 0x86c54343U, 0x9ad74d4dU, 0x66553333U, 0x11948585U,
-	0x8acf4545U, 0xe910f9f9U, 0x04060202U, 0xfe817f7fU, 0xa0f05050U, 0x78443c3cU, 0x25ba9f9fU, 0x4be3a8a8U,
-	0xa2f35151U, 0x5dfea3a3U, 0x80c04040U, 0x058a8f8fU, 0x3fad9292U, 0x21bc9d9dU, 0x70483838U, 0xf104f5f5U,
-	0x63dfbcbcU, 0x77c1b6b6U, 0xaf75dadaU, 0x42632121U, 0x20301010U, 0xe51affffU, 0xfd0ef3f3U, 0xbf6dd2d2U,
-	0x814ccdcdU, 0x18140c0cU, 0x26351313U, 0xc32fececU, 0xbee15f5fU, 0x35a29797U, 0x88cc4444U, 0x2e391717U,
-	0x9357c4c4U, 0x55f2a7a7U, 0xfc827e7eU, 0x7a473d3dU, 0xc8ac6464U, 0xbae75d5dU, 0x322b1919U, 0xe6957373U,
-	0xc0a06060U, 0x19988181U, 0x9ed14f4fU, 0xa37fdcdcU, 0x44662222U, 0x547e2a2aU, 0x3bab9090U, 0x0b838888U,
-	0x8cca4646U, 0xc729eeeeU, 0x6bd3b8b8U, 0x283c1414U, 0xa779dedeU, 0xbce25e5eU, 0x161d0b0bU, 0xad76dbdbU,
-	0xdb3be0e0U, 0x64563232U, 0x744e3a3aU, 0x141e0a0aU, 0x92db4949U, 0x0c0a0606U, 0x486c2424U, 0xb8e45c5cU,
-	0x9f5dc2c2U, 0xbd6ed3d3U, 0x43efacacU, 0xc4a66262U, 0x39a89191U, 0x31a49595U, 0xd337e4e4U, 0xf28b7979U,
-	0xd532e7e7U, 0x8b43c8c8U, 0x6e593737U, 0xdab76d6dU, 0x018c8d8dU, 0xb164d5d5U, 0x9cd24e4eU, 0x49e0a9a9U,
-	0xd8b46c6cU, 0xacfa5656U, 0xf307f4f4U, 0xcf25eaeaU, 0xcaaf6565U, 0xf48e7a7aU, 0x47e9aeaeU, 0x10180808U,
-	0x6fd5babaU, 0xf0887878U, 0x4a6f2525U, 0x5c722e2eU, 0x38241c1cU, 0x57f1a6a6U, 0x73c7b4b4U, 0x9751c6c6U,
-	0xcb23e8e8U, 0xa17cddddU, 0xe89c7474U, 0x3e211f1fU, 0x96dd4b4bU, 0x61dcbdbdU, 0x0d868b8bU, 0x0f858a8aU,
-	0xe0907070U, 0x7c423e3eU, 0x71c4b5b5U, 0xccaa6666U, 0x90d84848U, 0x06050303U, 0xf701f6f6U, 0x1c120e0eU,
-	0xc2a36161U, 0x6a5f3535U, 0xaef95757U, 0x69d0b9b9U, 0x17918686U, 0x9958c1c1U, 0x3a271d1dU, 0x27b99e9eU,
-	0xd938e1e1U, 0xeb13f8f8U, 0x2bb39898U, 0x22331111U, 0xd2bb6969U, 0xa970d9d9U, 0x07898e8eU, 0x33a79494U,
-	0x2db69b9bU, 0x3c221e1eU, 0x15928787U, 0xc920e9e9U, 0x8749ceceU, 0xaaff5555U, 0x50782828U, 0xa57adfdfU,
-	0x038f8c8cU, 0x59f8a1a1U, 0x09808989U, 0x1a170d0dU, 0x65dabfbfU, 0xd731e6e6U, 0x84c64242U, 0xd0b86868U,
-	0x82c34141U, 0x29b09999U, 0x5a772d2dU, 0x1e110f0fU, 0x7bcbb0b0U, 0xa8fc5454U, 0x6dd6bbbbU, 0x2c3a1616U
-};
-*/
-
-#define AS_U32(addr) *((uint32_t*)(addr))
-#define AS_UINT2(addr) *((uint2*)(addr))
-#define AS_UINT4(addr) *((uint4*)(addr))
-#define AS_UL2(addr) *((ulonglong2*)(addr))
-
-#define t_fn0(x) (sharedMemory[x])
-#define t_fn1(x) (sharedMemory[0x100U | (x)])
-#define t_fn2(x) (sharedMemory[0x200U | (x)])
-#define t_fn3(x) (sharedMemory[0x300U | (x)])
-
-#define round(shared, out, x, k) \
-	out[0] = (k)[0] ^ (t_fn0(x[0] & 0xff) ^ t_fn1((x[1] >> 8) & 0xff) ^ t_fn2((x[2] >> 16) & 0xff) ^ t_fn3((x[3] >> 24) & 0xff)); \
-	out[1] = (k)[1] ^ (t_fn0(x[1] & 0xff) ^ t_fn1((x[2] >> 8) & 0xff) ^ t_fn2((x[3] >> 16) & 0xff) ^ t_fn3((x[0] >> 24) & 0xff)); \
-	out[2] = (k)[2] ^ (t_fn0(x[2] & 0xff) ^ t_fn1((x[3] >> 8) & 0xff) ^ t_fn2((x[0] >> 16) & 0xff) ^ t_fn3((x[1] >> 24) & 0xff)); \
-	out[3] = (k)[3] ^ (t_fn0(x[3] & 0xff) ^ t_fn1((x[0] >> 8) & 0xff) ^ t_fn2((x[1] >> 16) & 0xff) ^ t_fn3((x[2] >> 24) & 0xff));
-
-#define round_u4(shared, out, in, k) \
-	((uint32_t*)out)[0] = (k)[0] ^ t_fn0(in[0].x) ^ t_fn1(in[1].y) ^ t_fn2(in[2].z) ^ t_fn3(in[3].w); \
-	((uint32_t*)out)[1] = (k)[1] ^ t_fn0(in[1].x) ^ t_fn1(in[2].y) ^ t_fn2(in[3].z) ^ t_fn3(in[0].w); \
-	((uint32_t*)out)[2] = (k)[2] ^ t_fn0(in[2].x) ^ t_fn1(in[3].y) ^ t_fn2(in[0].z) ^ t_fn3(in[1].w); \
-	((uint32_t*)out)[3] = (k)[3] ^ t_fn0(in[3].x) ^ t_fn1(in[0].y) ^ t_fn2(in[1].z) ^ t_fn3(in[2].w);
-
-#ifdef __INTELLISENSE__
-#define __byte_perm(a,b,c) a
-#endif
-
-#define OFF32_0(x) (x & 0xFFu)
-#define OFF32_1(x) __byte_perm(x, 0x01, 0x5541)
-#define OFF32_2(x) __byte_perm(x, 0x02, 0x5542)
-#define OFF32_3(x) __byte_perm(x, 0x03, 0x5543)
-
-#define SHARED_0(x) sharedMemory[OFF32_0(x)]
-#define SHARED_1(x) sharedMemory[OFF32_1(x)]
-#define SHARED_2(x) sharedMemory[OFF32_2(x)]
-#define SHARED_3(x) sharedMemory[OFF32_3(x)]
-
-__device__ __forceinline__
-void cn_aes_single_round(uint32_t * const sharedMemory, uint32_t * const in, uint32_t * out, uint32_t* expandedKey)
+static __constant__ uint32_t d_t_fn[1024] =
 {
-	asm("// aes_single_round");
-	out[0] = expandedKey[0] ^ SHARED_0(in[0]) ^ SHARED_1(in[1]) ^ SHARED_2(in[2]) ^ SHARED_3(in[3]);
-	out[1] = expandedKey[1] ^ SHARED_0(in[1]) ^ SHARED_1(in[2]) ^ SHARED_2(in[3]) ^ SHARED_3(in[0]);
-	out[2] = expandedKey[2] ^ SHARED_0(in[2]) ^ SHARED_1(in[3]) ^ SHARED_2(in[0]) ^ SHARED_3(in[1]);
-	out[3] = expandedKey[3] ^ SHARED_0(in[3]) ^ SHARED_1(in[0]) ^ SHARED_2(in[1]) ^ SHARED_3(in[2]);
-}
-
-//
-#ifdef _WIN64
-/* do a mul.wide.u32 to prevent a shl + cvt 32 to 64 on ld.shared [ptr] */
-#define OFF8_0(x) (x & 0xFFu) * sizeof(uint32_t)
-#define OFF8_1(x) __byte_perm(x, 0x01, 0x5541) * sizeof(uint32_t)
-#define OFF8_2(x) __byte_perm(x, 0x02, 0x5542) * sizeof(uint32_t)
-#define OFF8_3(x) __byte_perm(x, 0x03, 0x5543) * sizeof(uint32_t)
-#else
-#define OFF8_0(x) (x & 0xFFu) << 2
-#define OFF8_1(x) __byte_perm(x, 0x01, 0x5541) << 2
-#define OFF8_2(x) __byte_perm(x, 0x02, 0x5542) << 2
-#define OFF8_3(x) __byte_perm(x, 0x03, 0x5543) << 2
-#endif
+	0xa56363c6U, 0x847c7cf8U, 0x997777eeU, 0x8d7b7bf6U,
+	0x0df2f2ffU, 0xbd6b6bd6U, 0xb16f6fdeU, 0x54c5c591U,
+	0x50303060U, 0x03010102U, 0xa96767ceU, 0x7d2b2b56U,
+	0x19fefee7U, 0x62d7d7b5U, 0xe6abab4dU, 0x9a7676ecU,
+	0x45caca8fU, 0x9d82821fU, 0x40c9c989U, 0x877d7dfaU,
+	0x15fafaefU, 0xeb5959b2U, 0xc947478eU, 0x0bf0f0fbU,
+	0xecadad41U, 0x67d4d4b3U, 0xfda2a25fU, 0xeaafaf45U,
+	0xbf9c9c23U, 0xf7a4a453U, 0x967272e4U, 0x5bc0c09bU,
+	0xc2b7b775U, 0x1cfdfde1U, 0xae93933dU, 0x6a26264cU,
+	0x5a36366cU, 0x413f3f7eU, 0x02f7f7f5U, 0x4fcccc83U,
+	0x5c343468U, 0xf4a5a551U, 0x34e5e5d1U, 0x08f1f1f9U,
+	0x937171e2U, 0x73d8d8abU, 0x53313162U, 0x3f15152aU,
+	0x0c040408U, 0x52c7c795U, 0x65232346U, 0x5ec3c39dU,
+	0x28181830U, 0xa1969637U, 0x0f05050aU, 0xb59a9a2fU,
+	0x0907070eU, 0x36121224U, 0x9b80801bU, 0x3de2e2dfU,
+	0x26ebebcdU, 0x6927274eU, 0xcdb2b27fU, 0x9f7575eaU,
+	0x1b090912U, 0x9e83831dU, 0x742c2c58U, 0x2e1a1a34U,
+	0x2d1b1b36U, 0xb26e6edcU, 0xee5a5ab4U, 0xfba0a05bU,
+	0xf65252a4U, 0x4d3b3b76U, 0x61d6d6b7U, 0xceb3b37dU,
+	0x7b292952U, 0x3ee3e3ddU, 0x712f2f5eU, 0x97848413U,
+	0xf55353a6U, 0x68d1d1b9U, 0x00000000U, 0x2cededc1U,
+	0x60202040U, 0x1ffcfce3U, 0xc8b1b179U, 0xed5b5bb6U,
+	0xbe6a6ad4U, 0x46cbcb8dU, 0xd9bebe67U, 0x4b393972U,
+	0xde4a4a94U, 0xd44c4c98U, 0xe85858b0U, 0x4acfcf85U,
+	0x6bd0d0bbU, 0x2aefefc5U, 0xe5aaaa4fU, 0x16fbfbedU,
+	0xc5434386U, 0xd74d4d9aU, 0x55333366U, 0x94858511U,
+	0xcf45458aU, 0x10f9f9e9U, 0x06020204U, 0x817f7ffeU,
+	0xf05050a0U, 0x443c3c78U, 0xba9f9f25U, 0xe3a8a84bU,
+	0xf35151a2U, 0xfea3a35dU, 0xc0404080U, 0x8a8f8f05U,
+	0xad92923fU, 0xbc9d9d21U, 0x48383870U, 0x04f5f5f1U,
+	0xdfbcbc63U, 0xc1b6b677U, 0x75dadaafU, 0x63212142U,
+	0x30101020U, 0x1affffe5U, 0x0ef3f3fdU, 0x6dd2d2bfU,
+	0x4ccdcd81U, 0x140c0c18U, 0x35131326U, 0x2fececc3U,
+	0xe15f5fbeU, 0xa2979735U, 0xcc444488U, 0x3917172eU,
+	0x57c4c493U, 0xf2a7a755U, 0x827e7efcU, 0x473d3d7aU,
+	0xac6464c8U, 0xe75d5dbaU, 0x2b191932U, 0x957373e6U,
+	0xa06060c0U, 0x98818119U, 0xd14f4f9eU, 0x7fdcdca3U,
+	0x66222244U, 0x7e2a2a54U, 0xab90903bU, 0x8388880bU,
+	0xca46468cU, 0x29eeeec7U, 0xd3b8b86bU, 0x3c141428U,
+	0x79dedea7U, 0xe25e5ebcU, 0x1d0b0b16U, 0x76dbdbadU,
+	0x3be0e0dbU, 0x56323264U, 0x4e3a3a74U, 0x1e0a0a14U,
+	0xdb494992U, 0x0a06060cU, 0x6c242448U, 0xe45c5cb8U,
+	0x5dc2c29fU, 0x6ed3d3bdU, 0xefacac43U, 0xa66262c4U,
+	0xa8919139U, 0xa4959531U, 0x37e4e4d3U, 0x8b7979f2U,
+	0x32e7e7d5U, 0x43c8c88bU, 0x5937376eU, 0xb76d6ddaU,
+	0x8c8d8d01U, 0x64d5d5b1U, 0xd24e4e9cU, 0xe0a9a949U,
+	0xb46c6cd8U, 0xfa5656acU, 0x07f4f4f3U, 0x25eaeacfU,
+	0xaf6565caU, 0x8e7a7af4U, 0xe9aeae47U, 0x18080810U,
+	0xd5baba6fU, 0x887878f0U, 0x6f25254aU, 0x722e2e5cU,
+	0x241c1c38U, 0xf1a6a657U, 0xc7b4b473U, 0x51c6c697U,
+	0x23e8e8cbU, 0x7cdddda1U, 0x9c7474e8U, 0x211f1f3eU,
+	0xdd4b4b96U, 0xdcbdbd61U, 0x868b8b0dU, 0x858a8a0fU,
+	0x907070e0U, 0x423e3e7cU, 0xc4b5b571U, 0xaa6666ccU,
+	0xd8484890U, 0x05030306U, 0x01f6f6f7U, 0x120e0e1cU,
+	0xa36161c2U, 0x5f35356aU, 0xf95757aeU, 0xd0b9b969U,
+	0x91868617U, 0x58c1c199U, 0x271d1d3aU, 0xb99e9e27U,
+	0x38e1e1d9U, 0x13f8f8ebU, 0xb398982bU, 0x33111122U,
+	0xbb6969d2U, 0x70d9d9a9U, 0x898e8e07U, 0xa7949433U,
+	0xb69b9b2dU, 0x221e1e3cU, 0x92878715U, 0x20e9e9c9U,
+	0x49cece87U, 0xff5555aaU, 0x78282850U, 0x7adfdfa5U,
+	0x8f8c8c03U, 0xf8a1a159U, 0x80898909U, 0x170d0d1aU,
+	0xdabfbf65U, 0x31e6e6d7U, 0xc6424284U, 0xb86868d0U,
+	0xc3414182U, 0xb0999929U, 0x772d2d5aU, 0x110f0f1eU,
+	0xcbb0b07bU, 0xfc5454a8U, 0xd6bbbb6dU, 0x3a16162cU,
+	0x6363c6a5U, 0x7c7cf884U, 0x7777ee99U, 0x7b7bf68dU,
+	0xf2f2ff0dU, 0x6b6bd6bdU, 0x6f6fdeb1U, 0xc5c59154U,
+	0x30306050U, 0x01010203U, 0x6767cea9U, 0x2b2b567dU,
+	0xfefee719U, 0xd7d7b562U, 0xabab4de6U, 0x7676ec9aU,
+	0xcaca8f45U, 0x82821f9dU, 0xc9c98940U, 0x7d7dfa87U,
+	0xfafaef15U, 0x5959b2ebU, 0x47478ec9U, 0xf0f0fb0bU,
+	0xadad41ecU, 0xd4d4b367U, 0xa2a25ffdU, 0xafaf45eaU,
+	0x9c9c23bfU, 0xa4a453f7U, 0x7272e496U, 0xc0c09b5bU,
+	0xb7b775c2U, 0xfdfde11cU, 0x93933daeU, 0x26264c6aU,
+	0x36366c5aU, 0x3f3f7e41U, 0xf7f7f502U, 0xcccc834fU,
+	0x3434685cU, 0xa5a551f4U, 0xe5e5d134U, 0xf1f1f908U,
+	0x7171e293U, 0xd8d8ab73U, 0x31316253U, 0x15152a3fU,
+	0x0404080cU, 0xc7c79552U, 0x23234665U, 0xc3c39d5eU,
+	0x18183028U, 0x969637a1U, 0x05050a0fU, 0x9a9a2fb5U,
+	0x07070e09U, 0x12122436U, 0x80801b9bU, 0xe2e2df3dU,
+	0xebebcd26U, 0x27274e69U, 0xb2b27fcdU, 0x7575ea9fU,
+	0x0909121bU, 0x83831d9eU, 0x2c2c5874U, 0x1a1a342eU,
+	0x1b1b362dU, 0x6e6edcb2U, 0x5a5ab4eeU, 0xa0a05bfbU,
+	0x5252a4f6U, 0x3b3b764dU, 0xd6d6b761U, 0xb3b37dceU,
+	0x2929527bU, 0xe3e3dd3eU, 0x2f2f5e71U, 0x84841397U,
+	0x5353a6f5U, 0xd1d1b968U, 0x00000000U, 0xededc12cU,
+	0x20204060U, 0xfcfce31fU, 0xb1b179c8U, 0x5b5bb6edU,
+	0x6a6ad4beU, 0xcbcb8d46U, 0xbebe67d9U, 0x3939724bU,
+	0x4a4a94deU, 0x4c4c98d4U, 0x5858b0e8U, 0xcfcf854aU,
+	0xd0d0bb6bU, 0xefefc52aU, 0xaaaa4fe5U, 0xfbfbed16U,
+	0x434386c5U, 0x4d4d9ad7U, 0x33336655U, 0x85851194U,
+	0x45458acfU, 0xf9f9e910U, 0x02020406U, 0x7f7ffe81U,
+	0x5050a0f0U, 0x3c3c7844U, 0x9f9f25baU, 0xa8a84be3U,
+	0x5151a2f3U, 0xa3a35dfeU, 0x404080c0U, 0x8f8f058aU,
+	0x92923fadU, 0x9d9d21bcU, 0x38387048U, 0xf5f5f104U,
+	0xbcbc63dfU, 0xb6b677c1U, 0xdadaaf75U, 0x21214263U,
+	0x10102030U, 0xffffe51aU, 0xf3f3fd0eU, 0xd2d2bf6dU,
+	0xcdcd814cU, 0x0c0c1814U, 0x13132635U, 0xececc32fU,
+	0x5f5fbee1U, 0x979735a2U, 0x444488ccU, 0x17172e39U,
+	0xc4c49357U, 0xa7a755f2U, 0x7e7efc82U, 0x3d3d7a47U,
+	0x6464c8acU, 0x5d5dbae7U, 0x1919322bU, 0x7373e695U,
+	0x6060c0a0U, 0x81811998U, 0x4f4f9ed1U, 0xdcdca37fU,
+	0x22224466U, 0x2a2a547eU, 0x90903babU, 0x88880b83U,
+	0x46468ccaU, 0xeeeec729U, 0xb8b86bd3U, 0x1414283cU,
+	0xdedea779U, 0x5e5ebce2U, 0x0b0b161dU, 0xdbdbad76U,
+	0xe0e0db3bU, 0x32326456U, 0x3a3a744eU, 0x0a0a141eU,
+	0x494992dbU, 0x06060c0aU, 0x2424486cU, 0x5c5cb8e4U,
+	0xc2c29f5dU, 0xd3d3bd6eU, 0xacac43efU, 0x6262c4a6U,
+	0x919139a8U, 0x959531a4U, 0xe4e4d337U, 0x7979f28bU,
+	0xe7e7d532U, 0xc8c88b43U, 0x37376e59U, 0x6d6ddab7U,
+	0x8d8d018cU, 0xd5d5b164U, 0x4e4e9cd2U, 0xa9a949e0U,
+	0x6c6cd8b4U, 0x5656acfaU, 0xf4f4f307U, 0xeaeacf25U,
+	0x6565caafU, 0x7a7af48eU, 0xaeae47e9U, 0x08081018U,
+	0xbaba6fd5U, 0x7878f088U, 0x25254a6fU, 0x2e2e5c72U,
+	0x1c1c3824U, 0xa6a657f1U, 0xb4b473c7U, 0xc6c69751U,
+	0xe8e8cb23U, 0xdddda17cU, 0x7474e89cU, 0x1f1f3e21U,
+	0x4b4b96ddU, 0xbdbd61dcU, 0x8b8b0d86U, 0x8a8a0f85U,
+	0x7070e090U, 0x3e3e7c42U, 0xb5b571c4U, 0x6666ccaaU,
+	0x484890d8U, 0x03030605U, 0xf6f6f701U, 0x0e0e1c12U,
+	0x6161c2a3U, 0x35356a5fU, 0x5757aef9U, 0xb9b969d0U,
+	0x86861791U, 0xc1c19958U, 0x1d1d3a27U, 0x9e9e27b9U,
+	0xe1e1d938U, 0xf8f8eb13U, 0x98982bb3U, 0x11112233U,
+	0x6969d2bbU, 0xd9d9a970U, 0x8e8e0789U, 0x949433a7U,
+	0x9b9b2db6U, 0x1e1e3c22U, 0x87871592U, 0xe9e9c920U,
+	0xcece8749U, 0x5555aaffU, 0x28285078U, 0xdfdfa57aU,
+	0x8c8c038fU, 0xa1a159f8U, 0x89890980U, 0x0d0d1a17U,
+	0xbfbf65daU, 0xe6e6d731U, 0x424284c6U, 0x6868d0b8U,
+	0x414182c3U, 0x999929b0U, 0x2d2d5a77U, 0x0f0f1e11U,
+	0xb0b07bcbU, 0x5454a8fcU, 0xbbbb6dd6U, 0x16162c3aU,
+	0x63c6a563U, 0x7cf8847cU, 0x77ee9977U, 0x7bf68d7bU,
+	0xf2ff0df2U, 0x6bd6bd6bU, 0x6fdeb16fU, 0xc59154c5U,
+	0x30605030U, 0x01020301U, 0x67cea967U, 0x2b567d2bU,
+	0xfee719feU, 0xd7b562d7U, 0xab4de6abU, 0x76ec9a76U,
+	0xca8f45caU, 0x821f9d82U, 0xc98940c9U, 0x7dfa877dU,
+	0xfaef15faU, 0x59b2eb59U, 0x478ec947U, 0xf0fb0bf0U,
+	0xad41ecadU, 0xd4b367d4U, 0xa25ffda2U, 0xaf45eaafU,
+	0x9c23bf9cU, 0xa453f7a4U, 0x72e49672U, 0xc09b5bc0U,
+	0xb775c2b7U, 0xfde11cfdU, 0x933dae93U, 0x264c6a26U,
+	0x366c5a36U, 0x3f7e413fU, 0xf7f502f7U, 0xcc834fccU,
+	0x34685c34U, 0xa551f4a5U, 0xe5d134e5U, 0xf1f908f1U,
+	0x71e29371U, 0xd8ab73d8U, 0x31625331U, 0x152a3f15U,
+	0x04080c04U, 0xc79552c7U, 0x23466523U, 0xc39d5ec3U,
+	0x18302818U, 0x9637a196U, 0x050a0f05U, 0x9a2fb59aU,
+	0x070e0907U, 0x12243612U, 0x801b9b80U, 0xe2df3de2U,
+	0xebcd26ebU, 0x274e6927U, 0xb27fcdb2U, 0x75ea9f75U,
+	0x09121b09U, 0x831d9e83U, 0x2c58742cU, 0x1a342e1aU,
+	0x1b362d1bU, 0x6edcb26eU, 0x5ab4ee5aU, 0xa05bfba0U,
+	0x52a4f652U, 0x3b764d3bU, 0xd6b761d6U, 0xb37dceb3U,
+	0x29527b29U, 0xe3dd3ee3U, 0x2f5e712fU, 0x84139784U,
+	0x53a6f553U, 0xd1b968d1U, 0x00000000U, 0xedc12cedU,
+	0x20406020U, 0xfce31ffcU, 0xb179c8b1U, 0x5bb6ed5bU,
+	0x6ad4be6aU, 0xcb8d46cbU, 0xbe67d9beU, 0x39724b39U,
+	0x4a94de4aU, 0x4c98d44cU, 0x58b0e858U, 0xcf854acfU,
+	0xd0bb6bd0U, 0xefc52aefU, 0xaa4fe5aaU, 0xfbed16fbU,
+	0x4386c543U, 0x4d9ad74dU, 0x33665533U, 0x85119485U,
+	0x458acf45U, 0xf9e910f9U, 0x02040602U, 0x7ffe817fU,
+	0x50a0f050U, 0x3c78443cU, 0x9f25ba9fU, 0xa84be3a8U,
+	0x51a2f351U, 0xa35dfea3U, 0x4080c040U, 0x8f058a8fU,
+	0x923fad92U, 0x9d21bc9dU, 0x38704838U, 0xf5f104f5U,
+	0xbc63dfbcU, 0xb677c1b6U, 0xdaaf75daU, 0x21426321U,
+	0x10203010U, 0xffe51affU, 0xf3fd0ef3U, 0xd2bf6dd2U,
+	0xcd814ccdU, 0x0c18140cU, 0x13263513U, 0xecc32fecU,
+	0x5fbee15fU, 0x9735a297U, 0x4488cc44U, 0x172e3917U,
+	0xc49357c4U, 0xa755f2a7U, 0x7efc827eU, 0x3d7a473dU,
+	0x64c8ac64U, 0x5dbae75dU, 0x19322b19U, 0x73e69573U,
+	0x60c0a060U, 0x81199881U, 0x4f9ed14fU, 0xdca37fdcU,
+	0x22446622U, 0x2a547e2aU, 0x903bab90U, 0x880b8388U,
+	0x468cca46U, 0xeec729eeU, 0xb86bd3b8U, 0x14283c14U,
+	0xdea779deU, 0x5ebce25eU, 0x0b161d0bU, 0xdbad76dbU,
+	0xe0db3be0U, 0x32645632U, 0x3a744e3aU, 0x0a141e0aU,
+	0x4992db49U, 0x060c0a06U, 0x24486c24U, 0x5cb8e45cU,
+	0xc29f5dc2U, 0xd3bd6ed3U, 0xac43efacU, 0x62c4a662U,
+	0x9139a891U, 0x9531a495U, 0xe4d337e4U, 0x79f28b79U,
+	0xe7d532e7U, 0xc88b43c8U, 0x376e5937U, 0x6ddab76dU,
+	0x8d018c8dU, 0xd5b164d5U, 0x4e9cd24eU, 0xa949e0a9U,
+	0x6cd8b46cU, 0x56acfa56U, 0xf4f307f4U, 0xeacf25eaU,
+	0x65caaf65U, 0x7af48e7aU, 0xae47e9aeU, 0x08101808U,
+	0xba6fd5baU, 0x78f08878U, 0x254a6f25U, 0x2e5c722eU,
+	0x1c38241cU, 0xa657f1a6U, 0xb473c7b4U, 0xc69751c6U,
+	0xe8cb23e8U, 0xdda17cddU, 0x74e89c74U, 0x1f3e211fU,
+	0x4b96dd4bU, 0xbd61dcbdU, 0x8b0d868bU, 0x8a0f858aU,
+	0x70e09070U, 0x3e7c423eU, 0xb571c4b5U, 0x66ccaa66U,
+	0x4890d848U, 0x03060503U, 0xf6f701f6U, 0x0e1c120eU,
+	0x61c2a361U, 0x356a5f35U, 0x57aef957U, 0xb969d0b9U,
+	0x86179186U, 0xc19958c1U, 0x1d3a271dU, 0x9e27b99eU,
+	0xe1d938e1U, 0xf8eb13f8U, 0x982bb398U, 0x11223311U,
+	0x69d2bb69U, 0xd9a970d9U, 0x8e07898eU, 0x9433a794U,
+	0x9b2db69bU, 0x1e3c221eU, 0x87159287U, 0xe9c920e9U,
+	0xce8749ceU, 0x55aaff55U, 0x28507828U, 0xdfa57adfU,
+	0x8c038f8cU, 0xa159f8a1U, 0x89098089U, 0x0d1a170dU,
+	0xbf65dabfU, 0xe6d731e6U, 0x4284c642U, 0x68d0b868U,
+	0x4182c341U, 0x9929b099U, 0x2d5a772dU, 0x0f1e110fU,
+	0xb07bcbb0U, 0x54a8fc54U, 0xbb6dd6bbU, 0x162c3a16U,
+	0xc6a56363U, 0xf8847c7cU, 0xee997777U, 0xf68d7b7bU,
+	0xff0df2f2U, 0xd6bd6b6bU, 0xdeb16f6fU, 0x9154c5c5U,
+	0x60503030U, 0x02030101U, 0xcea96767U, 0x567d2b2bU,
+	0xe719fefeU, 0xb562d7d7U, 0x4de6ababU, 0xec9a7676U,
+	0x8f45cacaU, 0x1f9d8282U, 0x8940c9c9U, 0xfa877d7dU,
+	0xef15fafaU, 0xb2eb5959U, 0x8ec94747U, 0xfb0bf0f0U,
+	0x41ecadadU, 0xb367d4d4U, 0x5ffda2a2U, 0x45eaafafU,
+	0x23bf9c9cU, 0x53f7a4a4U, 0xe4967272U, 0x9b5bc0c0U,
+	0x75c2b7b7U, 0xe11cfdfdU, 0x3dae9393U, 0x4c6a2626U,
+	0x6c5a3636U, 0x7e413f3fU, 0xf502f7f7U, 0x834fccccU,
+	0x685c3434U, 0x51f4a5a5U, 0xd134e5e5U, 0xf908f1f1U,
+	0xe2937171U, 0xab73d8d8U, 0x62533131U, 0x2a3f1515U,
+	0x080c0404U, 0x9552c7c7U, 0x46652323U, 0x9d5ec3c3U,
+	0x30281818U, 0x37a19696U, 0x0a0f0505U, 0x2fb59a9aU,
+	0x0e090707U, 0x24361212U, 0x1b9b8080U, 0xdf3de2e2U,
+	0xcd26ebebU, 0x4e692727U, 0x7fcdb2b2U, 0xea9f7575U,
+	0x121b0909U, 0x1d9e8383U, 0x58742c2cU, 0x342e1a1aU,
+	0x362d1b1bU, 0xdcb26e6eU, 0xb4ee5a5aU, 0x5bfba0a0U,
+	0xa4f65252U, 0x764d3b3bU, 0xb761d6d6U, 0x7dceb3b3U,
+	0x527b2929U, 0xdd3ee3e3U, 0x5e712f2fU, 0x13978484U,
+	0xa6f55353U, 0xb968d1d1U, 0x00000000U, 0xc12cededU,
+	0x40602020U, 0xe31ffcfcU, 0x79c8b1b1U, 0xb6ed5b5bU,
+	0xd4be6a6aU, 0x8d46cbcbU, 0x67d9bebeU, 0x724b3939U,
+	0x94de4a4aU, 0x98d44c4cU, 0xb0e85858U, 0x854acfcfU,
+	0xbb6bd0d0U, 0xc52aefefU, 0x4fe5aaaaU, 0xed16fbfbU,
+	0x86c54343U, 0x9ad74d4dU, 0x66553333U, 0x11948585U,
+	0x8acf4545U, 0xe910f9f9U, 0x04060202U, 0xfe817f7fU,
+	0xa0f05050U, 0x78443c3cU, 0x25ba9f9fU, 0x4be3a8a8U,
+	0xa2f35151U, 0x5dfea3a3U, 0x80c04040U, 0x058a8f8fU,
+	0x3fad9292U, 0x21bc9d9dU, 0x70483838U, 0xf104f5f5U,
+	0x63dfbcbcU, 0x77c1b6b6U, 0xaf75dadaU, 0x42632121U,
+	0x20301010U, 0xe51affffU, 0xfd0ef3f3U, 0xbf6dd2d2U,
+	0x814ccdcdU, 0x18140c0cU, 0x26351313U, 0xc32fececU,
+	0xbee15f5fU, 0x35a29797U, 0x88cc4444U, 0x2e391717U,
+	0x9357c4c4U, 0x55f2a7a7U, 0xfc827e7eU, 0x7a473d3dU,
+	0xc8ac6464U, 0xbae75d5dU, 0x322b1919U, 0xe6957373U,
+	0xc0a06060U, 0x19988181U, 0x9ed14f4fU, 0xa37fdcdcU,
+	0x44662222U, 0x547e2a2aU, 0x3bab9090U, 0x0b838888U,
+	0x8cca4646U, 0xc729eeeeU, 0x6bd3b8b8U, 0x283c1414U,
+	0xa779dedeU, 0xbce25e5eU, 0x161d0b0bU, 0xad76dbdbU,
+	0xdb3be0e0U, 0x64563232U, 0x744e3a3aU, 0x141e0a0aU,
+	0x92db4949U, 0x0c0a0606U, 0x486c2424U, 0xb8e45c5cU,
+	0x9f5dc2c2U, 0xbd6ed3d3U, 0x43efacacU, 0xc4a66262U,
+	0x39a89191U, 0x31a49595U, 0xd337e4e4U, 0xf28b7979U,
+	0xd532e7e7U, 0x8b43c8c8U, 0x6e593737U, 0xdab76d6dU,
+	0x018c8d8dU, 0xb164d5d5U, 0x9cd24e4eU, 0x49e0a9a9U,
+	0xd8b46c6cU, 0xacfa5656U, 0xf307f4f4U, 0xcf25eaeaU,
+	0xcaaf6565U, 0xf48e7a7aU, 0x47e9aeaeU, 0x10180808U,
+	0x6fd5babaU, 0xf0887878U, 0x4a6f2525U, 0x5c722e2eU,
+	0x38241c1cU, 0x57f1a6a6U, 0x73c7b4b4U, 0x9751c6c6U,
+	0xcb23e8e8U, 0xa17cddddU, 0xe89c7474U, 0x3e211f1fU,
+	0x96dd4b4bU, 0x61dcbdbdU, 0x0d868b8bU, 0x0f858a8aU,
+	0xe0907070U, 0x7c423e3eU, 0x71c4b5b5U, 0xccaa6666U,
+	0x90d84848U, 0x06050303U, 0xf701f6f6U, 0x1c120e0eU,
+	0xc2a36161U, 0x6a5f3535U, 0xaef95757U, 0x69d0b9b9U,
+	0x17918686U, 0x9958c1c1U, 0x3a271d1dU, 0x27b99e9eU,
+	0xd938e1e1U, 0xeb13f8f8U, 0x2bb39898U, 0x22331111U,
+	0xd2bb6969U, 0xa970d9d9U, 0x07898e8eU, 0x33a79494U,
+	0x2db69b9bU, 0x3c221e1eU, 0x15928787U, 0xc920e9e9U,
+	0x8749ceceU, 0xaaff5555U, 0x50782828U, 0xa57adfdfU,
+	0x038f8c8cU, 0x59f8a1a1U, 0x09808989U, 0x1a170d0dU,
+	0x65dabfbfU, 0xd731e6e6U, 0x84c64242U, 0xd0b86868U,
+	0x82c34141U, 0x29b09999U, 0x5a772d2dU, 0x1e110f0fU,
+	0x7bcbb0b0U, 0xa8fc5454U, 0x6dd6bbbbU, 0x2c3a1616U
+};
 
-#define SHAR8_0(x) AS_U32(&sharedMemory[OFF8_0(x)])
-#define SHAR8_1(x) AS_U32(&sharedMemory[OFF8_1(x)])
-#define SHAR8_2(x) AS_U32(&sharedMemory[OFF8_2(x)])
-#define SHAR8_3(x) AS_U32(&sharedMemory[OFF8_3(x)])
+#define t_fn0(x) (sharedMemory[      (x)])
+#define t_fn1(x) (sharedMemory[256 + (x)])
+#define t_fn2(x) (sharedMemory[512 + (x)])
+#define t_fn3(x) (sharedMemory[768 + (x)])
 
-__device__ __forceinline__
-void cn_aes_single_round_b(uint8_t * const sharedMemory, void * const long_state, const uint4 key, uint4 *res)
-{
-	asm("// aes_single_round_b");
-	uint4 in = AS_UINT4(long_state);
-	*res = key;
-	res->x ^= SHAR8_0(in.x) ^ SHAR8_1(in.y) ^ SHAR8_2(in.z) ^ SHAR8_3(in.w);
-	res->y ^= SHAR8_0(in.y) ^ SHAR8_1(in.z) ^ SHAR8_2(in.w) ^ SHAR8_3(in.x);
-	res->z ^= SHAR8_0(in.z) ^ SHAR8_1(in.w) ^ SHAR8_2(in.x) ^ SHAR8_3(in.y);
-	res->w ^= SHAR8_0(in.w) ^ SHAR8_1(in.x) ^ SHAR8_2(in.y) ^ SHAR8_3(in.z);
-}
 
-#define round_perm(shared, out, in, k) \
-	out[0] = (k)[0] ^ SHARED_0(in[0]) ^ SHARED_1(in[1]) ^ SHARED_2(in[2]) ^ SHARED_3(in[3]); \
-	out[1] = (k)[1] ^ SHARED_0(in[1]) ^ SHARED_1(in[2]) ^ SHARED_2(in[3]) ^ SHARED_3(in[0]); \
-	out[2] = (k)[2] ^ SHARED_0(in[2]) ^ SHARED_1(in[3]) ^ SHARED_2(in[0]) ^ SHARED_3(in[1]); \
-	out[3] = (k)[3] ^ SHARED_0(in[3]) ^ SHARED_1(in[0]) ^ SHARED_2(in[1]) ^ SHARED_3(in[2]);
+#define round(dummy,y,x,k) \
+    y[0] = (k)[0]  ^ (t_fn0(x[0] & 0xff) ^ t_fn1((x[1] >> 8) & 0xff) ^ t_fn2((x[2] >> 16) & 0xff) ^ t_fn3((x[3] >> 24) & 0xff)); \
+    y[1] = (k)[1]  ^ (t_fn0(x[1] & 0xff) ^ t_fn1((x[2] >> 8) & 0xff) ^ t_fn2((x[3] >> 16) & 0xff) ^ t_fn3((x[0] >> 24) & 0xff)); \
+    y[2] = (k)[2]  ^ (t_fn0(x[2] & 0xff) ^ t_fn1((x[3] >> 8) & 0xff) ^ t_fn2((x[0] >> 16) & 0xff) ^ t_fn3((x[1] >> 24) & 0xff)); \
+    y[3] = (k)[3]  ^ (t_fn0(x[3] & 0xff) ^ t_fn1((x[0] >> 8) & 0xff) ^ t_fn2((x[1] >> 16) & 0xff) ^ t_fn3((x[2] >> 24) & 0xff));
 
-__device__ __forceinline__
-void cn_aes_pseudo_round_mut(const uint32_t * sharedMemory, uint32_t * val, uint32_t const * expandedKey)
+__device__ __forceinline__ static void cn_aes_single_round(uint32_t * __restrict__ sharedMemory, const uint32_t * __restrict__ in, uint32_t * __restrict__ out, const uint32_t * __restrict__ expandedKey)
 {
-	asm("// aes_pseudo_round_mut");
-	uint32_t b[4];
-	round_perm(sharedMemory, b, val, expandedKey);
-	round_perm(sharedMemory, val, b, expandedKey + (1 * N_COLS));
-	round_perm(sharedMemory, b, val, expandedKey + (2 * N_COLS));
-	round_perm(sharedMemory, val, b, expandedKey + (3 * N_COLS));
-	round_perm(sharedMemory, b, val, expandedKey + (4 * N_COLS));
-	round_perm(sharedMemory, val, b, expandedKey + (5 * N_COLS));
-	round_perm(sharedMemory, b, val, expandedKey + (6 * N_COLS));
-	round_perm(sharedMemory, val, b, expandedKey + (7 * N_COLS));
-	round_perm(sharedMemory, b, val, expandedKey + (8 * N_COLS));
-	round_perm(sharedMemory, val, b, expandedKey + (9 * N_COLS));
+	out[0] = expandedKey[0] ^ t_fn0(in[0] & 0xff) ^ t_fn1((in[1] >> 8) & 0xff) ^ t_fn2((in[2] >> 16) & 0xff) ^ t_fn3((in[3] >> 24) & 0xff);
+	out[1] = expandedKey[1] ^ t_fn0(in[1] & 0xff) ^ t_fn1((in[2] >> 8) & 0xff) ^ t_fn2((in[3] >> 16) & 0xff) ^ t_fn3((in[0] >> 24) & 0xff);
+	out[2] = expandedKey[2] ^ t_fn0(in[2] & 0xff) ^ t_fn1((in[3] >> 8) & 0xff) ^ t_fn2((in[0] >> 16) & 0xff) ^ t_fn3((in[1] >> 24) & 0xff);
+	out[3] = expandedKey[3] ^ t_fn0(in[3] & 0xff) ^ t_fn1((in[0] >> 8) & 0xff) ^ t_fn2((in[1] >> 16) & 0xff) ^ t_fn3((in[2] >> 24) & 0xff);
 }
 
-static __forceinline__ __device__ uint4 operator ^ (const uint4 &a, const uint4 &b) {
-	return make_uint4(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
-}
-
-#define round_perm4(in, k) {\
-	uint4 tmp; \
-	tmp.x = SHARED_0(in.x) ^ SHARED_1(in.y) ^ SHARED_2(in.z) ^ SHARED_3(in.w); \
-	tmp.y = SHARED_0(in.y) ^ SHARED_1(in.z) ^ SHARED_2(in.w) ^ SHARED_3(in.x); \
-	tmp.z = SHARED_0(in.z) ^ SHARED_1(in.w) ^ SHARED_2(in.x) ^ SHARED_3(in.y); \
-	tmp.w = SHARED_0(in.w) ^ SHARED_1(in.x) ^ SHARED_2(in.y) ^ SHARED_3(in.z); \
-	val = tmp ^ key[k]; \
-}
-
-__device__ __forceinline__
-void cn_aes_pseudo_round_mut_uint4(uint32_t * const sharedMemory, uint4 &val, uint4 const key[10])
+__device__ __forceinline__ static void cn_aes_pseudo_round_mut(const uint32_t * __restrict__ sharedMemory, uint32_t * __restrict__ val, const uint32_t * __restrict__ expandedKey)
 {
-	asm("// aes_pseudo_round_mut_uint4");
-	round_perm4(val, 0);
-	round_perm4(val, 1);
-	round_perm4(val, 2);
-	round_perm4(val, 3);
-	round_perm4(val, 4);
-	round_perm4(val, 5);
-	round_perm4(val, 6);
-	round_perm4(val, 7);
-	round_perm4(val, 8);
-	round_perm4(val, 9);
+    uint32_t b1[4];
+    round(sharedMemory, b1, val, expandedKey);
+    round(sharedMemory, val, b1, expandedKey + 1 * N_COLS);
+    round(sharedMemory, b1, val, expandedKey + 2 * N_COLS);
+    round(sharedMemory, val, b1, expandedKey + 3 * N_COLS);
+    round(sharedMemory, b1, val, expandedKey + 4 * N_COLS);
+    round(sharedMemory, val, b1, expandedKey + 5 * N_COLS);
+    round(sharedMemory, b1, val, expandedKey + 6 * N_COLS);
+    round(sharedMemory, val, b1, expandedKey + 7 * N_COLS);
+    round(sharedMemory, b1, val, expandedKey + 8 * N_COLS);
+    round(sharedMemory, val, b1, expandedKey + 9 * N_COLS);
 }
 
-/*
-__device__ __forceinline__
-void cn_aes_gpu_init2(uint32_t* sharedMemory)
+__device__ __forceinline__ static void cn_aes_gpu_init(uint32_t *sharedMemory)
 {
-#if 0
-	if(blockDim.x >= 64)
+	if(blockDim.x >= 32)
 	{
-		if(threadIdx.x < 64) {
-			#define thrX (threadIdx.x << 2U) // ensure offsets aligned (16) to vector
-			#pragma unroll 4
-			for (uint32_t i = 0; i < 1024U; i += 256U) // 32x32 = 1024, 4 * 256 also
-				AS_UINT4(&sharedMemory[i + thrX]) = AS_UINT4(&d_t_fn[i + thrX]);
-		}
-
-	} else
-#endif
-	if(blockDim.x >= 32) {
-
-		if(threadIdx.x < 32) {
-#if 0
-			#pragma unroll 32
-			for(uint32_t i = 0; i < 1024; i += 32)
+		if(threadIdx.x < 32)
+		{
+			for(int i = 0; i < 1024; i += 32)
+			{
 				sharedMemory[threadIdx.x + i] = d_t_fn[threadIdx.x + i];
-#else
-			#define thrX (threadIdx.x << 2U) // ensure offsets aligned (16) to vector
-			#pragma unroll 8
-			for (uint32_t i = 0; i < 1024; i += 128U) // 32x32 = 1024, 8 * 128 also
-				AS_UINT4(&sharedMemory[i + thrX]) = AS_UINT4(&d_t_fn[i + thrX]);
-#endif
+			}
 		}
-
-	} else {
-
-		if(threadIdx.x < 4) {
-#if 0
-			for (uint32_t i = 0; i < 1024; i += 4)
+	}
+	else
+	{
+		if(threadIdx.x < 4)
+		{
+			for(int i = 0; i < 1024; i += 4)
+			{
 				sharedMemory[threadIdx.x + i] = d_t_fn[threadIdx.x + i];
-#else
-			#define thrX (threadIdx.x << 2U) // ensure offsets aligned (16) to vector
-			#pragma unroll 64
-			for (uint32_t i = 0; i < 1024; i += 16U)
-				AS_UINT4(&sharedMemory[i + thrX]) = AS_UINT4(&d_t_fn[i + thrX]);
-#endif
+			}
 		}
 	}
-}
-*/
-
-__device__ __forceinline__
-void cn_aes_gpu_init(uint32_t* sharedMemory)
-{
-	// AES 0
-	switch (threadIdx.x) {
-	case 0:
-		AS_UL2(&sharedMemory[0x000]) = make_ulonglong2(0x847c7cf8a56363c6, 0x8d7b7bf6997777ee);
-		AS_UL2(&sharedMemory[0x004]) = make_ulonglong2(0xbd6b6bd60df2f2ff, 0x54c5c591b16f6fde);
-		AS_UL2(&sharedMemory[0x008]) = make_ulonglong2(0x0301010250303060, 0x7d2b2b56a96767ce);
-		AS_UL2(&sharedMemory[0x00C]) = make_ulonglong2(0x62d7d7b519fefee7, 0x9a7676ece6abab4d);
-		AS_UL2(&sharedMemory[0x010]) = make_ulonglong2(0x9d82821f45caca8f, 0x877d7dfa40c9c989);
-		AS_UL2(&sharedMemory[0x014]) = make_ulonglong2(0xeb5959b215fafaef, 0x0bf0f0fbc947478e);
-		AS_UL2(&sharedMemory[0x018]) = make_ulonglong2(0x67d4d4b3ecadad41, 0xeaafaf45fda2a25f);
-		AS_UL2(&sharedMemory[0x01C]) = make_ulonglong2(0xf7a4a453bf9c9c23, 0x5bc0c09b967272e4);
-		break;
-	case 1:
-		AS_UL2(&sharedMemory[0x020]) = make_ulonglong2(0x1cfdfde1c2b7b775, 0x6a26264cae93933d);
-		AS_UL2(&sharedMemory[0x024]) = make_ulonglong2(0x413f3f7e5a36366c, 0x4fcccc8302f7f7f5);
-		AS_UL2(&sharedMemory[0x028]) = make_ulonglong2(0xf4a5a5515c343468, 0x08f1f1f934e5e5d1);
-		AS_UL2(&sharedMemory[0x02C]) = make_ulonglong2(0x73d8d8ab937171e2, 0x3f15152a53313162);
-		AS_UL2(&sharedMemory[0x030]) = make_ulonglong2(0x52c7c7950c040408, 0x5ec3c39d65232346);
-		AS_UL2(&sharedMemory[0x034]) = make_ulonglong2(0xa196963728181830, 0xb59a9a2f0f05050a);
-		AS_UL2(&sharedMemory[0x038]) = make_ulonglong2(0x361212240907070e, 0x3de2e2df9b80801b);
-		AS_UL2(&sharedMemory[0x03C]) = make_ulonglong2(0x6927274e26ebebcd, 0x9f7575eacdb2b27f);
-		break;
-	case 2:
-		AS_UL2(&sharedMemory[0x040]) = make_ulonglong2(0x9e83831d1b090912, 0x2e1a1a34742c2c58);
-		AS_UL2(&sharedMemory[0x044]) = make_ulonglong2(0xb26e6edc2d1b1b36, 0xfba0a05bee5a5ab4);
-		AS_UL2(&sharedMemory[0x048]) = make_ulonglong2(0x4d3b3b76f65252a4, 0xceb3b37d61d6d6b7);
-		AS_UL2(&sharedMemory[0x04C]) = make_ulonglong2(0x3ee3e3dd7b292952, 0x97848413712f2f5e);
-		AS_UL2(&sharedMemory[0x050]) = make_ulonglong2(0x68d1d1b9f55353a6, 0x2cededc100000000);
-		AS_UL2(&sharedMemory[0x054]) = make_ulonglong2(0x1ffcfce360202040, 0xed5b5bb6c8b1b179);
-		AS_UL2(&sharedMemory[0x058]) = make_ulonglong2(0x46cbcb8dbe6a6ad4, 0x4b393972d9bebe67);
-		AS_UL2(&sharedMemory[0x05C]) = make_ulonglong2(0xd44c4c98de4a4a94, 0x4acfcf85e85858b0);
-		break;
-	case 3:
-		AS_UL2(&sharedMemory[0x060]) = make_ulonglong2(0x2aefefc56bd0d0bb, 0x16fbfbede5aaaa4f);
-		AS_UL2(&sharedMemory[0x064]) = make_ulonglong2(0xd74d4d9ac5434386, 0x9485851155333366);
-		AS_UL2(&sharedMemory[0x068]) = make_ulonglong2(0x10f9f9e9cf45458a, 0x817f7ffe06020204);
-		AS_UL2(&sharedMemory[0x06C]) = make_ulonglong2(0x443c3c78f05050a0, 0xe3a8a84bba9f9f25);
-		AS_UL2(&sharedMemory[0x070]) = make_ulonglong2(0xfea3a35df35151a2, 0x8a8f8f05c0404080);
-		AS_UL2(&sharedMemory[0x074]) = make_ulonglong2(0xbc9d9d21ad92923f, 0x04f5f5f148383870);
-		AS_UL2(&sharedMemory[0x078]) = make_ulonglong2(0xc1b6b677dfbcbc63, 0x6321214275dadaaf);
-		AS_UL2(&sharedMemory[0x07C]) = make_ulonglong2(0x1affffe530101020, 0x6dd2d2bf0ef3f3fd);
-		break;
-	case 4:
-		AS_UL2(&sharedMemory[0x080]) = make_ulonglong2(0x140c0c184ccdcd81, 0x2fececc335131326);
-		AS_UL2(&sharedMemory[0x084]) = make_ulonglong2(0xa2979735e15f5fbe, 0x3917172ecc444488);
-		AS_UL2(&sharedMemory[0x088]) = make_ulonglong2(0xf2a7a75557c4c493, 0x473d3d7a827e7efc);
-		AS_UL2(&sharedMemory[0x08C]) = make_ulonglong2(0xe75d5dbaac6464c8, 0x957373e62b191932);
-		AS_UL2(&sharedMemory[0x090]) = make_ulonglong2(0x98818119a06060c0, 0x7fdcdca3d14f4f9e);
-		AS_UL2(&sharedMemory[0x094]) = make_ulonglong2(0x7e2a2a5466222244, 0x8388880bab90903b);
-		AS_UL2(&sharedMemory[0x098]) = make_ulonglong2(0x29eeeec7ca46468c, 0x3c141428d3b8b86b);
-		AS_UL2(&sharedMemory[0x09C]) = make_ulonglong2(0xe25e5ebc79dedea7, 0x76dbdbad1d0b0b16);
-		break;
-	case 5:
-		AS_UL2(&sharedMemory[0x0A0]) = make_ulonglong2(0x563232643be0e0db, 0x1e0a0a144e3a3a74);
-		AS_UL2(&sharedMemory[0x0A4]) = make_ulonglong2(0x0a06060cdb494992, 0xe45c5cb86c242448);
-		AS_UL2(&sharedMemory[0x0A8]) = make_ulonglong2(0x6ed3d3bd5dc2c29f, 0xa66262c4efacac43);
-		AS_UL2(&sharedMemory[0x0AC]) = make_ulonglong2(0xa4959531a8919139, 0x8b7979f237e4e4d3);
-		AS_UL2(&sharedMemory[0x0B0]) = make_ulonglong2(0x43c8c88b32e7e7d5, 0xb76d6dda5937376e);
-		AS_UL2(&sharedMemory[0x0B4]) = make_ulonglong2(0x64d5d5b18c8d8d01, 0xe0a9a949d24e4e9c);
-		AS_UL2(&sharedMemory[0x0B8]) = make_ulonglong2(0xfa5656acb46c6cd8, 0x25eaeacf07f4f4f3);
-		AS_UL2(&sharedMemory[0x0BC]) = make_ulonglong2(0x8e7a7af4af6565ca, 0x18080810e9aeae47);
-		break;
-	case 6:
-		AS_UL2(&sharedMemory[0x0C0]) = make_ulonglong2(0x887878f0d5baba6f, 0x722e2e5c6f25254a);
-		AS_UL2(&sharedMemory[0x0C4]) = make_ulonglong2(0xf1a6a657241c1c38, 0x51c6c697c7b4b473);
-		AS_UL2(&sharedMemory[0x0C8]) = make_ulonglong2(0x7cdddda123e8e8cb, 0x211f1f3e9c7474e8);
-		AS_UL2(&sharedMemory[0x0CC]) = make_ulonglong2(0xdcbdbd61dd4b4b96, 0x858a8a0f868b8b0d);
-		AS_UL2(&sharedMemory[0x0D0]) = make_ulonglong2(0x423e3e7c907070e0, 0xaa6666ccc4b5b571);
-		AS_UL2(&sharedMemory[0x0D4]) = make_ulonglong2(0x05030306d8484890, 0x120e0e1c01f6f6f7);
-		AS_UL2(&sharedMemory[0x0D8]) = make_ulonglong2(0x5f35356aa36161c2, 0xd0b9b969f95757ae);
-		AS_UL2(&sharedMemory[0x0DC]) = make_ulonglong2(0x58c1c19991868617, 0xb99e9e27271d1d3a);
-		break;
-	case 7:
-		AS_UL2(&sharedMemory[0x0E0]) = make_ulonglong2(0x13f8f8eb38e1e1d9, 0x33111122b398982b);
-		AS_UL2(&sharedMemory[0x0E4]) = make_ulonglong2(0x70d9d9a9bb6969d2, 0xa7949433898e8e07);
-		AS_UL2(&sharedMemory[0x0E8]) = make_ulonglong2(0x221e1e3cb69b9b2d, 0x20e9e9c992878715);
-		AS_UL2(&sharedMemory[0x0EC]) = make_ulonglong2(0xff5555aa49cece87, 0x7adfdfa578282850);
-		AS_UL2(&sharedMemory[0x0F0]) = make_ulonglong2(0xf8a1a1598f8c8c03, 0x170d0d1a80898909);
-		AS_UL2(&sharedMemory[0x0F4]) = make_ulonglong2(0x31e6e6d7dabfbf65, 0xb86868d0c6424284);
-		AS_UL2(&sharedMemory[0x0F8]) = make_ulonglong2(0xb0999929c3414182, 0x110f0f1e772d2d5a);
-		AS_UL2(&sharedMemory[0x0FC]) = make_ulonglong2(0xfc5454a8cbb0b07b, 0x3a16162cd6bbbb6d);
-		break;
-	}
-	// AES 1
-	switch (threadIdx.x) {
-	case 0:
-		AS_UL2(&sharedMemory[0x100]) = make_ulonglong2(0x7c7cf8846363c6a5, 0x7b7bf68d7777ee99);
-		AS_UL2(&sharedMemory[0x104]) = make_ulonglong2(0x6b6bd6bdf2f2ff0d, 0xc5c591546f6fdeb1);
-		AS_UL2(&sharedMemory[0x108]) = make_ulonglong2(0x0101020330306050, 0x2b2b567d6767cea9);
-		AS_UL2(&sharedMemory[0x10C]) = make_ulonglong2(0xd7d7b562fefee719, 0x7676ec9aabab4de6);
-		AS_UL2(&sharedMemory[0x110]) = make_ulonglong2(0x82821f9dcaca8f45, 0x7d7dfa87c9c98940);
-		AS_UL2(&sharedMemory[0x114]) = make_ulonglong2(0x5959b2ebfafaef15, 0xf0f0fb0b47478ec9);
-		AS_UL2(&sharedMemory[0x118]) = make_ulonglong2(0xd4d4b367adad41ec, 0xafaf45eaa2a25ffd);
-		AS_UL2(&sharedMemory[0x11C]) = make_ulonglong2(0xa4a453f79c9c23bf, 0xc0c09b5b7272e496);
-		break;
-	case 1:
-		AS_UL2(&sharedMemory[0x120]) = make_ulonglong2(0xfdfde11cb7b775c2, 0x26264c6a93933dae);
-		AS_UL2(&sharedMemory[0x124]) = make_ulonglong2(0x3f3f7e4136366c5a, 0xcccc834ff7f7f502);
-		AS_UL2(&sharedMemory[0x128]) = make_ulonglong2(0xa5a551f43434685c, 0xf1f1f908e5e5d134);
-		AS_UL2(&sharedMemory[0x12C]) = make_ulonglong2(0xd8d8ab737171e293, 0x15152a3f31316253);
-		AS_UL2(&sharedMemory[0x130]) = make_ulonglong2(0xc7c795520404080c, 0xc3c39d5e23234665);
-		AS_UL2(&sharedMemory[0x134]) = make_ulonglong2(0x969637a118183028, 0x9a9a2fb505050a0f);
-		AS_UL2(&sharedMemory[0x138]) = make_ulonglong2(0x1212243607070e09, 0xe2e2df3d80801b9b);
-		AS_UL2(&sharedMemory[0x13C]) = make_ulonglong2(0x27274e69ebebcd26, 0x7575ea9fb2b27fcd);
-		break;
-	case 2:
-		AS_UL2(&sharedMemory[0x140]) = make_ulonglong2(0x83831d9e0909121b, 0x1a1a342e2c2c5874);
-		AS_UL2(&sharedMemory[0x144]) = make_ulonglong2(0x6e6edcb21b1b362d, 0xa0a05bfb5a5ab4ee);
-		AS_UL2(&sharedMemory[0x148]) = make_ulonglong2(0x3b3b764d5252a4f6, 0xb3b37dced6d6b761);
-		AS_UL2(&sharedMemory[0x14C]) = make_ulonglong2(0xe3e3dd3e2929527b, 0x848413972f2f5e71);
-		AS_UL2(&sharedMemory[0x150]) = make_ulonglong2(0xd1d1b9685353a6f5, 0xededc12c00000000);
-		AS_UL2(&sharedMemory[0x154]) = make_ulonglong2(0xfcfce31f20204060, 0x5b5bb6edb1b179c8);
-		AS_UL2(&sharedMemory[0x158]) = make_ulonglong2(0xcbcb8d466a6ad4be, 0x3939724bbebe67d9);
-		AS_UL2(&sharedMemory[0x15C]) = make_ulonglong2(0x4c4c98d44a4a94de, 0xcfcf854a5858b0e8);
-		break;
-	case 3:
-		AS_UL2(&sharedMemory[0x160]) = make_ulonglong2(0xefefc52ad0d0bb6b, 0xfbfbed16aaaa4fe5);
-		AS_UL2(&sharedMemory[0x164]) = make_ulonglong2(0x4d4d9ad7434386c5, 0x8585119433336655);
-		AS_UL2(&sharedMemory[0x168]) = make_ulonglong2(0xf9f9e91045458acf, 0x7f7ffe8102020406);
-		AS_UL2(&sharedMemory[0x16C]) = make_ulonglong2(0x3c3c78445050a0f0, 0xa8a84be39f9f25ba);
-		AS_UL2(&sharedMemory[0x170]) = make_ulonglong2(0xa3a35dfe5151a2f3, 0x8f8f058a404080c0);
-		AS_UL2(&sharedMemory[0x174]) = make_ulonglong2(0x9d9d21bc92923fad, 0xf5f5f10438387048);
-		AS_UL2(&sharedMemory[0x178]) = make_ulonglong2(0xb6b677c1bcbc63df, 0x21214263dadaaf75);
-		AS_UL2(&sharedMemory[0x17C]) = make_ulonglong2(0xffffe51a10102030, 0xd2d2bf6df3f3fd0e);
-		break;
-	case 4:
-		AS_UL2(&sharedMemory[0x180]) = make_ulonglong2(0x0c0c1814cdcd814c, 0xececc32f13132635);
-		AS_UL2(&sharedMemory[0x184]) = make_ulonglong2(0x979735a25f5fbee1, 0x17172e39444488cc);
-		AS_UL2(&sharedMemory[0x188]) = make_ulonglong2(0xa7a755f2c4c49357, 0x3d3d7a477e7efc82);
-		AS_UL2(&sharedMemory[0x18C]) = make_ulonglong2(0x5d5dbae76464c8ac, 0x7373e6951919322b);
-		AS_UL2(&sharedMemory[0x190]) = make_ulonglong2(0x818119986060c0a0, 0xdcdca37f4f4f9ed1);
-		AS_UL2(&sharedMemory[0x194]) = make_ulonglong2(0x2a2a547e22224466, 0x88880b8390903bab);
-		AS_UL2(&sharedMemory[0x198]) = make_ulonglong2(0xeeeec72946468cca, 0x1414283cb8b86bd3);
-		AS_UL2(&sharedMemory[0x19C]) = make_ulonglong2(0x5e5ebce2dedea779, 0xdbdbad760b0b161d);
-		break;
-	case 5:
-		AS_UL2(&sharedMemory[0x1A0]) = make_ulonglong2(0x32326456e0e0db3b, 0x0a0a141e3a3a744e);
-		AS_UL2(&sharedMemory[0x1A4]) = make_ulonglong2(0x06060c0a494992db, 0x5c5cb8e42424486c);
-		AS_UL2(&sharedMemory[0x1A8]) = make_ulonglong2(0xd3d3bd6ec2c29f5d, 0x6262c4a6acac43ef);
-		AS_UL2(&sharedMemory[0x1AC]) = make_ulonglong2(0x959531a4919139a8, 0x7979f28be4e4d337);
-		AS_UL2(&sharedMemory[0x1B0]) = make_ulonglong2(0xc8c88b43e7e7d532, 0x6d6ddab737376e59);
-		AS_UL2(&sharedMemory[0x1B4]) = make_ulonglong2(0xd5d5b1648d8d018c, 0xa9a949e04e4e9cd2);
-		AS_UL2(&sharedMemory[0x1B8]) = make_ulonglong2(0x5656acfa6c6cd8b4, 0xeaeacf25f4f4f307);
-		AS_UL2(&sharedMemory[0x1BC]) = make_ulonglong2(0x7a7af48e6565caaf, 0x08081018aeae47e9);
-		break;
-	case 6:
-		AS_UL2(&sharedMemory[0x1C0]) = make_ulonglong2(0x7878f088baba6fd5, 0x2e2e5c7225254a6f);
-		AS_UL2(&sharedMemory[0x1C4]) = make_ulonglong2(0xa6a657f11c1c3824, 0xc6c69751b4b473c7);
-		AS_UL2(&sharedMemory[0x1C8]) = make_ulonglong2(0xdddda17ce8e8cb23, 0x1f1f3e217474e89c);
-		AS_UL2(&sharedMemory[0x1CC]) = make_ulonglong2(0xbdbd61dc4b4b96dd, 0x8a8a0f858b8b0d86);
-		AS_UL2(&sharedMemory[0x1D0]) = make_ulonglong2(0x3e3e7c427070e090, 0x6666ccaab5b571c4);
-		AS_UL2(&sharedMemory[0x1D4]) = make_ulonglong2(0x03030605484890d8, 0x0e0e1c12f6f6f701);
-		AS_UL2(&sharedMemory[0x1D8]) = make_ulonglong2(0x35356a5f6161c2a3, 0xb9b969d05757aef9);
-		AS_UL2(&sharedMemory[0x1DC]) = make_ulonglong2(0xc1c1995886861791, 0x9e9e27b91d1d3a27);
-		break;
-	case 7:
-		AS_UL2(&sharedMemory[0x1E0]) = make_ulonglong2(0xf8f8eb13e1e1d938, 0x1111223398982bb3);
-		AS_UL2(&sharedMemory[0x1E4]) = make_ulonglong2(0xd9d9a9706969d2bb, 0x949433a78e8e0789);
-		AS_UL2(&sharedMemory[0x1E8]) = make_ulonglong2(0x1e1e3c229b9b2db6, 0xe9e9c92087871592);
-		AS_UL2(&sharedMemory[0x1EC]) = make_ulonglong2(0x5555aaffcece8749, 0xdfdfa57a28285078);
-		AS_UL2(&sharedMemory[0x1F0]) = make_ulonglong2(0xa1a159f88c8c038f, 0x0d0d1a1789890980);
-		AS_UL2(&sharedMemory[0x1F4]) = make_ulonglong2(0xe6e6d731bfbf65da, 0x6868d0b8424284c6);
-		AS_UL2(&sharedMemory[0x1F8]) = make_ulonglong2(0x999929b0414182c3, 0x0f0f1e112d2d5a77);
-		AS_UL2(&sharedMemory[0x1FC]) = make_ulonglong2(0x5454a8fcb0b07bcb, 0x16162c3abbbb6dd6);
-		break;
-	}
-	// AES 2
-	switch (threadIdx.x) {
-	case 0:
-		AS_UL2(&sharedMemory[0x200]) = make_ulonglong2(0x7cf8847c63c6a563, 0x7bf68d7b77ee9977);
-		AS_UL2(&sharedMemory[0x204]) = make_ulonglong2(0x6bd6bd6bf2ff0df2, 0xc59154c56fdeb16f);
-		AS_UL2(&sharedMemory[0x208]) = make_ulonglong2(0x0102030130605030, 0x2b567d2b67cea967);
-		AS_UL2(&sharedMemory[0x20C]) = make_ulonglong2(0xd7b562d7fee719fe, 0x76ec9a76ab4de6ab);
-		AS_UL2(&sharedMemory[0x210]) = make_ulonglong2(0x821f9d82ca8f45ca, 0x7dfa877dc98940c9);
-		AS_UL2(&sharedMemory[0x214]) = make_ulonglong2(0x59b2eb59faef15fa, 0xf0fb0bf0478ec947);
-		AS_UL2(&sharedMemory[0x218]) = make_ulonglong2(0xd4b367d4ad41ecad, 0xaf45eaafa25ffda2);
-		AS_UL2(&sharedMemory[0x21C]) = make_ulonglong2(0xa453f7a49c23bf9c, 0xc09b5bc072e49672);
-		break;
-	case 1:
-		AS_UL2(&sharedMemory[0x220]) = make_ulonglong2(0xfde11cfdb775c2b7, 0x264c6a26933dae93);
-		AS_UL2(&sharedMemory[0x224]) = make_ulonglong2(0x3f7e413f366c5a36, 0xcc834fccf7f502f7);
-		AS_UL2(&sharedMemory[0x228]) = make_ulonglong2(0xa551f4a534685c34, 0xf1f908f1e5d134e5);
-		AS_UL2(&sharedMemory[0x22C]) = make_ulonglong2(0xd8ab73d871e29371, 0x152a3f1531625331);
-		AS_UL2(&sharedMemory[0x230]) = make_ulonglong2(0xc79552c704080c04, 0xc39d5ec323466523);
-		AS_UL2(&sharedMemory[0x234]) = make_ulonglong2(0x9637a19618302818, 0x9a2fb59a050a0f05);
-		AS_UL2(&sharedMemory[0x238]) = make_ulonglong2(0x12243612070e0907, 0xe2df3de2801b9b80);
-		AS_UL2(&sharedMemory[0x23C]) = make_ulonglong2(0x274e6927ebcd26eb, 0x75ea9f75b27fcdb2);
-		break;
-	case 2:
-		AS_UL2(&sharedMemory[0x240]) = make_ulonglong2(0x831d9e8309121b09, 0x1a342e1a2c58742c);
-		AS_UL2(&sharedMemory[0x244]) = make_ulonglong2(0x6edcb26e1b362d1b, 0xa05bfba05ab4ee5a);
-		AS_UL2(&sharedMemory[0x248]) = make_ulonglong2(0x3b764d3b52a4f652, 0xb37dceb3d6b761d6);
-		AS_UL2(&sharedMemory[0x24C]) = make_ulonglong2(0xe3dd3ee329527b29, 0x841397842f5e712f);
-		AS_UL2(&sharedMemory[0x250]) = make_ulonglong2(0xd1b968d153a6f553, 0xedc12ced00000000);
-		AS_UL2(&sharedMemory[0x254]) = make_ulonglong2(0xfce31ffc20406020, 0x5bb6ed5bb179c8b1);
-		AS_UL2(&sharedMemory[0x258]) = make_ulonglong2(0xcb8d46cb6ad4be6a, 0x39724b39be67d9be);
-		AS_UL2(&sharedMemory[0x25C]) = make_ulonglong2(0x4c98d44c4a94de4a, 0xcf854acf58b0e858);
-		break;
-	case 3:
-		AS_UL2(&sharedMemory[0x260]) = make_ulonglong2(0xefc52aefd0bb6bd0, 0xfbed16fbaa4fe5aa);
-		AS_UL2(&sharedMemory[0x264]) = make_ulonglong2(0x4d9ad74d4386c543, 0x8511948533665533);
-		AS_UL2(&sharedMemory[0x268]) = make_ulonglong2(0xf9e910f9458acf45, 0x7ffe817f02040602);
-		AS_UL2(&sharedMemory[0x26C]) = make_ulonglong2(0x3c78443c50a0f050, 0xa84be3a89f25ba9f);
-		AS_UL2(&sharedMemory[0x270]) = make_ulonglong2(0xa35dfea351a2f351, 0x8f058a8f4080c040);
-		AS_UL2(&sharedMemory[0x274]) = make_ulonglong2(0x9d21bc9d923fad92, 0xf5f104f538704838);
-		AS_UL2(&sharedMemory[0x278]) = make_ulonglong2(0xb677c1b6bc63dfbc, 0x21426321daaf75da);
-		AS_UL2(&sharedMemory[0x27C]) = make_ulonglong2(0xffe51aff10203010, 0xd2bf6dd2f3fd0ef3);
-		break;
-	case 4:
-		AS_UL2(&sharedMemory[0x280]) = make_ulonglong2(0x0c18140ccd814ccd, 0xecc32fec13263513);
-		AS_UL2(&sharedMemory[0x284]) = make_ulonglong2(0x9735a2975fbee15f, 0x172e39174488cc44);
-		AS_UL2(&sharedMemory[0x288]) = make_ulonglong2(0xa755f2a7c49357c4, 0x3d7a473d7efc827e);
-		AS_UL2(&sharedMemory[0x28C]) = make_ulonglong2(0x5dbae75d64c8ac64, 0x73e6957319322b19);
-		AS_UL2(&sharedMemory[0x290]) = make_ulonglong2(0x8119988160c0a060, 0xdca37fdc4f9ed14f);
-		AS_UL2(&sharedMemory[0x294]) = make_ulonglong2(0x2a547e2a22446622, 0x880b8388903bab90);
-		AS_UL2(&sharedMemory[0x298]) = make_ulonglong2(0xeec729ee468cca46, 0x14283c14b86bd3b8);
-		AS_UL2(&sharedMemory[0x29C]) = make_ulonglong2(0x5ebce25edea779de, 0xdbad76db0b161d0b);
-		break;
-	case 5:
-		AS_UL2(&sharedMemory[0x2A0]) = make_ulonglong2(0x32645632e0db3be0, 0x0a141e0a3a744e3a);
-		AS_UL2(&sharedMemory[0x2A4]) = make_ulonglong2(0x060c0a064992db49, 0x5cb8e45c24486c24);
-		AS_UL2(&sharedMemory[0x2A8]) = make_ulonglong2(0xd3bd6ed3c29f5dc2, 0x62c4a662ac43efac);
-		AS_UL2(&sharedMemory[0x2AC]) = make_ulonglong2(0x9531a4959139a891, 0x79f28b79e4d337e4);
-		AS_UL2(&sharedMemory[0x2B0]) = make_ulonglong2(0xc88b43c8e7d532e7, 0x6ddab76d376e5937);
-		AS_UL2(&sharedMemory[0x2B4]) = make_ulonglong2(0xd5b164d58d018c8d, 0xa949e0a94e9cd24e);
-		AS_UL2(&sharedMemory[0x2B8]) = make_ulonglong2(0x56acfa566cd8b46c, 0xeacf25eaf4f307f4);
-		AS_UL2(&sharedMemory[0x2BC]) = make_ulonglong2(0x7af48e7a65caaf65, 0x08101808ae47e9ae);
-		break;
-	case 6:
-		AS_UL2(&sharedMemory[0x2C0]) = make_ulonglong2(0x78f08878ba6fd5ba, 0x2e5c722e254a6f25);
-		AS_UL2(&sharedMemory[0x2C4]) = make_ulonglong2(0xa657f1a61c38241c, 0xc69751c6b473c7b4);
-		AS_UL2(&sharedMemory[0x2C8]) = make_ulonglong2(0xdda17cdde8cb23e8, 0x1f3e211f74e89c74);
-		AS_UL2(&sharedMemory[0x2CC]) = make_ulonglong2(0xbd61dcbd4b96dd4b, 0x8a0f858a8b0d868b);
-		AS_UL2(&sharedMemory[0x2D0]) = make_ulonglong2(0x3e7c423e70e09070, 0x66ccaa66b571c4b5);
-		AS_UL2(&sharedMemory[0x2D4]) = make_ulonglong2(0x030605034890d848, 0x0e1c120ef6f701f6);
-		AS_UL2(&sharedMemory[0x2D8]) = make_ulonglong2(0x356a5f3561c2a361, 0xb969d0b957aef957);
-		AS_UL2(&sharedMemory[0x2DC]) = make_ulonglong2(0xc19958c186179186, 0x9e27b99e1d3a271d);
-		break;
-	case 7:
-		AS_UL2(&sharedMemory[0x2E0]) = make_ulonglong2(0xf8eb13f8e1d938e1, 0x11223311982bb398);
-		AS_UL2(&sharedMemory[0x2E4]) = make_ulonglong2(0xd9a970d969d2bb69, 0x9433a7948e07898e);
-		AS_UL2(&sharedMemory[0x2E8]) = make_ulonglong2(0x1e3c221e9b2db69b, 0xe9c920e987159287);
-		AS_UL2(&sharedMemory[0x2EC]) = make_ulonglong2(0x55aaff55ce8749ce, 0xdfa57adf28507828);
-		AS_UL2(&sharedMemory[0x2F0]) = make_ulonglong2(0xa159f8a18c038f8c, 0x0d1a170d89098089);
-		AS_UL2(&sharedMemory[0x2F4]) = make_ulonglong2(0xe6d731e6bf65dabf, 0x68d0b8684284c642);
-		AS_UL2(&sharedMemory[0x2F8]) = make_ulonglong2(0x9929b0994182c341, 0x0f1e110f2d5a772d);
-		AS_UL2(&sharedMemory[0x2FC]) = make_ulonglong2(0x54a8fc54b07bcbb0, 0x162c3a16bb6dd6bb);
-		break;
-	}
-	// AES 3
-	switch (threadIdx.x) {
-	case 0:
-		AS_UL2(&sharedMemory[0x300]) = make_ulonglong2(0xf8847c7cc6a56363, 0xf68d7b7bee997777);
-		AS_UL2(&sharedMemory[0x304]) = make_ulonglong2(0xd6bd6b6bff0df2f2, 0x9154c5c5deb16f6f);
-		AS_UL2(&sharedMemory[0x308]) = make_ulonglong2(0x0203010160503030, 0x567d2b2bcea96767);
-		AS_UL2(&sharedMemory[0x30C]) = make_ulonglong2(0xb562d7d7e719fefe, 0xec9a76764de6abab);
-		AS_UL2(&sharedMemory[0x310]) = make_ulonglong2(0x1f9d82828f45caca, 0xfa877d7d8940c9c9);
-		AS_UL2(&sharedMemory[0x314]) = make_ulonglong2(0xb2eb5959ef15fafa, 0xfb0bf0f08ec94747);
-		AS_UL2(&sharedMemory[0x318]) = make_ulonglong2(0xb367d4d441ecadad, 0x45eaafaf5ffda2a2);
-		AS_UL2(&sharedMemory[0x31C]) = make_ulonglong2(0x53f7a4a423bf9c9c, 0x9b5bc0c0e4967272);
-		break;
-	case 1:
-		AS_UL2(&sharedMemory[0x320]) = make_ulonglong2(0xe11cfdfd75c2b7b7, 0x4c6a26263dae9393);
-		AS_UL2(&sharedMemory[0x324]) = make_ulonglong2(0x7e413f3f6c5a3636, 0x834fccccf502f7f7);
-		AS_UL2(&sharedMemory[0x328]) = make_ulonglong2(0x51f4a5a5685c3434, 0xf908f1f1d134e5e5);
-		AS_UL2(&sharedMemory[0x32C]) = make_ulonglong2(0xab73d8d8e2937171, 0x2a3f151562533131);
-		AS_UL2(&sharedMemory[0x330]) = make_ulonglong2(0x9552c7c7080c0404, 0x9d5ec3c346652323);
-		AS_UL2(&sharedMemory[0x334]) = make_ulonglong2(0x37a1969630281818, 0x2fb59a9a0a0f0505);
-		AS_UL2(&sharedMemory[0x338]) = make_ulonglong2(0x243612120e090707, 0xdf3de2e21b9b8080);
-		AS_UL2(&sharedMemory[0x33C]) = make_ulonglong2(0x4e692727cd26ebeb, 0xea9f75757fcdb2b2);
-		break;
-	case 2:
-		AS_UL2(&sharedMemory[0x340]) = make_ulonglong2(0x1d9e8383121b0909, 0x342e1a1a58742c2c);
-		AS_UL2(&sharedMemory[0x344]) = make_ulonglong2(0xdcb26e6e362d1b1b, 0x5bfba0a0b4ee5a5a);
-		AS_UL2(&sharedMemory[0x348]) = make_ulonglong2(0x764d3b3ba4f65252, 0x7dceb3b3b761d6d6);
-		AS_UL2(&sharedMemory[0x34C]) = make_ulonglong2(0xdd3ee3e3527b2929, 0x139784845e712f2f);
-		AS_UL2(&sharedMemory[0x350]) = make_ulonglong2(0xb968d1d1a6f55353, 0xc12ceded00000000);
-		AS_UL2(&sharedMemory[0x354]) = make_ulonglong2(0xe31ffcfc40602020, 0xb6ed5b5b79c8b1b1);
-		AS_UL2(&sharedMemory[0x358]) = make_ulonglong2(0x8d46cbcbd4be6a6a, 0x724b393967d9bebe);
-		AS_UL2(&sharedMemory[0x35C]) = make_ulonglong2(0x98d44c4c94de4a4a, 0x854acfcfb0e85858);
-		break;
-	case 3:
-		AS_UL2(&sharedMemory[0x360]) = make_ulonglong2(0xc52aefefbb6bd0d0, 0xed16fbfb4fe5aaaa);
-		AS_UL2(&sharedMemory[0x364]) = make_ulonglong2(0x9ad74d4d86c54343, 0x1194858566553333);
-		AS_UL2(&sharedMemory[0x368]) = make_ulonglong2(0xe910f9f98acf4545, 0xfe817f7f04060202);
-		AS_UL2(&sharedMemory[0x36C]) = make_ulonglong2(0x78443c3ca0f05050, 0x4be3a8a825ba9f9f);
-		AS_UL2(&sharedMemory[0x370]) = make_ulonglong2(0x5dfea3a3a2f35151, 0x058a8f8f80c04040);
-		AS_UL2(&sharedMemory[0x374]) = make_ulonglong2(0x21bc9d9d3fad9292, 0xf104f5f570483838);
-		AS_UL2(&sharedMemory[0x378]) = make_ulonglong2(0x77c1b6b663dfbcbc, 0x42632121af75dada);
-		AS_UL2(&sharedMemory[0x37C]) = make_ulonglong2(0xe51affff20301010, 0xbf6dd2d2fd0ef3f3);
-		break;
-	case 4:
-		AS_UL2(&sharedMemory[0x380]) = make_ulonglong2(0x18140c0c814ccdcd, 0xc32fecec26351313);
-		AS_UL2(&sharedMemory[0x384]) = make_ulonglong2(0x35a29797bee15f5f, 0x2e39171788cc4444);
-		AS_UL2(&sharedMemory[0x388]) = make_ulonglong2(0x55f2a7a79357c4c4, 0x7a473d3dfc827e7e);
-		AS_UL2(&sharedMemory[0x38C]) = make_ulonglong2(0xbae75d5dc8ac6464, 0xe6957373322b1919);
-		AS_UL2(&sharedMemory[0x390]) = make_ulonglong2(0x19988181c0a06060, 0xa37fdcdc9ed14f4f);
-		AS_UL2(&sharedMemory[0x394]) = make_ulonglong2(0x547e2a2a44662222, 0x0b8388883bab9090);
-		AS_UL2(&sharedMemory[0x398]) = make_ulonglong2(0xc729eeee8cca4646, 0x283c14146bd3b8b8);
-		AS_UL2(&sharedMemory[0x39C]) = make_ulonglong2(0xbce25e5ea779dede, 0xad76dbdb161d0b0b);
-		break;
-	case 5:
-		AS_UL2(&sharedMemory[0x3A0]) = make_ulonglong2(0x64563232db3be0e0, 0x141e0a0a744e3a3a);
-		AS_UL2(&sharedMemory[0x3A4]) = make_ulonglong2(0x0c0a060692db4949, 0xb8e45c5c486c2424);
-		AS_UL2(&sharedMemory[0x3A8]) = make_ulonglong2(0xbd6ed3d39f5dc2c2, 0xc4a6626243efacac);
-		AS_UL2(&sharedMemory[0x3AC]) = make_ulonglong2(0x31a4959539a89191, 0xf28b7979d337e4e4);
-		AS_UL2(&sharedMemory[0x3B0]) = make_ulonglong2(0x8b43c8c8d532e7e7, 0xdab76d6d6e593737);
-		AS_UL2(&sharedMemory[0x3B4]) = make_ulonglong2(0xb164d5d5018c8d8d, 0x49e0a9a99cd24e4e);
-		AS_UL2(&sharedMemory[0x3B8]) = make_ulonglong2(0xacfa5656d8b46c6c, 0xcf25eaeaf307f4f4);
-		AS_UL2(&sharedMemory[0x3BC]) = make_ulonglong2(0xf48e7a7acaaf6565, 0x1018080847e9aeae);
-		break;
-	case 6:
-		AS_UL2(&sharedMemory[0x3C0]) = make_ulonglong2(0xf08878786fd5baba, 0x5c722e2e4a6f2525);
-		AS_UL2(&sharedMemory[0x3C4]) = make_ulonglong2(0x57f1a6a638241c1c, 0x9751c6c673c7b4b4);
-		AS_UL2(&sharedMemory[0x3C8]) = make_ulonglong2(0xa17cddddcb23e8e8, 0x3e211f1fe89c7474);
-		AS_UL2(&sharedMemory[0x3CC]) = make_ulonglong2(0x61dcbdbd96dd4b4b, 0x0f858a8a0d868b8b);
-		AS_UL2(&sharedMemory[0x3D0]) = make_ulonglong2(0x7c423e3ee0907070, 0xccaa666671c4b5b5);
-		AS_UL2(&sharedMemory[0x3D4]) = make_ulonglong2(0x0605030390d84848, 0x1c120e0ef701f6f6);
-		AS_UL2(&sharedMemory[0x3D8]) = make_ulonglong2(0x6a5f3535c2a36161, 0x69d0b9b9aef95757);
-		AS_UL2(&sharedMemory[0x3DC]) = make_ulonglong2(0x9958c1c117918686, 0x27b99e9e3a271d1d);
-		break;
-	case 7:
-		AS_UL2(&sharedMemory[0x3E0]) = make_ulonglong2(0xeb13f8f8d938e1e1, 0x223311112bb39898);
-		AS_UL2(&sharedMemory[0x3E4]) = make_ulonglong2(0xa970d9d9d2bb6969, 0x33a7949407898e8e);
-		AS_UL2(&sharedMemory[0x3E8]) = make_ulonglong2(0x3c221e1e2db69b9b, 0xc920e9e915928787);
-		AS_UL2(&sharedMemory[0x3EC]) = make_ulonglong2(0xaaff55558749cece, 0xa57adfdf50782828);
-		AS_UL2(&sharedMemory[0x3F0]) = make_ulonglong2(0x59f8a1a1038f8c8c, 0x1a170d0d09808989);
-		AS_UL2(&sharedMemory[0x3F4]) = make_ulonglong2(0xd731e6e665dabfbf, 0xd0b8686884c64242);
-		AS_UL2(&sharedMemory[0x3F8]) = make_ulonglong2(0x29b0999982c34141, 0x1e110f0f5a772d2d);
-		AS_UL2(&sharedMemory[0x3FC]) = make_ulonglong2(0xa8fc54547bcbb0b0, 0x2c3a16166dd6bbbb);
-		break;
-	}
-}
-
-__device__ __forceinline__
-void cn_aes_gpu_init_u4(uint32_t* sharedMemory)
-{
-	// AES 0
-	switch (threadIdx.x) {
-	case 0:
-		AS_UINT4(&sharedMemory[0x000]) = make_uint4(0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6);
-		AS_UINT4(&sharedMemory[0x004]) = make_uint4(0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591);
-		AS_UINT4(&sharedMemory[0x008]) = make_uint4(0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56);
-		AS_UINT4(&sharedMemory[0x00C]) = make_uint4(0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec);
-		AS_UINT4(&sharedMemory[0x010]) = make_uint4(0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa);
-		AS_UINT4(&sharedMemory[0x014]) = make_uint4(0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb);
-		AS_UINT4(&sharedMemory[0x018]) = make_uint4(0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45);
-		AS_UINT4(&sharedMemory[0x01C]) = make_uint4(0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b);
-		break;
-	case 1:
-		AS_UINT4(&sharedMemory[0x020]) = make_uint4(0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c);
-		AS_UINT4(&sharedMemory[0x024]) = make_uint4(0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83);
-		AS_UINT4(&sharedMemory[0x028]) = make_uint4(0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9);
-		AS_UINT4(&sharedMemory[0x02C]) = make_uint4(0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a);
-		AS_UINT4(&sharedMemory[0x030]) = make_uint4(0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d);
-		AS_UINT4(&sharedMemory[0x034]) = make_uint4(0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f);
-		AS_UINT4(&sharedMemory[0x038]) = make_uint4(0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df);
-		AS_UINT4(&sharedMemory[0x03C]) = make_uint4(0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea);
-		break;
-	case 2:
-		AS_UINT4(&sharedMemory[0x040]) = make_uint4(0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34);
-		AS_UINT4(&sharedMemory[0x044]) = make_uint4(0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b);
-		AS_UINT4(&sharedMemory[0x048]) = make_uint4(0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d);
-		AS_UINT4(&sharedMemory[0x04C]) = make_uint4(0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413);
-		AS_UINT4(&sharedMemory[0x050]) = make_uint4(0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1);
-		AS_UINT4(&sharedMemory[0x054]) = make_uint4(0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6);
-		AS_UINT4(&sharedMemory[0x058]) = make_uint4(0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972);
-		AS_UINT4(&sharedMemory[0x05C]) = make_uint4(0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85);
-		break;
-	case 3:
-		AS_UINT4(&sharedMemory[0x060]) = make_uint4(0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed);
-		AS_UINT4(&sharedMemory[0x064]) = make_uint4(0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511);
-		AS_UINT4(&sharedMemory[0x068]) = make_uint4(0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe);
-		AS_UINT4(&sharedMemory[0x06C]) = make_uint4(0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b);
-		AS_UINT4(&sharedMemory[0x070]) = make_uint4(0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05);
-		AS_UINT4(&sharedMemory[0x074]) = make_uint4(0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1);
-		AS_UINT4(&sharedMemory[0x078]) = make_uint4(0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142);
-		AS_UINT4(&sharedMemory[0x07C]) = make_uint4(0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf);
-		break;
-	case 4:
-		AS_UINT4(&sharedMemory[0x080]) = make_uint4(0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3);
-		AS_UINT4(&sharedMemory[0x084]) = make_uint4(0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e);
-		AS_UINT4(&sharedMemory[0x088]) = make_uint4(0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a);
-		AS_UINT4(&sharedMemory[0x08C]) = make_uint4(0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6);
-		AS_UINT4(&sharedMemory[0x090]) = make_uint4(0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3);
-		AS_UINT4(&sharedMemory[0x094]) = make_uint4(0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b);
-		AS_UINT4(&sharedMemory[0x098]) = make_uint4(0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428);
-		AS_UINT4(&sharedMemory[0x09C]) = make_uint4(0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad);
-		break;
-	case 5:
-		AS_UINT4(&sharedMemory[0x0A0]) = make_uint4(0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14);
-		AS_UINT4(&sharedMemory[0x0A4]) = make_uint4(0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8);
-		AS_UINT4(&sharedMemory[0x0A8]) = make_uint4(0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4);
-		AS_UINT4(&sharedMemory[0x0AC]) = make_uint4(0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2);
-		AS_UINT4(&sharedMemory[0x0B0]) = make_uint4(0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda);
-		AS_UINT4(&sharedMemory[0x0B4]) = make_uint4(0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949);
-		AS_UINT4(&sharedMemory[0x0B8]) = make_uint4(0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf);
-		AS_UINT4(&sharedMemory[0x0BC]) = make_uint4(0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810);
-		break;
-	case 6:
-		AS_UINT4(&sharedMemory[0x0C0]) = make_uint4(0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c);
-		AS_UINT4(&sharedMemory[0x0C4]) = make_uint4(0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697);
-		AS_UINT4(&sharedMemory[0x0C8]) = make_uint4(0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e);
-		AS_UINT4(&sharedMemory[0x0CC]) = make_uint4(0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f);
-		AS_UINT4(&sharedMemory[0x0D0]) = make_uint4(0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc);
-		AS_UINT4(&sharedMemory[0x0D4]) = make_uint4(0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c);
-		AS_UINT4(&sharedMemory[0x0D8]) = make_uint4(0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969);
-		AS_UINT4(&sharedMemory[0x0DC]) = make_uint4(0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27);
-		break;
-	case 7:
-		AS_UINT4(&sharedMemory[0x0E0]) = make_uint4(0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122);
-		AS_UINT4(&sharedMemory[0x0E4]) = make_uint4(0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433);
-		AS_UINT4(&sharedMemory[0x0E8]) = make_uint4(0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9);
-		AS_UINT4(&sharedMemory[0x0EC]) = make_uint4(0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5);
-		AS_UINT4(&sharedMemory[0x0F0]) = make_uint4(0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a);
-		AS_UINT4(&sharedMemory[0x0F4]) = make_uint4(0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0);
-		AS_UINT4(&sharedMemory[0x0F8]) = make_uint4(0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e);
-		AS_UINT4(&sharedMemory[0x0FC]) = make_uint4(0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c);
-		break;
-	}
-	// AES 1
-	switch (threadIdx.x) {
-	case 0:
-		AS_UINT4(&sharedMemory[0x100]) = make_uint4(0x6363c6a5, 0x7c7cf884, 0x7777ee99, 0x7b7bf68d);
-		AS_UINT4(&sharedMemory[0x104]) = make_uint4(0xf2f2ff0d, 0x6b6bd6bd, 0x6f6fdeb1, 0xc5c59154);
-		AS_UINT4(&sharedMemory[0x108]) = make_uint4(0x30306050, 0x01010203, 0x6767cea9, 0x2b2b567d);
-		AS_UINT4(&sharedMemory[0x10C]) = make_uint4(0xfefee719, 0xd7d7b562, 0xabab4de6, 0x7676ec9a);
-		AS_UINT4(&sharedMemory[0x110]) = make_uint4(0xcaca8f45, 0x82821f9d, 0xc9c98940, 0x7d7dfa87);
-		AS_UINT4(&sharedMemory[0x114]) = make_uint4(0xfafaef15, 0x5959b2eb, 0x47478ec9, 0xf0f0fb0b);
-		AS_UINT4(&sharedMemory[0x118]) = make_uint4(0xadad41ec, 0xd4d4b367, 0xa2a25ffd, 0xafaf45ea);
-		AS_UINT4(&sharedMemory[0x11C]) = make_uint4(0x9c9c23bf, 0xa4a453f7, 0x7272e496, 0xc0c09b5b);
-		break;
-	case 1:
-		AS_UINT4(&sharedMemory[0x120]) = make_uint4(0xb7b775c2, 0xfdfde11c, 0x93933dae, 0x26264c6a);
-		AS_UINT4(&sharedMemory[0x124]) = make_uint4(0x36366c5a, 0x3f3f7e41, 0xf7f7f502, 0xcccc834f);
-		AS_UINT4(&sharedMemory[0x128]) = make_uint4(0x3434685c, 0xa5a551f4, 0xe5e5d134, 0xf1f1f908);
-		AS_UINT4(&sharedMemory[0x12C]) = make_uint4(0x7171e293, 0xd8d8ab73, 0x31316253, 0x15152a3f);
-		AS_UINT4(&sharedMemory[0x130]) = make_uint4(0x0404080c, 0xc7c79552, 0x23234665, 0xc3c39d5e);
-		AS_UINT4(&sharedMemory[0x134]) = make_uint4(0x18183028, 0x969637a1, 0x05050a0f, 0x9a9a2fb5);
-		AS_UINT4(&sharedMemory[0x138]) = make_uint4(0x07070e09, 0x12122436, 0x80801b9b, 0xe2e2df3d);
-		AS_UINT4(&sharedMemory[0x13C]) = make_uint4(0xebebcd26, 0x27274e69, 0xb2b27fcd, 0x7575ea9f);
-		break;
-	case 2:
-		AS_UINT4(&sharedMemory[0x140]) = make_uint4(0x0909121b, 0x83831d9e, 0x2c2c5874, 0x1a1a342e);
-		AS_UINT4(&sharedMemory[0x144]) = make_uint4(0x1b1b362d, 0x6e6edcb2, 0x5a5ab4ee, 0xa0a05bfb);
-		AS_UINT4(&sharedMemory[0x148]) = make_uint4(0x5252a4f6, 0x3b3b764d, 0xd6d6b761, 0xb3b37dce);
-		AS_UINT4(&sharedMemory[0x14C]) = make_uint4(0x2929527b, 0xe3e3dd3e, 0x2f2f5e71, 0x84841397);
-		AS_UINT4(&sharedMemory[0x150]) = make_uint4(0x5353a6f5, 0xd1d1b968, 0x00000000, 0xededc12c);
-		AS_UINT4(&sharedMemory[0x154]) = make_uint4(0x20204060, 0xfcfce31f, 0xb1b179c8, 0x5b5bb6ed);
-		AS_UINT4(&sharedMemory[0x158]) = make_uint4(0x6a6ad4be, 0xcbcb8d46, 0xbebe67d9, 0x3939724b);
-		AS_UINT4(&sharedMemory[0x15C]) = make_uint4(0x4a4a94de, 0x4c4c98d4, 0x5858b0e8, 0xcfcf854a);
-		break;
-	case 3:
-		AS_UINT4(&sharedMemory[0x160]) = make_uint4(0xd0d0bb6b, 0xefefc52a, 0xaaaa4fe5, 0xfbfbed16);
-		AS_UINT4(&sharedMemory[0x164]) = make_uint4(0x434386c5, 0x4d4d9ad7, 0x33336655, 0x85851194);
-		AS_UINT4(&sharedMemory[0x168]) = make_uint4(0x45458acf, 0xf9f9e910, 0x02020406, 0x7f7ffe81);
-		AS_UINT4(&sharedMemory[0x16C]) = make_uint4(0x5050a0f0, 0x3c3c7844, 0x9f9f25ba, 0xa8a84be3);
-		AS_UINT4(&sharedMemory[0x170]) = make_uint4(0x5151a2f3, 0xa3a35dfe, 0x404080c0, 0x8f8f058a);
-		AS_UINT4(&sharedMemory[0x174]) = make_uint4(0x92923fad, 0x9d9d21bc, 0x38387048, 0xf5f5f104);
-		AS_UINT4(&sharedMemory[0x178]) = make_uint4(0xbcbc63df, 0xb6b677c1, 0xdadaaf75, 0x21214263);
-		AS_UINT4(&sharedMemory[0x17C]) = make_uint4(0x10102030, 0xffffe51a, 0xf3f3fd0e, 0xd2d2bf6d);
-		break;
-	case 4:
-		AS_UINT4(&sharedMemory[0x180]) = make_uint4(0xcdcd814c, 0x0c0c1814, 0x13132635, 0xececc32f);
-		AS_UINT4(&sharedMemory[0x184]) = make_uint4(0x5f5fbee1, 0x979735a2, 0x444488cc, 0x17172e39);
-		AS_UINT4(&sharedMemory[0x188]) = make_uint4(0xc4c49357, 0xa7a755f2, 0x7e7efc82, 0x3d3d7a47);
-		AS_UINT4(&sharedMemory[0x18C]) = make_uint4(0x6464c8ac, 0x5d5dbae7, 0x1919322b, 0x7373e695);
-		AS_UINT4(&sharedMemory[0x190]) = make_uint4(0x6060c0a0, 0x81811998, 0x4f4f9ed1, 0xdcdca37f);
-		AS_UINT4(&sharedMemory[0x194]) = make_uint4(0x22224466, 0x2a2a547e, 0x90903bab, 0x88880b83);
-		AS_UINT4(&sharedMemory[0x198]) = make_uint4(0x46468cca, 0xeeeec729, 0xb8b86bd3, 0x1414283c);
-		AS_UINT4(&sharedMemory[0x19C]) = make_uint4(0xdedea779, 0x5e5ebce2, 0x0b0b161d, 0xdbdbad76);
-		break;
-	case 5:
-		AS_UINT4(&sharedMemory[0x1A0]) = make_uint4(0xe0e0db3b, 0x32326456, 0x3a3a744e, 0x0a0a141e);
-		AS_UINT4(&sharedMemory[0x1A4]) = make_uint4(0x494992db, 0x06060c0a, 0x2424486c, 0x5c5cb8e4);
-		AS_UINT4(&sharedMemory[0x1A8]) = make_uint4(0xc2c29f5d, 0xd3d3bd6e, 0xacac43ef, 0x6262c4a6);
-		AS_UINT4(&sharedMemory[0x1AC]) = make_uint4(0x919139a8, 0x959531a4, 0xe4e4d337, 0x7979f28b);
-		AS_UINT4(&sharedMemory[0x1B0]) = make_uint4(0xe7e7d532, 0xc8c88b43, 0x37376e59, 0x6d6ddab7);
-		AS_UINT4(&sharedMemory[0x1B4]) = make_uint4(0x8d8d018c, 0xd5d5b164, 0x4e4e9cd2, 0xa9a949e0);
-		AS_UINT4(&sharedMemory[0x1B8]) = make_uint4(0x6c6cd8b4, 0x5656acfa, 0xf4f4f307, 0xeaeacf25);
-		AS_UINT4(&sharedMemory[0x1BC]) = make_uint4(0x6565caaf, 0x7a7af48e, 0xaeae47e9, 0x08081018);
-		break;
-	case 6:
-		AS_UINT4(&sharedMemory[0x1C0]) = make_uint4(0xbaba6fd5, 0x7878f088, 0x25254a6f, 0x2e2e5c72);
-		AS_UINT4(&sharedMemory[0x1C4]) = make_uint4(0x1c1c3824, 0xa6a657f1, 0xb4b473c7, 0xc6c69751);
-		AS_UINT4(&sharedMemory[0x1C8]) = make_uint4(0xe8e8cb23, 0xdddda17c, 0x7474e89c, 0x1f1f3e21);
-		AS_UINT4(&sharedMemory[0x1CC]) = make_uint4(0x4b4b96dd, 0xbdbd61dc, 0x8b8b0d86, 0x8a8a0f85);
-		AS_UINT4(&sharedMemory[0x1D0]) = make_uint4(0x7070e090, 0x3e3e7c42, 0xb5b571c4, 0x6666ccaa);
-		AS_UINT4(&sharedMemory[0x1D4]) = make_uint4(0x484890d8, 0x03030605, 0xf6f6f701, 0x0e0e1c12);
-		AS_UINT4(&sharedMemory[0x1D8]) = make_uint4(0x6161c2a3, 0x35356a5f, 0x5757aef9, 0xb9b969d0);
-		AS_UINT4(&sharedMemory[0x1DC]) = make_uint4(0x86861791, 0xc1c19958, 0x1d1d3a27, 0x9e9e27b9);
-		break;
-	case 7:
-		AS_UINT4(&sharedMemory[0x1E0]) = make_uint4(0xe1e1d938, 0xf8f8eb13, 0x98982bb3, 0x11112233);
-		AS_UINT4(&sharedMemory[0x1E4]) = make_uint4(0x6969d2bb, 0xd9d9a970, 0x8e8e0789, 0x949433a7);
-		AS_UINT4(&sharedMemory[0x1E8]) = make_uint4(0x9b9b2db6, 0x1e1e3c22, 0x87871592, 0xe9e9c920);
-		AS_UINT4(&sharedMemory[0x1EC]) = make_uint4(0xcece8749, 0x5555aaff, 0x28285078, 0xdfdfa57a);
-		AS_UINT4(&sharedMemory[0x1F0]) = make_uint4(0x8c8c038f, 0xa1a159f8, 0x89890980, 0x0d0d1a17);
-		AS_UINT4(&sharedMemory[0x1F4]) = make_uint4(0xbfbf65da, 0xe6e6d731, 0x424284c6, 0x6868d0b8);
-		AS_UINT4(&sharedMemory[0x1F8]) = make_uint4(0x414182c3, 0x999929b0, 0x2d2d5a77, 0x0f0f1e11);
-		AS_UINT4(&sharedMemory[0x1FC]) = make_uint4(0xb0b07bcb, 0x5454a8fc, 0xbbbb6dd6, 0x16162c3a);
-		break;
-	}
-	// AES 2
-	switch (threadIdx.x) {
-	case 0:
-		AS_UINT4(&sharedMemory[0x200]) = make_uint4(0x63c6a563, 0x7cf8847c, 0x77ee9977, 0x7bf68d7b);
-		AS_UINT4(&sharedMemory[0x204]) = make_uint4(0xf2ff0df2, 0x6bd6bd6b, 0x6fdeb16f, 0xc59154c5);
-		AS_UINT4(&sharedMemory[0x208]) = make_uint4(0x30605030, 0x01020301, 0x67cea967, 0x2b567d2b);
-		AS_UINT4(&sharedMemory[0x20C]) = make_uint4(0xfee719fe, 0xd7b562d7, 0xab4de6ab, 0x76ec9a76);
-		AS_UINT4(&sharedMemory[0x210]) = make_uint4(0xca8f45ca, 0x821f9d82, 0xc98940c9, 0x7dfa877d);
-		AS_UINT4(&sharedMemory[0x214]) = make_uint4(0xfaef15fa, 0x59b2eb59, 0x478ec947, 0xf0fb0bf0);
-		AS_UINT4(&sharedMemory[0x218]) = make_uint4(0xad41ecad, 0xd4b367d4, 0xa25ffda2, 0xaf45eaaf);
-		AS_UINT4(&sharedMemory[0x21C]) = make_uint4(0x9c23bf9c, 0xa453f7a4, 0x72e49672, 0xc09b5bc0);
-		break;
-	case 1:
-		AS_UINT4(&sharedMemory[0x220]) = make_uint4(0xb775c2b7, 0xfde11cfd, 0x933dae93, 0x264c6a26);
-		AS_UINT4(&sharedMemory[0x224]) = make_uint4(0x366c5a36, 0x3f7e413f, 0xf7f502f7, 0xcc834fcc);
-		AS_UINT4(&sharedMemory[0x228]) = make_uint4(0x34685c34, 0xa551f4a5, 0xe5d134e5, 0xf1f908f1);
-		AS_UINT4(&sharedMemory[0x22C]) = make_uint4(0x71e29371, 0xd8ab73d8, 0x31625331, 0x152a3f15);
-		AS_UINT4(&sharedMemory[0x230]) = make_uint4(0x04080c04, 0xc79552c7, 0x23466523, 0xc39d5ec3);
-		AS_UINT4(&sharedMemory[0x234]) = make_uint4(0x18302818, 0x9637a196, 0x050a0f05, 0x9a2fb59a);
-		AS_UINT4(&sharedMemory[0x238]) = make_uint4(0x070e0907, 0x12243612, 0x801b9b80, 0xe2df3de2);
-		AS_UINT4(&sharedMemory[0x23C]) = make_uint4(0xebcd26eb, 0x274e6927, 0xb27fcdb2, 0x75ea9f75);
-		break;
-	case 2:
-		AS_UINT4(&sharedMemory[0x240]) = make_uint4(0x09121b09, 0x831d9e83, 0x2c58742c, 0x1a342e1a);
-		AS_UINT4(&sharedMemory[0x244]) = make_uint4(0x1b362d1b, 0x6edcb26e, 0x5ab4ee5a, 0xa05bfba0);
-		AS_UINT4(&sharedMemory[0x248]) = make_uint4(0x52a4f652, 0x3b764d3b, 0xd6b761d6, 0xb37dceb3);
-		AS_UINT4(&sharedMemory[0x24C]) = make_uint4(0x29527b29, 0xe3dd3ee3, 0x2f5e712f, 0x84139784);
-		AS_UINT4(&sharedMemory[0x250]) = make_uint4(0x53a6f553, 0xd1b968d1, 0x00000000, 0xedc12ced);
-		AS_UINT4(&sharedMemory[0x254]) = make_uint4(0x20406020, 0xfce31ffc, 0xb179c8b1, 0x5bb6ed5b);
-		AS_UINT4(&sharedMemory[0x258]) = make_uint4(0x6ad4be6a, 0xcb8d46cb, 0xbe67d9be, 0x39724b39);
-		AS_UINT4(&sharedMemory[0x25C]) = make_uint4(0x4a94de4a, 0x4c98d44c, 0x58b0e858, 0xcf854acf);
-		break;
-	case 3:
-		AS_UINT4(&sharedMemory[0x260]) = make_uint4(0xd0bb6bd0, 0xefc52aef, 0xaa4fe5aa, 0xfbed16fb);
-		AS_UINT4(&sharedMemory[0x264]) = make_uint4(0x4386c543, 0x4d9ad74d, 0x33665533, 0x85119485);
-		AS_UINT4(&sharedMemory[0x268]) = make_uint4(0x458acf45, 0xf9e910f9, 0x02040602, 0x7ffe817f);
-		AS_UINT4(&sharedMemory[0x26C]) = make_uint4(0x50a0f050, 0x3c78443c, 0x9f25ba9f, 0xa84be3a8);
-		AS_UINT4(&sharedMemory[0x270]) = make_uint4(0x51a2f351, 0xa35dfea3, 0x4080c040, 0x8f058a8f);
-		AS_UINT4(&sharedMemory[0x274]) = make_uint4(0x923fad92, 0x9d21bc9d, 0x38704838, 0xf5f104f5);
-		AS_UINT4(&sharedMemory[0x278]) = make_uint4(0xbc63dfbc, 0xb677c1b6, 0xdaaf75da, 0x21426321);
-		AS_UINT4(&sharedMemory[0x27C]) = make_uint4(0x10203010, 0xffe51aff, 0xf3fd0ef3, 0xd2bf6dd2);
-		break;
-	case 4:
-		AS_UINT4(&sharedMemory[0x280]) = make_uint4(0xcd814ccd, 0x0c18140c, 0x13263513, 0xecc32fec);
-		AS_UINT4(&sharedMemory[0x284]) = make_uint4(0x5fbee15f, 0x9735a297, 0x4488cc44, 0x172e3917);
-		AS_UINT4(&sharedMemory[0x288]) = make_uint4(0xc49357c4, 0xa755f2a7, 0x7efc827e, 0x3d7a473d);
-		AS_UINT4(&sharedMemory[0x28C]) = make_uint4(0x64c8ac64, 0x5dbae75d, 0x19322b19, 0x73e69573);
-		AS_UINT4(&sharedMemory[0x290]) = make_uint4(0x60c0a060, 0x81199881, 0x4f9ed14f, 0xdca37fdc);
-		AS_UINT4(&sharedMemory[0x294]) = make_uint4(0x22446622, 0x2a547e2a, 0x903bab90, 0x880b8388);
-		AS_UINT4(&sharedMemory[0x298]) = make_uint4(0x468cca46, 0xeec729ee, 0xb86bd3b8, 0x14283c14);
-		AS_UINT4(&sharedMemory[0x29C]) = make_uint4(0xdea779de, 0x5ebce25e, 0x0b161d0b, 0xdbad76db);
-		break;
-	case 5:
-		AS_UINT4(&sharedMemory[0x2A0]) = make_uint4(0xe0db3be0, 0x32645632, 0x3a744e3a, 0x0a141e0a);
-		AS_UINT4(&sharedMemory[0x2A4]) = make_uint4(0x4992db49, 0x060c0a06, 0x24486c24, 0x5cb8e45c);
-		AS_UINT4(&sharedMemory[0x2A8]) = make_uint4(0xc29f5dc2, 0xd3bd6ed3, 0xac43efac, 0x62c4a662);
-		AS_UINT4(&sharedMemory[0x2AC]) = make_uint4(0x9139a891, 0x9531a495, 0xe4d337e4, 0x79f28b79);
-		AS_UINT4(&sharedMemory[0x2B0]) = make_uint4(0xe7d532e7, 0xc88b43c8, 0x376e5937, 0x6ddab76d);
-		AS_UINT4(&sharedMemory[0x2B4]) = make_uint4(0x8d018c8d, 0xd5b164d5, 0x4e9cd24e, 0xa949e0a9);
-		AS_UINT4(&sharedMemory[0x2B8]) = make_uint4(0x6cd8b46c, 0x56acfa56, 0xf4f307f4, 0xeacf25ea);
-		AS_UINT4(&sharedMemory[0x2BC]) = make_uint4(0x65caaf65, 0x7af48e7a, 0xae47e9ae, 0x08101808);
-		break;
-	case 6:
-		AS_UINT4(&sharedMemory[0x2C0]) = make_uint4(0xba6fd5ba, 0x78f08878, 0x254a6f25, 0x2e5c722e);
-		AS_UINT4(&sharedMemory[0x2C4]) = make_uint4(0x1c38241c, 0xa657f1a6, 0xb473c7b4, 0xc69751c6);
-		AS_UINT4(&sharedMemory[0x2C8]) = make_uint4(0xe8cb23e8, 0xdda17cdd, 0x74e89c74, 0x1f3e211f);
-		AS_UINT4(&sharedMemory[0x2CC]) = make_uint4(0x4b96dd4b, 0xbd61dcbd, 0x8b0d868b, 0x8a0f858a);
-		AS_UINT4(&sharedMemory[0x2D0]) = make_uint4(0x70e09070, 0x3e7c423e, 0xb571c4b5, 0x66ccaa66);
-		AS_UINT4(&sharedMemory[0x2D4]) = make_uint4(0x4890d848, 0x03060503, 0xf6f701f6, 0x0e1c120e);
-		AS_UINT4(&sharedMemory[0x2D8]) = make_uint4(0x61c2a361, 0x356a5f35, 0x57aef957, 0xb969d0b9);
-		AS_UINT4(&sharedMemory[0x2DC]) = make_uint4(0x86179186, 0xc19958c1, 0x1d3a271d, 0x9e27b99e);
-		break;
-	case 7:
-		AS_UINT4(&sharedMemory[0x2E0]) = make_uint4(0xe1d938e1, 0xf8eb13f8, 0x982bb398, 0x11223311);
-		AS_UINT4(&sharedMemory[0x2E4]) = make_uint4(0x69d2bb69, 0xd9a970d9, 0x8e07898e, 0x9433a794);
-		AS_UINT4(&sharedMemory[0x2E8]) = make_uint4(0x9b2db69b, 0x1e3c221e, 0x87159287, 0xe9c920e9);
-		AS_UINT4(&sharedMemory[0x2EC]) = make_uint4(0xce8749ce, 0x55aaff55, 0x28507828, 0xdfa57adf);
-		AS_UINT4(&sharedMemory[0x2F0]) = make_uint4(0x8c038f8c, 0xa159f8a1, 0x89098089, 0x0d1a170d);
-		AS_UINT4(&sharedMemory[0x2F4]) = make_uint4(0xbf65dabf, 0xe6d731e6, 0x4284c642, 0x68d0b868);
-		AS_UINT4(&sharedMemory[0x2F8]) = make_uint4(0x4182c341, 0x9929b099, 0x2d5a772d, 0x0f1e110f);
-		AS_UINT4(&sharedMemory[0x2FC]) = make_uint4(0xb07bcbb0, 0x54a8fc54, 0xbb6dd6bb, 0x162c3a16);
-		break;
-	}
-	// AES 3
-	switch (threadIdx.x) {
-	case 0:
-		AS_UINT4(&sharedMemory[0x300]) = make_uint4(0xc6a56363, 0xf8847c7c, 0xee997777, 0xf68d7b7b);
-		AS_UINT4(&sharedMemory[0x304]) = make_uint4(0xff0df2f2, 0xd6bd6b6b, 0xdeb16f6f, 0x9154c5c5);
-		AS_UINT4(&sharedMemory[0x308]) = make_uint4(0x60503030, 0x02030101, 0xcea96767, 0x567d2b2b);
-		AS_UINT4(&sharedMemory[0x30C]) = make_uint4(0xe719fefe, 0xb562d7d7, 0x4de6abab, 0xec9a7676);
-		AS_UINT4(&sharedMemory[0x310]) = make_uint4(0x8f45caca, 0x1f9d8282, 0x8940c9c9, 0xfa877d7d);
-		AS_UINT4(&sharedMemory[0x314]) = make_uint4(0xef15fafa, 0xb2eb5959, 0x8ec94747, 0xfb0bf0f0);
-		AS_UINT4(&sharedMemory[0x318]) = make_uint4(0x41ecadad, 0xb367d4d4, 0x5ffda2a2, 0x45eaafaf);
-		AS_UINT4(&sharedMemory[0x31C]) = make_uint4(0x23bf9c9c, 0x53f7a4a4, 0xe4967272, 0x9b5bc0c0);
-		break;
-	case 1:
-		AS_UINT4(&sharedMemory[0x320]) = make_uint4(0x75c2b7b7, 0xe11cfdfd, 0x3dae9393, 0x4c6a2626);
-		AS_UINT4(&sharedMemory[0x324]) = make_uint4(0x6c5a3636, 0x7e413f3f, 0xf502f7f7, 0x834fcccc);
-		AS_UINT4(&sharedMemory[0x328]) = make_uint4(0x685c3434, 0x51f4a5a5, 0xd134e5e5, 0xf908f1f1);
-		AS_UINT4(&sharedMemory[0x32C]) = make_uint4(0xe2937171, 0xab73d8d8, 0x62533131, 0x2a3f1515);
-		AS_UINT4(&sharedMemory[0x330]) = make_uint4(0x080c0404, 0x9552c7c7, 0x46652323, 0x9d5ec3c3);
-		AS_UINT4(&sharedMemory[0x334]) = make_uint4(0x30281818, 0x37a19696, 0x0a0f0505, 0x2fb59a9a);
-		AS_UINT4(&sharedMemory[0x338]) = make_uint4(0x0e090707, 0x24361212, 0x1b9b8080, 0xdf3de2e2);
-		AS_UINT4(&sharedMemory[0x33C]) = make_uint4(0xcd26ebeb, 0x4e692727, 0x7fcdb2b2, 0xea9f7575);
-		break;
-	case 2:
-		AS_UINT4(&sharedMemory[0x340]) = make_uint4(0x121b0909, 0x1d9e8383, 0x58742c2c, 0x342e1a1a);
-		AS_UINT4(&sharedMemory[0x344]) = make_uint4(0x362d1b1b, 0xdcb26e6e, 0xb4ee5a5a, 0x5bfba0a0);
-		AS_UINT4(&sharedMemory[0x348]) = make_uint4(0xa4f65252, 0x764d3b3b, 0xb761d6d6, 0x7dceb3b3);
-		AS_UINT4(&sharedMemory[0x34C]) = make_uint4(0x527b2929, 0xdd3ee3e3, 0x5e712f2f, 0x13978484);
-		AS_UINT4(&sharedMemory[0x350]) = make_uint4(0xa6f55353, 0xb968d1d1, 0x00000000, 0xc12ceded);
-		AS_UINT4(&sharedMemory[0x354]) = make_uint4(0x40602020, 0xe31ffcfc, 0x79c8b1b1, 0xb6ed5b5b);
-		AS_UINT4(&sharedMemory[0x358]) = make_uint4(0xd4be6a6a, 0x8d46cbcb, 0x67d9bebe, 0x724b3939);
-		AS_UINT4(&sharedMemory[0x35C]) = make_uint4(0x94de4a4a, 0x98d44c4c, 0xb0e85858, 0x854acfcf);
-		break;
-	case 3:
-		AS_UINT4(&sharedMemory[0x360]) = make_uint4(0xbb6bd0d0, 0xc52aefef, 0x4fe5aaaa, 0xed16fbfb);
-		AS_UINT4(&sharedMemory[0x364]) = make_uint4(0x86c54343, 0x9ad74d4d, 0x66553333, 0x11948585);
-		AS_UINT4(&sharedMemory[0x368]) = make_uint4(0x8acf4545, 0xe910f9f9, 0x04060202, 0xfe817f7f);
-		AS_UINT4(&sharedMemory[0x36C]) = make_uint4(0xa0f05050, 0x78443c3c, 0x25ba9f9f, 0x4be3a8a8);
-		AS_UINT4(&sharedMemory[0x370]) = make_uint4(0xa2f35151, 0x5dfea3a3, 0x80c04040, 0x058a8f8f);
-		AS_UINT4(&sharedMemory[0x374]) = make_uint4(0x3fad9292, 0x21bc9d9d, 0x70483838, 0xf104f5f5);
-		AS_UINT4(&sharedMemory[0x378]) = make_uint4(0x63dfbcbc, 0x77c1b6b6, 0xaf75dada, 0x42632121);
-		AS_UINT4(&sharedMemory[0x37C]) = make_uint4(0x20301010, 0xe51affff, 0xfd0ef3f3, 0xbf6dd2d2);
-		break;
-	case 4:
-		AS_UINT4(&sharedMemory[0x380]) = make_uint4(0x814ccdcd, 0x18140c0c, 0x26351313, 0xc32fecec);
-		AS_UINT4(&sharedMemory[0x384]) = make_uint4(0xbee15f5f, 0x35a29797, 0x88cc4444, 0x2e391717);
-		AS_UINT4(&sharedMemory[0x388]) = make_uint4(0x9357c4c4, 0x55f2a7a7, 0xfc827e7e, 0x7a473d3d);
-		AS_UINT4(&sharedMemory[0x38C]) = make_uint4(0xc8ac6464, 0xbae75d5d, 0x322b1919, 0xe6957373);
-		AS_UINT4(&sharedMemory[0x390]) = make_uint4(0xc0a06060, 0x19988181, 0x9ed14f4f, 0xa37fdcdc);
-		AS_UINT4(&sharedMemory[0x394]) = make_uint4(0x44662222, 0x547e2a2a, 0x3bab9090, 0x0b838888);
-		AS_UINT4(&sharedMemory[0x398]) = make_uint4(0x8cca4646, 0xc729eeee, 0x6bd3b8b8, 0x283c1414);
-		AS_UINT4(&sharedMemory[0x39C]) = make_uint4(0xa779dede, 0xbce25e5e, 0x161d0b0b, 0xad76dbdb);
-		break;
-	case 5:
-		AS_UINT4(&sharedMemory[0x3A0]) = make_uint4(0xdb3be0e0, 0x64563232, 0x744e3a3a, 0x141e0a0a);
-		AS_UINT4(&sharedMemory[0x3A4]) = make_uint4(0x92db4949, 0x0c0a0606, 0x486c2424, 0xb8e45c5c);
-		AS_UINT4(&sharedMemory[0x3A8]) = make_uint4(0x9f5dc2c2, 0xbd6ed3d3, 0x43efacac, 0xc4a66262);
-		AS_UINT4(&sharedMemory[0x3AC]) = make_uint4(0x39a89191, 0x31a49595, 0xd337e4e4, 0xf28b7979);
-		AS_UINT4(&sharedMemory[0x3B0]) = make_uint4(0xd532e7e7, 0x8b43c8c8, 0x6e593737, 0xdab76d6d);
-		AS_UINT4(&sharedMemory[0x3B4]) = make_uint4(0x018c8d8d, 0xb164d5d5, 0x9cd24e4e, 0x49e0a9a9);
-		AS_UINT4(&sharedMemory[0x3B8]) = make_uint4(0xd8b46c6c, 0xacfa5656, 0xf307f4f4, 0xcf25eaea);
-		AS_UINT4(&sharedMemory[0x3BC]) = make_uint4(0xcaaf6565, 0xf48e7a7a, 0x47e9aeae, 0x10180808);
-		break;
-	case 6:
-		AS_UINT4(&sharedMemory[0x3C0]) = make_uint4(0x6fd5baba, 0xf0887878, 0x4a6f2525, 0x5c722e2e);
-		AS_UINT4(&sharedMemory[0x3C4]) = make_uint4(0x38241c1c, 0x57f1a6a6, 0x73c7b4b4, 0x9751c6c6);
-		AS_UINT4(&sharedMemory[0x3C8]) = make_uint4(0xcb23e8e8, 0xa17cdddd, 0xe89c7474, 0x3e211f1f);
-		AS_UINT4(&sharedMemory[0x3CC]) = make_uint4(0x96dd4b4b, 0x61dcbdbd, 0x0d868b8b, 0x0f858a8a);
-		AS_UINT4(&sharedMemory[0x3D0]) = make_uint4(0xe0907070, 0x7c423e3e, 0x71c4b5b5, 0xccaa6666);
-		AS_UINT4(&sharedMemory[0x3D4]) = make_uint4(0x90d84848, 0x06050303, 0xf701f6f6, 0x1c120e0e);
-		AS_UINT4(&sharedMemory[0x3D8]) = make_uint4(0xc2a36161, 0x6a5f3535, 0xaef95757, 0x69d0b9b9);
-		AS_UINT4(&sharedMemory[0x3DC]) = make_uint4(0x17918686, 0x9958c1c1, 0x3a271d1d, 0x27b99e9e);
-		break;
-	case 7:
-		AS_UINT4(&sharedMemory[0x3E0]) = make_uint4(0xd938e1e1, 0xeb13f8f8, 0x2bb39898, 0x22331111);
-		AS_UINT4(&sharedMemory[0x3E4]) = make_uint4(0xd2bb6969, 0xa970d9d9, 0x07898e8e, 0x33a79494);
-		AS_UINT4(&sharedMemory[0x3E8]) = make_uint4(0x2db69b9b, 0x3c221e1e, 0x15928787, 0xc920e9e9);
-		AS_UINT4(&sharedMemory[0x3EC]) = make_uint4(0x8749cece, 0xaaff5555, 0x50782828, 0xa57adfdf);
-		AS_UINT4(&sharedMemory[0x3F0]) = make_uint4(0x038f8c8c, 0x59f8a1a1, 0x09808989, 0x1a170d0d);
-		AS_UINT4(&sharedMemory[0x3F4]) = make_uint4(0x65dabfbf, 0xd731e6e6, 0x84c64242, 0xd0b86868);
-		AS_UINT4(&sharedMemory[0x3F8]) = make_uint4(0x82c34141, 0x29b09999, 0x5a772d2d, 0x1e110f0f);
-		AS_UINT4(&sharedMemory[0x3FC]) = make_uint4(0x7bcbb0b0, 0xa8fc5454, 0x6dd6bbbb, 0x2c3a1616);
-		break;
-	}
-}
+}
\ No newline at end of file
diff --git a/crypto/cryptonight-core.cu b/crypto/cryptonight-core.cu
index 4780f3751..bdf70b795 100644
--- a/crypto/cryptonight-core.cu
+++ b/crypto/cryptonight-core.cu
@@ -2,185 +2,242 @@
 #include <stdint.h>
 #include <string.h>
 #include <sys/time.h>
-#include <unistd.h>
-
+#include "cuda.h"
+#include "cuda_runtime.h"
 #include "cryptonight.h"
 
-#define LONG_SHL32 19 // 1<<19
-#define LONG_SHL64 18 // 1<<18 (uint64_t* index)
-#define LONG_LOOPS32 0x80000U
-#define LONG_LOOPS64 0x40000U
+#ifndef _WIN32
+#include <unistd.h>
+#endif
+
+extern int device_arch[MAX_GPU][2];
+extern int device_bfactor[MAX_GPU];
+extern int device_bsleep[MAX_GPU];
 
 #include "cn_aes.cuh"
 
-__global__
-//__launch_bounds__(128, 9) // 56 registers
-void cryptonight_core_gpu_phase1(const uint32_t threads, uint64_t * long_state, uint64_t * const ctx_state, uint32_t * ctx_key1)
+#define VARIANT1_1(p) \
+  do if (variant > 0 && sub == 2) \
+  { \
+    uint32_t tmp32 = loadGlobal32<uint32_t>(p); \
+    uint8_t tmp = tmp32 >> 24; \
+    uint8_t tmp1 = (tmp>>4)&1, tmp2 = (tmp>>5)&1, tmp3 = tmp1^tmp2; \
+    uint8_t tmp0 = nonce_flag ? tmp3 : tmp1 + 1; \
+    tmp32 &= 0x00ffffff; tmp32 |= ((tmp & 0xef) | (tmp0<<4)) << 24; \
+    storeGlobal32<uint32_t>(p, tmp32); \
+  } while(0)
+
+#define VARIANT1_2(p) VARIANT1_1(p)
+#define VARIANT1_INIT() \
+  nonce_flag ^= (thread & 1)
+
+__device__ __forceinline__ uint64_t cuda_mul128(uint64_t multiplier, uint64_t multiplicand, uint64_t* product_hi)
 {
-	__shared__ __align__(16) uint32_t sharedMemory[1024];
-	cn_aes_gpu_init(sharedMemory);
-	__syncthreads();
+	*product_hi = __umul64hi(multiplier, multiplicand);
+	return(multiplier * multiplicand);
+}
+
+template< typename T >
+__device__ __forceinline__ T loadGlobal64(T * const addr)
+{
+	T x;
+	asm volatile(
+		"ld.global.cg.u64 %0, [%1];" : "=l"(x) : "l"(addr)
+		);
+	return x;
+}
 
-	const uint32_t thread = (blockDim.x * blockIdx.x + threadIdx.x) >> 3;
-	const uint32_t sub = (threadIdx.x & 7) << 1; // 0 2 .. 14
+template< typename T >
+__device__ __forceinline__ T loadGlobal32(T * const addr)
+{
+	T x;
+	asm volatile(
+		"ld.global.cg.u32 %0, [%1];" : "=r"(x) : "l"(addr)
+		);
+	return x;
+}
+
+template< typename T >
+__device__ __forceinline__ void storeGlobal32(T* addr, T const & val)
+{
+	asm volatile(
+		"st.global.cg.u32 [%0], %1;" : : "l"(addr), "r"(val)
+		);
+
+}
 
+__global__ void cryptonight_core_gpu_phase1(int threads, uint32_t * __restrict__ long_state, uint32_t * __restrict__ ctx_state, uint32_t * __restrict__ ctx_key1)
+{
+	__shared__ uint32_t sharedMemory[1024];
+
+	const int thread = (blockDim.x * blockIdx.x + threadIdx.x) >> 3;
 	if(thread < threads)
 	{
-		const uint32_t long_oft = (thread << LONG_SHL64) + sub;
+		cn_aes_gpu_init(sharedMemory);
+		__syncthreads();
+
+		const int sub = (threadIdx.x & 7) << 2;
+		uint32_t *longstate = &long_state[(thread << 19) + sub];
 
-		const uint32_t* ctx_key = &ctx_key1[thread * 40U];
-		uint4 keys[10];
-		#pragma unroll 10 // load 160 bytes
-		for (int i = 0; i < 10; i ++)
-			keys[i] = AS_UINT4(&ctx_key[i*4]);
+		uint32_t key[40], text[4];
 
-		uint4 text = AS_UINT4(&ctx_state[thread * 26U + sub + 8U]);
+		MEMCPY8(key, ctx_key1 + thread * 40, 20);
+		MEMCPY8(text, ctx_state + thread * 50 + sub + 16, 2);
 
-		for (uint32_t i = 0; i < LONG_LOOPS64; i += 16U) {
-			cn_aes_pseudo_round_mut_uint4(sharedMemory, text, keys);
-			AS_UINT4(&long_state[long_oft + i]) = text;
+		for(int i = 0; i < 0x80000; i += 32)
+		{
+			cn_aes_pseudo_round_mut(sharedMemory, text, key);
+			MEMCPY8(&longstate[i], text, 2);
 		}
 	}
 }
 
-__device__ __forceinline__ ulonglong2 cuda_mul128(const uint64_t multiplier, const uint64_t multiplicand)
+__device__ __forceinline__ void MUL_SUM_XOR_DST(uint64_t a, uint64_t *__restrict__ c, uint64_t *__restrict__ dst)
 {
-	ulonglong2 product;
-	product.x = __umul64hi(multiplier, multiplicand);
-	product.y = multiplier * multiplicand;
-	return product;
-}
-
-static __forceinline__ __device__ void operator += (ulonglong2 &a, const ulonglong2 b) {
-	a.x += b.x; a.y += b.y;
-}
-
-static __forceinline__ __device__ ulonglong2 operator ^ (const ulonglong2 &a, const ulonglong2 &b) {
-	return make_ulonglong2(a.x ^ b.x, a.y ^ b.y);
+	uint64_t hi = __umul64hi(a, dst[0]) + c[0];
+	uint64_t lo = a * dst[0] + c[1];
+	c[0] = dst[0] ^ hi;
+	c[1] = dst[1] ^ lo;
+	dst[0] = hi;
+	dst[1] = lo;
 }
 
-#undef MUL_SUM_XOR_DST
-__device__ __forceinline__ void MUL_SUM_XOR_DST(const uint64_t m, uint4 &a, void* far_dst)
+__global__ void cryptonight_core_gpu_phase2(uint32_t threads, int bfactor, int partidx, uint32_t * __restrict__ d_long_state, uint32_t * __restrict__ d_ctx_a, uint32_t * __restrict__ d_ctx_b, int variant, uint8_t nonce_flag)
 {
-	ulonglong2 d = AS_UL2(far_dst);
-	ulonglong2 p = cuda_mul128(m, d.x);
-	p += AS_UL2(&a);
-	AS_UL2(&a) = p ^ d;
-	AS_UL2(far_dst) = p;
-}
+	__shared__ uint32_t sharedMemory[1024];
 
-__global__
-#if __CUDA_ARCH__ >= 500
-//__launch_bounds__(128,12) /* force 40 regs to allow -l ...x32 */
-#endif
-void cryptonight_core_gpu_phase2(const uint32_t threads, const uint32_t bfactor, const uint32_t partidx,
-	uint64_t * d_long_state, uint32_t * d_ctx_a, uint32_t * d_ctx_b)
-{
-	__shared__ __align__(16) uint32_t sharedMemory[1024];
 	cn_aes_gpu_init(sharedMemory);
 	__syncthreads();
 
-	const uint32_t thread = blockDim.x * blockIdx.x + threadIdx.x;
-
-	if (thread < threads)
+	const int thread = (blockDim.x * blockIdx.x + threadIdx.x) >> 2;
+	if (thread >= threads)
+		return;
+
+	VARIANT1_INIT();
+
+	const int sub = threadIdx.x & 3;
+	const int sub2 = threadIdx.x & 2;
+
+	int i, k;
+	uint32_t j;
+	const int batchsize = ITER >> (2 + bfactor);
+	const int start = partidx * batchsize;
+	const int end = start + batchsize;
+	uint32_t * long_state = &d_long_state[thread << 19];
+	uint32_t * ctx_a = d_ctx_a + thread * 4;
+	uint32_t * ctx_b = d_ctx_b + thread * 4;
+	uint32_t a, d[2];
+	uint32_t t1[2], t2[2], res;
+
+	a = ctx_a[sub];
+	d[1] = ctx_b[sub];
+#pragma unroll 2
+	for (i = start; i < end; ++i)
 	{
-		const uint32_t batchsize = ITER >> (2U + bfactor);
-		const uint32_t start = partidx * batchsize;
-		const uint32_t end = start + batchsize;
-
-		void * ctx_a = (void*)(&d_ctx_a[thread << 2U]);
-		void * ctx_b = (void*)(&d_ctx_b[thread << 2U]);
-		uint4 A = AS_UINT4(ctx_a); // ld.global.u32.v4
-		uint4 B = AS_UINT4(ctx_b);
-
-		uint64_t * long_state = &d_long_state[thread << LONG_SHL64];
-		for (int i = start; i < end; i++) // end = 262144
+#pragma unroll 2
+		for (int x = 0; x < 2; ++x)
 		{
-			uint4 C;
-
-			uint32_t j = (A.x & E2I_MASK) >> 3;
-			cn_aes_single_round_b((uint8_t*)sharedMemory, &long_state[j], A, &C);
-			AS_UINT4(&long_state[j]) = C ^ B; // st.global.u32.v4
-			MUL_SUM_XOR_DST((AS_UL2(&C)).x, A, &long_state[(C.x & E2I_MASK) >> 3]);
-
-			j = (A.x & E2I_MASK) >> 3;
-			cn_aes_single_round_b((uint8_t*)sharedMemory, &long_state[j], A, &B);
-			AS_UINT4(&long_state[j]) = C ^ B;
-			MUL_SUM_XOR_DST((AS_UL2(&B)).x, A, &long_state[(B.x & E2I_MASK) >> 3]);
+			j = ((__shfl(a, 0, 4) & 0x1FFFF0) >> 2) + sub;
+
+			const uint32_t x_0 = loadGlobal32<uint32_t>(long_state + j);
+			const uint32_t x_1 = __shfl(x_0, sub + 1, 4);
+			const uint32_t x_2 = __shfl(x_0, sub + 2, 4);
+			const uint32_t x_3 = __shfl(x_0, sub + 3, 4);
+			d[x] = a ^
+				t_fn0(x_0 & 0xff) ^
+				t_fn1((x_1 >> 8) & 0xff) ^
+				t_fn2((x_2 >> 16) & 0xff) ^
+				t_fn3((x_3 >> 24));
+
+
+			//XOR_BLOCKS_DST(c, b, &long_state[j]);
+			t1[0] = __shfl(d[x], 0, 4);
+			//long_state[j] = d[0] ^ d[1];
+			storeGlobal32(long_state + j, d[0] ^ d[1]);
+			VARIANT1_1(long_state + j);
+
+			//MUL_SUM_XOR_DST(c, a, &long_state[((uint32_t *)c)[0] & 0x1FFFF0]);
+			j = ((*t1 & 0x1FFFF0) >> 2) + sub;
+
+			uint32_t yy[2];
+			*((uint64_t*)yy) = loadGlobal64<uint64_t>(((uint64_t *)long_state) + (j >> 1));
+			uint32_t zz[2];
+			zz[0] = __shfl(yy[0], 0, 4);
+			zz[1] = __shfl(yy[1], 0, 4);
+
+			t1[1] = __shfl(d[x], 1, 4);
+#pragma unroll
+			for (k = 0; k < 2; k++)
+				t2[k] = __shfl(a, k + sub2, 4);
+
+			*((uint64_t *)t2) += sub2 ? (*((uint64_t *)t1) * *((uint64_t*)zz)) : __umul64hi(*((uint64_t *)t1), *((uint64_t*)zz));
+
+			res = *((uint64_t *)t2) >> (sub & 1 ? 32 : 0);
+
+			storeGlobal32(long_state + j, res);
+			VARIANT1_2(long_state + j);
+			a = (sub & 1 ? yy[1] : yy[0]) ^ res;
 		}
+	}
 
-		if (bfactor) {
-			AS_UINT4(ctx_a) = A;
-			AS_UINT4(ctx_b) = B;
-		}
+	if (bfactor > 0)
+	{
+		ctx_a[sub] = a;
+		ctx_b[sub] = d[1];
 	}
 }
 
-__global__
-void cryptonight_core_gpu_phase3(const uint32_t threads, const uint64_t * long_state, uint64_t * ctx_state, uint32_t * __restrict__ ctx_key2)
+__global__ void cryptonight_core_gpu_phase3(int threads, const uint32_t * __restrict__ long_state, uint32_t * __restrict__ d_ctx_state, const uint32_t * __restrict__ d_ctx_key2)
 {
-	__shared__ __align__(16) uint32_t sharedMemory[1024];
+	__shared__ uint32_t sharedMemory[1024];
+
 	cn_aes_gpu_init(sharedMemory);
 	__syncthreads();
 
-	const uint32_t thread = (blockDim.x * blockIdx.x + threadIdx.x) >> 3U;
-	const uint32_t sub = (threadIdx.x & 7U) << 1U;
+	const int thread = (blockDim.x * blockIdx.x + threadIdx.x) >> 3;
 
 	if(thread < threads)
 	{
-		const uint32_t long_oft = (thread << LONG_SHL64) + sub;
-		const uint32_t st_oft = (thread * 26U) + sub + 8U;
-
-		uint4 key[10];
-		const uint32_t* ctx_key = &ctx_key2[thread * 40U];
-		#pragma unroll 10 // 160 bytes
-		for (int i = 0; i < 10; i++)
-			key[i] = AS_UINT4(&ctx_key[i*4U]);
-
-		uint4 text = AS_UINT4(&ctx_state[st_oft]);
+		const int sub = (threadIdx.x & 7) << 2;
+		const uint32_t *longstate = &long_state[(thread << 19) + sub];
+		uint32_t key[40], text[4], i, j;
+		MEMCPY8(key, d_ctx_key2 + thread * 40, 20);
+		MEMCPY8(text, d_ctx_state + thread * 50 + sub + 16, 2);
 
-		for(uint32_t i = 0; i < LONG_LOOPS64; i += 16U)
+		for(i = 0; i < 0x80000; i += 32)
 		{
-			uint4 st = AS_UINT4(&long_state[long_oft + i]);
-			text = text ^ st;
-			cn_aes_pseudo_round_mut_uint4(sharedMemory, text, key);
+#pragma unroll
+			for(j = 0; j < 4; ++j)
+				text[j] ^= longstate[i + j];
+
+			cn_aes_pseudo_round_mut(sharedMemory, text, key);
 		}
 
-		AS_UINT4(&ctx_state[st_oft]) = text;
+		MEMCPY8(d_ctx_state + thread * 50 + sub + 16, text, 2);
 	}
 }
 
-extern int device_bfactor[MAX_GPUS];
-
-__host__
-void cryptonight_core_cuda(int thr_id, int blocks, int threads, uint64_t *d_long_state, uint64_t *d_ctx_state,
-	uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2)
+__host__ void cryptonight_core_cpu_hash(int thr_id, int blocks, int threads, uint32_t *d_long_state, uint32_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2, int variant, uint8_t nonce_flag)
 {
 	dim3 grid(blocks);
 	dim3 block(threads);
-	//dim3 block2(threads << 1);
 	dim3 block4(threads << 2);
 	dim3 block8(threads << 3);
 
-	const uint32_t bfactor = (uint32_t) device_bfactor[thr_id];
-	const uint32_t partcount = 1 << bfactor;
-	const uint32_t throughput = (uint32_t) (blocks*threads);
-
-	const int bsleep = bfactor ? 100 : 0;
-	const int dev_id = device_map[thr_id];
+	int i, partcount = 1 << device_bfactor[thr_id];
 
-	cryptonight_core_gpu_phase1 <<<grid, block8>>> (throughput, d_long_state, d_ctx_state, d_ctx_key1);
-	exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
-	if(partcount > 1) usleep(bsleep);
+	cryptonight_core_gpu_phase1 <<< grid, block8 >>>(blocks*threads, d_long_state, d_ctx_state, d_ctx_key1);
+	exit_if_cudaerror(thr_id, __FILE__, __LINE__);
+	if(partcount > 1) usleep(device_bsleep[thr_id]);
 
-	for (uint32_t i = 0; i < partcount; i++)
+	for(i = 0; i < partcount; i++)
 	{
-		dim3 b = device_sm[dev_id] >= 300 ? block4 : block;
-		cryptonight_core_gpu_phase2 <<<grid, b>>> (throughput, bfactor, i, d_long_state, d_ctx_a, d_ctx_b);
-		exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
-		if(partcount > 1) usleep(bsleep);
+		cryptonight_core_gpu_phase2 <<< grid, block4 >>>(blocks*threads, device_bfactor[thr_id], i, d_long_state, d_ctx_a, d_ctx_b, variant, nonce_flag);
+		exit_if_cudaerror(thr_id, __FILE__, __LINE__);
+		if(partcount > 1) usleep(device_bsleep[thr_id]);
 	}
-
-	cryptonight_core_gpu_phase3 <<<grid, block8>>> (throughput, d_long_state, d_ctx_state, d_ctx_key2);
-	exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
-}
+	cudaDeviceSynchronize();
+	exit_if_cudaerror(thr_id, __FILE__, __LINE__);
+	cryptonight_core_gpu_phase3 <<< grid, block8 >>>(blocks*threads, d_long_state, d_ctx_state, d_ctx_key2);
+	exit_if_cudaerror(thr_id, __FILE__, __LINE__);
+}
\ No newline at end of file
diff --git a/crypto/cryptonight-cpu.cpp b/crypto/cryptonight-cpu.cpp
index 66b3cf47a..01fce21fa 100644
--- a/crypto/cryptonight-cpu.cpp
+++ b/crypto/cryptonight-cpu.cpp
@@ -12,6 +12,20 @@ extern "C" {
 #include "cpu/c_keccak.h"
 }
 
+#define VARIANT1_1(p) \
+  do if (variant > 0) \
+  { \
+    uint8_t tmp = ((const uint8_t*)p)[11]; \
+    uint8_t tmp1 = (tmp>>4)&1, tmp2 = (tmp>>5)&1, tmp3 = tmp1^tmp2; \
+    uint8_t tmp0 = nonce_flag ? tmp3 : tmp1 + 1; \
+    ((uint8_t*)p)[11] = (tmp & 0xef) | (tmp0<<4); \
+  } while(0)
+
+#define VARIANT1_2(p) VARIANT1_1(p)
+#define VARIANT1_INIT() \
+  const uint8_t nonce_flag = variant > 0 ? ((const uint8_t*)input)[39] & 0x01 : 0
+
+
 struct cryptonight_ctx {
 	uint8_t long_state[MEMORY];
 	union cn_slow_hash_state state;
@@ -155,13 +169,15 @@ static void xor_blocks_dst(const uint8_t* a, const uint8_t* b, uint8_t* dst) {
 	((uint64_t*) dst)[1] = ((uint64_t*) a)[1] ^ ((uint64_t*) b)[1];
 }
 
-static void cryptonight_hash_ctx(void* output, const void* input, size_t len, struct cryptonight_ctx* ctx)
+static void cryptonight_hash_ctx(void* output, const void* input, size_t len, struct cryptonight_ctx* ctx, int variant)
 {
 	size_t i, j;
 	keccak_hash_process(&ctx->state.hs, (const uint8_t*) input, len);
 	ctx->aes_ctx = (oaes_ctx*) oaes_alloc();
 	memcpy(ctx->text, ctx->state.init, INIT_SIZE_BYTE);
 
+	VARIANT1_INIT();
+
 	oaes_key_import_data(ctx->aes_ctx, ctx->state.hs.b, AES_KEY_SIZE);
 	for (i = 0; likely(i < MEMORY); i += INIT_SIZE_BYTE) {
 #undef RND
@@ -184,14 +200,18 @@ static void cryptonight_hash_ctx(void* output, const void* input, size_t len, st
 		j = e2i(ctx->a) * AES_BLOCK_SIZE;
 		aesb_single_round(&ctx->long_state[j], ctx->c, ctx->a);
 		xor_blocks_dst(ctx->c, ctx->b, &ctx->long_state[j]);
+		VARIANT1_1(&ctx->long_state[j]);
 
 		mul_sum_xor_dst(ctx->c, ctx->a, &ctx->long_state[e2i(ctx->c) * AES_BLOCK_SIZE]);
+		VARIANT1_2(&ctx->long_state[e2i(ctx->c) * AES_BLOCK_SIZE]);
 
 		j = e2i(ctx->a) * AES_BLOCK_SIZE;
 		aesb_single_round(&ctx->long_state[j], ctx->b, ctx->a);
 		xor_blocks_dst(ctx->b, ctx->c, &ctx->long_state[j]);
+		VARIANT1_1(&ctx->long_state[j]);
 
 		mul_sum_xor_dst(ctx->b, ctx->a, &ctx->long_state[e2i(ctx->b) * AES_BLOCK_SIZE]);
+		VARIANT1_2(&ctx->long_state[e2i(ctx->b) * AES_BLOCK_SIZE]);
 	}
 
 	memcpy(ctx->text, ctx->state.init, INIT_SIZE_BYTE);
@@ -219,9 +239,9 @@ static void cryptonight_hash_ctx(void* output, const void* input, size_t len, st
 	oaes_free((OAES_CTX **) &ctx->aes_ctx);
 }
 
-void cryptonight_hash(void* output, const void* input, size_t len)
+void cryptonight_hash(void* output, const void* input, size_t len, int variant)
 {
 	struct cryptonight_ctx *ctx = (struct cryptonight_ctx*)malloc(sizeof(struct cryptonight_ctx));
-	cryptonight_hash_ctx(output, input, len, ctx);
+	cryptonight_hash_ctx(output, input, len, ctx, variant);
 	free(ctx);
 }
diff --git a/crypto/cryptonight.cu b/crypto/cryptonight.cu
index 0214ce4fc..0682fd9c3 100644
--- a/crypto/cryptonight.cu
+++ b/crypto/cryptonight.cu
@@ -29,6 +29,7 @@ extern "C" int scanhash_cryptonight(int thr_id, struct work* work, uint32_t max_
 	uint32_t *ptarget = work->target;
 	uint8_t *pdata = (uint8_t*) work->data;
 	uint32_t *nonceptr = (uint32_t*) (&pdata[39]);
+	int variant = ((uint8_t*)pdata)[0] >= 7 ? ((uint8_t*)pdata)[0] - 6 : 0;
 	const uint32_t first_nonce = *nonceptr;
 	uint32_t nonce = first_nonce;
 	int dev_id = device_map[thr_id];
@@ -109,7 +110,7 @@ extern "C" int scanhash_cryptonight(int thr_id, struct work* work, uint32_t max_
 
 		cryptonight_extra_cpu_setData(thr_id, pdata, ptarget);
 		cryptonight_extra_cpu_prepare(thr_id, throughput, nonce, d_ctx_state[thr_id], d_ctx_a[thr_id], d_ctx_b[thr_id], d_ctx_key1[thr_id], d_ctx_key2[thr_id]);
-		cryptonight_core_cuda(thr_id, cn_blocks, cn_threads, d_long_state[thr_id], d_ctx_state[thr_id], d_ctx_a[thr_id], d_ctx_b[thr_id], d_ctx_key1[thr_id], d_ctx_key2[thr_id]);
+		cryptonight_core_cpu_hash(thr_id, cn_blocks, cn_threads, d_long_state[thr_id], d_ctx_state[thr_id], d_ctx_a[thr_id], d_ctx_b[thr_id], d_ctx_key1[thr_id], d_ctx_key2[thr_id], variant, nonce);
 		cryptonight_extra_cpu_final(thr_id, throughput, nonce, resNonces, d_ctx_state[thr_id]);
 
 		*hashes_done = nonce - first_nonce + throughput;
@@ -121,7 +122,7 @@ extern "C" int scanhash_cryptonight(int thr_id, struct work* work, uint32_t max_
 			uint32_t *tempnonceptr = (uint32_t*)(((char*)tempdata) + 39);
 			memcpy(tempdata, pdata, 76);
 			*tempnonceptr = resNonces[0];
-			cryptonight_hash(vhash, tempdata, 76);
+			cryptonight_hash(vhash, tempdata, 76, variant);
 			if(vhash[7] <= Htarg && fulltest(vhash, ptarget))
 			{
 				res = 1;
@@ -131,7 +132,7 @@ extern "C" int scanhash_cryptonight(int thr_id, struct work* work, uint32_t max_
 				if(resNonces[1] != UINT32_MAX)
 				{
 					*tempnonceptr = resNonces[1];
-					cryptonight_hash(vhash, tempdata, 76);
+					cryptonight_hash(vhash, tempdata, 76, variant);
 					if(vhash[7] <= Htarg && fulltest(vhash, ptarget)) {
 						res++;
 						work->nonces[1] = resNonces[1];
diff --git a/crypto/cryptonight.h b/crypto/cryptonight.h
index 4a318324e..74b4eaca9 100644
--- a/crypto/cryptonight.h
+++ b/crypto/cryptonight.h
@@ -136,7 +136,7 @@ static inline void exit_if_cudaerror(int thr_id, const char *src, int line)
 		exit(1);
 	}
 }
-void cryptonight_core_cuda(int thr_id, int blocks, int threads, uint64_t *d_long_state, uint64_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2);
+void cryptonight_core_cpu_hash(int thr_id, int blocks, int threads, uint64_t *d_long_state, uint64_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2, int variant, uint8_t nonce_flag);
 
 void cryptonight_extra_cpu_setData(int thr_id, const void *data, const void *pTargetIn);
 void cryptonight_extra_cpu_init(int thr_id, uint32_t threads);
diff --git a/miner.h b/miner.h
index 6d90518c7..a4e5af90a 100644
--- a/miner.h
+++ b/miner.h
@@ -894,7 +894,7 @@ void blake2s_hash(void *output, const void *input);
 void bmw_hash(void *state, const void *input);
 void c11hash(void *output, const void *input);
 void cryptolight_hash(void* output, const void* input, int len);
-void cryptonight_hash(void* output, const void* input, size_t len);
+void cryptonight_hash(void* output, const void* input, size_t len, int variant);
 void decred_hash(void *state, const void *input);
 void deephash(void *state, const void *input);
 void luffa_hash(void *state, const void *input);

From f1d248cdc9ec34a7594561af583bc5c3ea49a334 Mon Sep 17 00:00:00 2001
From: ystarnaud <ystarnaud@gmail.com>
Date: Fri, 6 Apr 2018 12:09:35 -0400
Subject: [PATCH 2/5] vtnerd monero v1 optimizations

---
 crypto/cryptonight-core.cu  |  43 ++++----
 crypto/cryptonight-cpu.cpp  |  35 ++++---
 crypto/cryptonight-extra.cu | 239 ++++++++++++++++++++------------------------
 crypto/cryptonight.cu       |  15 +--
 crypto/cryptonight.h        |   4 +-
 miner.h                     |   2 +-
 6 files changed, 157 insertions(+), 181 deletions(-)

diff --git a/crypto/cryptonight-core.cu b/crypto/cryptonight-core.cu
index bdf70b795..24adf37fd 100644
--- a/crypto/cryptonight-core.cu
+++ b/crypto/cryptonight-core.cu
@@ -16,21 +16,6 @@ extern int device_bsleep[MAX_GPU];
 
 #include "cn_aes.cuh"
 
-#define VARIANT1_1(p) \
-  do if (variant > 0 && sub == 2) \
-  { \
-    uint32_t tmp32 = loadGlobal32<uint32_t>(p); \
-    uint8_t tmp = tmp32 >> 24; \
-    uint8_t tmp1 = (tmp>>4)&1, tmp2 = (tmp>>5)&1, tmp3 = tmp1^tmp2; \
-    uint8_t tmp0 = nonce_flag ? tmp3 : tmp1 + 1; \
-    tmp32 &= 0x00ffffff; tmp32 |= ((tmp & 0xef) | (tmp0<<4)) << 24; \
-    storeGlobal32<uint32_t>(p, tmp32); \
-  } while(0)
-
-#define VARIANT1_2(p) VARIANT1_1(p)
-#define VARIANT1_INIT() \
-  nonce_flag ^= (thread & 1)
-
 __device__ __forceinline__ uint64_t cuda_mul128(uint64_t multiplier, uint64_t multiplicand, uint64_t* product_hi)
 {
 	*product_hi = __umul64hi(multiplier, multiplicand);
@@ -92,6 +77,14 @@ __global__ void cryptonight_core_gpu_phase1(int threads, uint32_t * __restrict__
 	}
 }
 
+__device__ __forceinline__ uint32_t variant1_1(const uint32_t src)
+{
+	const uint8_t tmp = src >> 24;
+	const uint32_t table = 0x75310;
+	const uint8_t index = (((tmp >> 3) & 6) | (tmp & 1)) << 1;
+	return (src & 0x00ffffff) | ((tmp ^ ((table >> index) & 0x30)) << 24);
+}
+
 __device__ __forceinline__ void MUL_SUM_XOR_DST(uint64_t a, uint64_t *__restrict__ c, uint64_t *__restrict__ dst)
 {
 	uint64_t hi = __umul64hi(a, dst[0]) + c[0];
@@ -102,7 +95,7 @@ __device__ __forceinline__ void MUL_SUM_XOR_DST(uint64_t a, uint64_t *__restrict
 	dst[1] = lo;
 }
 
-__global__ void cryptonight_core_gpu_phase2(uint32_t threads, int bfactor, int partidx, uint32_t * __restrict__ d_long_state, uint32_t * __restrict__ d_ctx_a, uint32_t * __restrict__ d_ctx_b, int variant, uint8_t nonce_flag)
+__global__ void cryptonight_core_gpu_phase2(uint32_t threads, int bfactor, int partidx, uint32_t * __restrict__ d_long_state, uint32_t * __restrict__ d_ctx_a, uint32_t * __restrict__ d_ctx_b, int variant, const uint32_t * d_tweak1_2)
 {
 	__shared__ uint32_t sharedMemory[1024];
 
@@ -113,7 +106,12 @@ __global__ void cryptonight_core_gpu_phase2(uint32_t threads, int bfactor, int p
 	if (thread >= threads)
 		return;
 
-	VARIANT1_INIT();
+	uint32_t tweak1_2[2];
+	if (variant > 0)
+	{
+		tweak1_2[0] = d_tweak1_2[thread * 2];
+		tweak1_2[1] = d_tweak1_2[thread * 2 + 1];
+	}
 
 	const int sub = threadIdx.x & 3;
 	const int sub2 = threadIdx.x & 2;
@@ -153,8 +151,8 @@ __global__ void cryptonight_core_gpu_phase2(uint32_t threads, int bfactor, int p
 			//XOR_BLOCKS_DST(c, b, &long_state[j]);
 			t1[0] = __shfl(d[x], 0, 4);
 			//long_state[j] = d[0] ^ d[1];
-			storeGlobal32(long_state + j, d[0] ^ d[1]);
-			VARIANT1_1(long_state + j);
+			const uint32_t z = d[0] ^ d[1];
+			storeGlobal32(long_state + j, (variant > 0 && sub == 2) ? variant1_1(z) : z);
 
 			//MUL_SUM_XOR_DST(c, a, &long_state[((uint32_t *)c)[0] & 0x1FFFF0]);
 			j = ((*t1 & 0x1FFFF0) >> 2) + sub;
@@ -174,8 +172,7 @@ __global__ void cryptonight_core_gpu_phase2(uint32_t threads, int bfactor, int p
 
 			res = *((uint64_t *)t2) >> (sub & 1 ? 32 : 0);
 
-			storeGlobal32(long_state + j, res);
-			VARIANT1_2(long_state + j);
+			storeGlobal32(long_state + j, (variant > 0 && sub2) ? (tweak1_2[sub & 1] ^ res) : res);
 			a = (sub & 1 ? yy[1] : yy[0]) ^ res;
 		}
 	}
@@ -217,7 +214,7 @@ __global__ void cryptonight_core_gpu_phase3(int threads, const uint32_t * __rest
 	}
 }
 
-__host__ void cryptonight_core_cpu_hash(int thr_id, int blocks, int threads, uint32_t *d_long_state, uint32_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2, int variant, uint8_t nonce_flag)
+__host__ void cryptonight_core_cpu_hash(int thr_id, int blocks, int threads, uint32_t *d_long_state, uint32_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2, int variant, uint32_t *d_ctx_tweak1_2)
 {
 	dim3 grid(blocks);
 	dim3 block(threads);
@@ -232,7 +229,7 @@ __host__ void cryptonight_core_cpu_hash(int thr_id, int blocks, int threads, uin
 
 	for(i = 0; i < partcount; i++)
 	{
-		cryptonight_core_gpu_phase2 <<< grid, block4 >>>(blocks*threads, device_bfactor[thr_id], i, d_long_state, d_ctx_a, d_ctx_b, variant, nonce_flag);
+		cryptonight_core_gpu_phase2 <<< grid, block4 >>>(blocks*threads, device_bfactor[thr_id], i, d_long_state, d_ctx_a, d_ctx_b, variant, d_ctx_tweak1_2);
 		exit_if_cudaerror(thr_id, __FILE__, __LINE__);
 		if(partcount > 1) usleep(device_bsleep[thr_id]);
 	}
diff --git a/crypto/cryptonight-cpu.cpp b/crypto/cryptonight-cpu.cpp
index 01fce21fa..4fb31ba6b 100644
--- a/crypto/cryptonight-cpu.cpp
+++ b/crypto/cryptonight-cpu.cpp
@@ -15,16 +15,19 @@ extern "C" {
 #define VARIANT1_1(p) \
   do if (variant > 0) \
   { \
-    uint8_t tmp = ((const uint8_t*)p)[11]; \
-    uint8_t tmp1 = (tmp>>4)&1, tmp2 = (tmp>>5)&1, tmp3 = tmp1^tmp2; \
-    uint8_t tmp0 = nonce_flag ? tmp3 : tmp1 + 1; \
-    ((uint8_t*)p)[11] = (tmp & 0xef) | (tmp0<<4); \
+		const uint8_t tmp = ((const uint8_t*)(p))[11]; \
+    static const uint32_t table = 0x75310; \
+    const uint8_t index = (((tmp >> 3) & 6) | (tmp & 1)) << 1; \
+    ((uint8_t*)(p))[11] = tmp ^ ((table >> index) & 0x30); \
   } while(0)
 
-#define VARIANT1_2(p) VARIANT1_1(p)
 #define VARIANT1_INIT() \
-  const uint8_t nonce_flag = variant > 0 ? ((const uint8_t*)input)[39] & 0x01 : 0
-
+ if (variant > 0 && len < 43) \
+  { \
+    return 0; \
+  } \
+  const uint64_t tweak1_2 = variant > 0 ? *((const uint64_t*) (((const uint8_t*)input) + 35)) ^ ctx->state.hs.w[24] : 0
+ 
 
 struct cryptonight_ctx {
 	uint8_t long_state[MEMORY];
@@ -144,14 +147,14 @@ static void mul_sum_dst(const uint8_t* a, const uint8_t* b, const uint8_t* c, ui
 	((uint64_t*) dst)[0] += ((uint64_t*) c)[0];
 }
 
-static void mul_sum_xor_dst(const uint8_t* a, uint8_t* c, uint8_t* dst) {
+static void mul_sum_xor_dst(const uint8_t* a, uint8_t* c, uint8_t* dst, const int variant, const uint64_t tweak1_2) {
 	uint64_t hi, lo = mul128(((uint64_t*) a)[0], ((uint64_t*) dst)[0], &hi) + ((uint64_t*) c)[1];
 	hi += ((uint64_t*) c)[0];
 
 	((uint64_t*) c)[0] = ((uint64_t*) dst)[0] ^ hi;
 	((uint64_t*) c)[1] = ((uint64_t*) dst)[1] ^ lo;
 	((uint64_t*) dst)[0] = hi;
-	((uint64_t*) dst)[1] = lo;
+	((uint64_t*) dst)[1] = variant > 0 ? lo ^ tweak1_2 : lo;
 }
 
 static void copy_block(uint8_t* dst, const uint8_t* src) {
@@ -169,7 +172,7 @@ static void xor_blocks_dst(const uint8_t* a, const uint8_t* b, uint8_t* dst) {
 	((uint64_t*) dst)[1] = ((uint64_t*) a)[1] ^ ((uint64_t*) b)[1];
 }
 
-static void cryptonight_hash_ctx(void* output, const void* input, size_t len, struct cryptonight_ctx* ctx, int variant)
+static int cryptonight_hash_ctx(void* output, const void* input, size_t len, struct cryptonight_ctx* ctx, int variant)
 {
 	size_t i, j;
 	keccak_hash_process(&ctx->state.hs, (const uint8_t*) input, len);
@@ -202,16 +205,14 @@ static void cryptonight_hash_ctx(void* output, const void* input, size_t len, st
 		xor_blocks_dst(ctx->c, ctx->b, &ctx->long_state[j]);
 		VARIANT1_1(&ctx->long_state[j]);
 
-		mul_sum_xor_dst(ctx->c, ctx->a, &ctx->long_state[e2i(ctx->c) * AES_BLOCK_SIZE]);
-		VARIANT1_2(&ctx->long_state[e2i(ctx->c) * AES_BLOCK_SIZE]);
+		mul_sum_xor_dst(ctx->c, ctx->a, &ctx->long_state[e2i(ctx->c) * AES_BLOCK_SIZE], variant, tweak1_2);
 
 		j = e2i(ctx->a) * AES_BLOCK_SIZE;
 		aesb_single_round(&ctx->long_state[j], ctx->b, ctx->a);
 		xor_blocks_dst(ctx->b, ctx->c, &ctx->long_state[j]);
 		VARIANT1_1(&ctx->long_state[j]);
 
-		mul_sum_xor_dst(ctx->b, ctx->a, &ctx->long_state[e2i(ctx->b) * AES_BLOCK_SIZE]);
-		VARIANT1_2(&ctx->long_state[e2i(ctx->b) * AES_BLOCK_SIZE]);
+		mul_sum_xor_dst(ctx->b, ctx->a, &ctx->long_state[e2i(ctx->b) * AES_BLOCK_SIZE], variant, tweak1_2);
 	}
 
 	memcpy(ctx->text, ctx->state.init, INIT_SIZE_BYTE);
@@ -237,11 +238,13 @@ static void cryptonight_hash_ctx(void* output, const void* input, size_t len, st
 	if (opt_debug) applog(LOG_DEBUG, "extra algo=%d", extra_algo);
 
 	oaes_free((OAES_CTX **) &ctx->aes_ctx);
+	return 1;
 }
 
-void cryptonight_hash(void* output, const void* input, size_t len, int variant)
+int cryptonight_hash(void* output, const void* input, size_t len, int variant)
 {
 	struct cryptonight_ctx *ctx = (struct cryptonight_ctx*)malloc(sizeof(struct cryptonight_ctx));
-	cryptonight_hash_ctx(output, input, len, ctx, variant);
+	int rc = cryptonight_hash_ctx(output, input, len, ctx, variant);
 	free(ctx);
+	return rc;
 }
diff --git a/crypto/cryptonight-extra.cu b/crypto/cryptonight-extra.cu
index 6d3c1312e..1cad0e177 100644
--- a/crypto/cryptonight-extra.cu
+++ b/crypto/cryptonight-extra.cu
@@ -22,7 +22,8 @@ static uint32_t *d_result[MAX_GPUS];
 #include "cn_jh.cuh"
 #include "cn_skein.cuh"
 
-__constant__ uint8_t d_sub_byte[16][16] = {
+__constant__ uint8_t d_sub_byte[16][16] =
+{
 	{0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76},
 	{0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0},
 	{0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15},
@@ -41,64 +42,74 @@ __constant__ uint8_t d_sub_byte[16][16] = {
 	{0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16}
 };
 
-__device__ __forceinline__
-void cryptonight_aes_set_key(uint32_t * __restrict__ key, const uint32_t * __restrict__ data)
+__device__ __forceinline__ void cryptonight_aes_set_key(uint32_t * __restrict__ key, const uint32_t * __restrict__ data)
 {
-	const uint32_t aes_gf[] = {
+	int i, j;
+	uint8_t temp[4];
+	const uint32_t aes_gf[10] =
+	{
 		0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36
 	};
 
-	MEMSET4(key, 0, 40);
 	MEMCPY4(key, data, 8);
-
-	#pragma unroll
-	for(int i = 8; i < 40; i++)
+#pragma unroll
+	for(i = 8; i < 40; i++)
 	{
-		uint8_t temp[4];
 		*(uint32_t *)temp = key[i - 1];
-
-		if(i % 8 == 0) {
+		if(i % 8 == 0)
+		{
 			*(uint32_t *)temp = ROTR32(*(uint32_t *)temp, 8);
-			for(int j = 0; j < 4; j++)
+			for(j = 0; j < 4; j++)
 				temp[j] = d_sub_byte[(temp[j] >> 4) & 0x0f][temp[j] & 0x0f];
 			*(uint32_t *)temp ^= aes_gf[i / 8 - 1];
 		}
-		else if(i % 8 == 4) {
-			#pragma unroll
-			for(int j = 0; j < 4; j++)
-				temp[j] = d_sub_byte[(temp[j] >> 4) & 0x0f][temp[j] & 0x0f];
-		}
-
+		else
+			if(i % 8 == 4)
+#pragma unroll
+				for(j = 0; j < 4; j++)
+					temp[j] = d_sub_byte[(temp[j] >> 4) & 0x0f][temp[j] & 0x0f];
 		key[i] = key[(i - 8)] ^ *(uint32_t *)temp;
 	}
 }
 
-__global__
-void cryptonight_extra_gpu_prepare(const uint32_t threads, uint32_t * __restrict__ d_input, uint32_t startNonce,
-	uint64_t * d_ctx_state, uint32_t * __restrict__ d_ctx_a, uint32_t * __restrict__ d_ctx_b,
-	uint32_t * __restrict__ d_ctx_key1, uint32_t * __restrict__ d_ctx_key2)
+__global__ void cryptonight_extra_gpu_prepare(int threads, const uint32_t * __restrict__ d_input, uint32_t startNonce, uint32_t * __restrict__ d_ctx_state, uint32_t * __restrict__ d_ctx_a, uint32_t * __restrict__ d_ctx_b, uint32_t * __restrict__ d_ctx_key1, uint32_t * __restrict__ d_ctx_key2, int variant, uint32_t * d_ctx_tweak1_2)
 {
-	const uint32_t thread = (blockDim.x * blockIdx.x + threadIdx.x);
+	int thread = (blockDim.x * blockIdx.x + threadIdx.x);
 
 	if(thread < threads)
 	{
-		uint32_t ctx_state[50];
+		uint64_t ctx_state[25];
 		uint32_t ctx_a[4];
 		uint32_t ctx_b[4];
-		uint32_t ctx_key1[40];
-		uint32_t ctx_key2[40];
+		uint32_t ctx_key1[40] = {0};
+		uint32_t ctx_key2[40] = {0};
 		uint32_t input[19];
+		uint32_t tweak1_2[2];
 
 		MEMCPY4(input, d_input, 19);
-		*((uint32_t *)(((char *)input) + 39)) = startNonce + thread;
 
-		cn_keccak((uint8_t *)input, (uint8_t *)ctx_state);
-		cryptonight_aes_set_key(ctx_key1, ctx_state);
-		cryptonight_aes_set_key(ctx_key2, ctx_state + 8);
-		XOR_BLOCKS_DST(ctx_state, ctx_state + 8, ctx_a);
-		XOR_BLOCKS_DST(ctx_state + 4, ctx_state + 12, ctx_b);
+		uint32_t nonce = startNonce + thread;
+		*(((uint8_t *)input) + 39) = nonce & 0xff;
+		*(((uint8_t *)input) + 40) = (nonce >> 8) & 0xff;
+		*(((uint8_t *)input) + 41) = (nonce >> 16) & 0xff;
+		*(((uint8_t *)input) + 42) = (nonce >> 24) & 0xff;
 
-		MEMCPY8(&d_ctx_state[thread * 26], ctx_state, 25);
+		cn_keccak(input, ctx_state);
+		cryptonight_aes_set_key(ctx_key1, (uint32_t*)ctx_state);
+		cryptonight_aes_set_key(ctx_key2, (uint32_t*)(ctx_state + 4));
+		XOR_BLOCKS_DST(ctx_state, ctx_state + 4, ctx_a);
+		XOR_BLOCKS_DST(ctx_state + 2, ctx_state + 6, ctx_b);
+
+		if (variant > 0)
+		{
+			tweak1_2[0] = (input[8] >> 24) | (input[9] << 8);
+			tweak1_2[0] ^= (ctx_state[24] & 0xffffffff);
+			tweak1_2[1] = (input[9] >> 24) | (input[10] << 8);
+			tweak1_2[1] ^= (ctx_state[24] >> 32);
+			MEMCPY4(d_ctx_tweak1_2 + thread * 2, tweak1_2, 2);
+		}
+
+		MEMCPY4(d_ctx_state + thread * 50, ctx_state, 50);
 		MEMCPY4(d_ctx_a + thread * 4, ctx_a, 4);
 		MEMCPY4(d_ctx_b + thread * 4, ctx_b, 4);
 		MEMCPY4(d_ctx_key1 + thread * 40, ctx_key1, 40);
@@ -106,142 +117,104 @@ void cryptonight_extra_gpu_prepare(const uint32_t threads, uint32_t * __restrict
 	}
 }
 
-__global__
-void cryptonight_extra_gpu_keccak(uint32_t threads, uint32_t * d_ctx_state)
+__global__ void cryptonight_extra_gpu_final(int threads, uint32_t startNonce, const uint32_t * __restrict__ d_target, uint32_t * __restrict__ resNonce, uint32_t * __restrict__ d_ctx_state)
 {
-	const uint32_t thread = (blockDim.x * blockIdx.x + threadIdx.x);
+	const int thread = blockDim.x * blockIdx.x + threadIdx.x;
+	
 	if(thread < threads)
 	{
-		uint64_t* ctx_state = (uint64_t*) (&d_ctx_state[thread * 52U]);
-		uint64_t state[25];
-		#pragma unroll
-		for(int i = 0; i < 25; i++)
+		int i;
+		const uint32_t nonce = startNonce + thread;
+		const uint32_t * __restrict__ ctx_state = d_ctx_state + thread * 50;
+		uint32_t hash[8];
+		uint32_t state[50];
+
+#pragma unroll
+		for(i = 0; i < 50; i++)
 			state[i] = ctx_state[i];
 
-		cn_keccakf2(state);
+		cn_keccakf2((uint64_t *)state);
 
-		// to reduce the final kernel stack frame, cut algos in 2 kernels
-		// ps: these 2 final kernels are not important for the overall xmr hashrate (< 1%)
-		switch (((uint8_t*)state)[0] & 0x03)
-		{
-			case 0: {
-				uint32_t hash[8];
-				cn_blake((uint8_t*)state, 200, (uint8_t*)hash);
-				((uint32_t*)ctx_state)[0] = 0;
-				((uint32_t*)ctx_state)[6] = hash[6];
-				((uint32_t*)ctx_state)[7] = hash[7];
-				break;
-			}
-			case 1: {
-				uint32_t hash[8];
-				cn_groestl((BitSequence*)state, 200, (BitSequence*)hash);
-				((uint32_t*)ctx_state)[0] = 0;
-				((uint32_t*)ctx_state)[6] = hash[6];
-				((uint32_t*)ctx_state)[7] = hash[7];
-				break;
-			}
-			default: {
-				#pragma unroll
-				for(int i = 0; i < 25; i++)
-					ctx_state[i] = state[i];
-			}
-		}
-	}
-}
+		int branch = ((uint8_t *)state)[0] & 0x03;
+		if(branch == 0)
+			cn_blake((const uint8_t *)state, 200, (uint8_t *)hash);
+		if(branch == 1)
+			cn_groestl((const BitSequence *)state, 200, (BitSequence *)hash);
+		if(branch == 2)
+			cn_jh((const BitSequence *)state, 200, (BitSequence *)hash);
+		if(branch == 3)
+			cn_skein((const BitSequence *)state, 200, (BitSequence *)hash);
 
-__global__
-void cryptonight_extra_gpu_final(uint32_t threads, const uint32_t startNonce, uint64_t * __restrict__ d_ctx_state,
-	const uint32_t* d_target, uint32_t * resNonces)
-{
-	const uint32_t thread = (blockDim.x * blockIdx.x + threadIdx.x);
-	if(thread < threads)
-	{
-		uint64_t* const state = &d_ctx_state[thread * 26U];
+		int position = -1;
+		bool rc = true;
 
-		uint32_t hash[8];
-		switch(((uint8_t *)state)[0] & 0x03)
+#pragma unroll 8
+		for(i = 7; i >= 0; i--)
 		{
-			case 0: {
-				uint32_t* h32 = (uint32_t*)state;
-				hash[6] = h32[6];
-				hash[7] = h32[7];
-				break;
+			if(hash[i] > d_target[i])
+			{
+				if(position < i)
+				{
+					position = i;
+					rc = false;
+				}
 			}
-			case 2: {
-				cn_jh256((uint8_t*)state, 200, hash);
-				break;
-			}
-			case 3: {
-				cn_skein((uint8_t*)state, 200, hash);
-				break;
+			if(hash[i] < d_target[i])
+			{
+				if(position < i)
+				{
+					position = i;
+					rc = true;
+				}
 			}
 		}
 
-		if(hash[7] <= d_target[1] && hash[6] <= d_target[0])
+		if(rc == true)
 		{
-			const uint32_t nonce = startNonce + thread;
-			uint32_t tmp = atomicExch(resNonces, nonce);
-			if(tmp != UINT32_MAX)
-				resNonces[1] = tmp;
+			uint32_t tmp = atomicExch(resNonce, nonce);
+			if(tmp != 0xffffffff)
+				resNonce[1] = tmp;
 		}
 	}
 }
 
-__host__
-void cryptonight_extra_cpu_setData(int thr_id, const void *data, const void *ptarget)
+__host__ void cryptonight_extra_cpu_setData(int thr_id, const void *data, const void *pTargetIn)
 {
-	uint32_t *pTargetIn = (uint32_t*) ptarget;
 	cudaMemcpy(d_input[thr_id], data, 19 * sizeof(uint32_t), cudaMemcpyHostToDevice);
-	cudaMemcpy(d_target[thr_id], &pTargetIn[6], 2*sizeof(uint32_t), cudaMemcpyHostToDevice);
-	exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
+	cudaMemcpy(d_target[thr_id], pTargetIn, 8 * sizeof(uint32_t), cudaMemcpyHostToDevice);
+	cudaMemset(d_resultNonce[thr_id], 0xFF, 2 * sizeof(uint32_t));
+	exit_if_cudaerror(thr_id, __FILE__, __LINE__);
 }
 
-__host__
-void cryptonight_extra_cpu_init(int thr_id, uint32_t threads)
+__host__ void cryptonight_extra_cpu_init(int thr_id)
 {
 	cudaMalloc(&d_input[thr_id], 19 * sizeof(uint32_t));
-	cudaMalloc(&d_target[thr_id], 2*sizeof(uint32_t));
-	cudaMalloc(&d_result[thr_id], 2*sizeof(uint32_t));
-	exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
+	cudaMalloc(&d_target[thr_id], 8 * sizeof(uint32_t));
+	cudaMalloc(&d_resultNonce[thr_id], 2*sizeof(uint32_t));
+	exit_if_cudaerror(thr_id, __FILE__, __LINE__);
 }
 
-__host__
-void cryptonight_extra_cpu_prepare(int thr_id, uint32_t threads, uint32_t startNonce, uint64_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2)
+__host__ void cryptonight_extra_cpu_prepare(int thr_id, int threads, uint32_t startNonce, uint32_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2, int variant, uint32_t *d_ctx_tweak1_2)
 {
-	uint32_t threadsperblock = 128;
+	int threadsperblock = 128;
 
 	dim3 grid((threads + threadsperblock - 1) / threadsperblock);
 	dim3 block(threadsperblock);
 
-	cryptonight_extra_gpu_prepare <<<grid, block >>> (threads, d_input[thr_id], startNonce, d_ctx_state, d_ctx_a, d_ctx_b, d_ctx_key1, d_ctx_key2);
-	exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
+	cryptonight_extra_gpu_prepare << <grid, block >> >(threads, d_input[thr_id], startNonce, d_ctx_state, d_ctx_a, d_ctx_b, d_ctx_key1, d_ctx_key2, variant, d_ctx_tweak1_2);
+	exit_if_cudaerror(thr_id, __FILE__, __LINE__);
 }
 
-__host__
-void cryptonight_extra_cpu_final(int thr_id, uint32_t threads, uint32_t startNonce, uint32_t *resnonce, uint64_t *d_ctx_state)
+__host__ void cryptonight_extra_cpu_final(int thr_id, int threads, uint32_t startNonce, uint32_t *resnonce, uint32_t *d_ctx_state)
 {
-	uint32_t threadsperblock = 128;
+	int threadsperblock = 128;
 
 	dim3 grid((threads + threadsperblock - 1) / threadsperblock);
 	dim3 block(threadsperblock);
 
-	cudaMemset(d_result[thr_id], 0xFF, 2*sizeof(uint32_t));
-	exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
-	cryptonight_extra_gpu_keccak <<<grid, block >>> (threads, (uint32_t*)d_ctx_state);
-	exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
-	cryptonight_extra_gpu_final <<<grid, block >>> (threads, startNonce, d_ctx_state, d_target[thr_id], d_result[thr_id]);
-	exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
-	cudaMemcpy(resnonce, d_result[thr_id], 2 * sizeof(uint32_t), cudaMemcpyDeviceToHost);
-	exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
-}
-
-__host__
-void cryptonight_extra_cpu_free(int thr_id)
-{
-	if (d_input[thr_id]) {
-		cudaFree(d_input[thr_id]);
-		cudaFree(d_target[thr_id]);
-		cudaFree(d_result[thr_id]);
-		d_input[thr_id] = NULL;
-	}
+	exit_if_cudaerror(thr_id, __FILE__, __LINE__);
+	cryptonight_extra_gpu_final << <grid, block >> >(threads, startNonce, d_target[thr_id], d_resultNonce[thr_id], d_ctx_state);
+	exit_if_cudaerror(thr_id, __FILE__, __LINE__);
+	cudaMemcpy(resnonce, d_resultNonce[thr_id], 2 * sizeof(uint32_t), cudaMemcpyDeviceToHost);
+	exit_if_cudaerror(thr_id, __FILE__, __LINE__);
 }
\ No newline at end of file
diff --git a/crypto/cryptonight.cu b/crypto/cryptonight.cu
index 0682fd9c3..90a5ac300 100644
--- a/crypto/cryptonight.cu
+++ b/crypto/cryptonight.cu
@@ -16,6 +16,7 @@ static uint64_t *d_ctx_state[MAX_GPUS];
 static uint32_t *d_ctx_key1[MAX_GPUS];
 static uint32_t *d_ctx_key2[MAX_GPUS];
 static uint32_t *d_ctx_text[MAX_GPUS];
+static uint32_t *d_ctx_tweak1_2[MAX_GPUS];
 static uint32_t *d_ctx_a[MAX_GPUS];
 static uint32_t *d_ctx_b[MAX_GPUS];
 
@@ -96,6 +97,8 @@ extern "C" int scanhash_cryptonight(int thr_id, struct work* work, uint32_t max_
 		exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
 		cudaMalloc(&d_ctx_b[thr_id], 4 * sizeof(uint32_t) * throughput);
 		exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
+		cudaMalloc(&d_ctx_tweak1_2[thr_id], 2 * sizeof(uint32_t) * throughput);
+		exit_if_cudaerror(thr_id, __FILE__, __LINE__);
 
 		gpu_init_shown = true;
 		init[thr_id] = true;
@@ -109,8 +112,8 @@ extern "C" int scanhash_cryptonight(int thr_id, struct work* work, uint32_t max_
 		uint32_t resNonces[2] = { UINT32_MAX, UINT32_MAX };
 
 		cryptonight_extra_cpu_setData(thr_id, pdata, ptarget);
-		cryptonight_extra_cpu_prepare(thr_id, throughput, nonce, d_ctx_state[thr_id], d_ctx_a[thr_id], d_ctx_b[thr_id], d_ctx_key1[thr_id], d_ctx_key2[thr_id]);
-		cryptonight_core_cpu_hash(thr_id, cn_blocks, cn_threads, d_long_state[thr_id], d_ctx_state[thr_id], d_ctx_a[thr_id], d_ctx_b[thr_id], d_ctx_key1[thr_id], d_ctx_key2[thr_id], variant, nonce);
+		cryptonight_extra_cpu_prepare(thr_id, throughput, nonce, d_ctx_state[thr_id], d_ctx_a[thr_id], d_ctx_b[thr_id], d_ctx_key1[thr_id], d_ctx_key2[thr_id], variant, d_ctx_tweak1_2[thr_id]);
+		cryptonight_core_cpu_hash(thr_id, cn_blocks, cn_threads, d_long_state[thr_id], d_ctx_state[thr_id], d_ctx_a[thr_id], d_ctx_b[thr_id], d_ctx_key1[thr_id], d_ctx_key2[thr_id], variant, d_ctx_tweak1_2[thr_id]);
 		cryptonight_extra_cpu_final(thr_id, throughput, nonce, resNonces, d_ctx_state[thr_id]);
 
 		*hashes_done = nonce - first_nonce + throughput;
@@ -122,8 +125,8 @@ extern "C" int scanhash_cryptonight(int thr_id, struct work* work, uint32_t max_
 			uint32_t *tempnonceptr = (uint32_t*)(((char*)tempdata) + 39);
 			memcpy(tempdata, pdata, 76);
 			*tempnonceptr = resNonces[0];
-			cryptonight_hash(vhash, tempdata, 76, variant);
-			if(vhash[7] <= Htarg && fulltest(vhash, ptarget))
+			const int rc = cryptonight_hash(vhash, tempdata, 76, variant);
+			if(rc && (vhash[7] <= Htarg) && fulltest(vhash, ptarget))
 			{
 				res = 1;
 				work->nonces[0] = resNonces[0];
@@ -132,8 +135,8 @@ extern "C" int scanhash_cryptonight(int thr_id, struct work* work, uint32_t max_
 				if(resNonces[1] != UINT32_MAX)
 				{
 					*tempnonceptr = resNonces[1];
-					cryptonight_hash(vhash, tempdata, 76, variant);
-					if(vhash[7] <= Htarg && fulltest(vhash, ptarget)) {
+					const int rc = cryptonight_hash(vhash, tempdata, 76, variant);
+					if(rc && (vhash[7] <= Htarg) && fulltest(vhash, ptarget)) {
 						res++;
 						work->nonces[1] = resNonces[1];
 					} else {
diff --git a/crypto/cryptonight.h b/crypto/cryptonight.h
index 74b4eaca9..39c2a61cc 100644
--- a/crypto/cryptonight.h
+++ b/crypto/cryptonight.h
@@ -136,10 +136,10 @@ static inline void exit_if_cudaerror(int thr_id, const char *src, int line)
 		exit(1);
 	}
 }
-void cryptonight_core_cpu_hash(int thr_id, int blocks, int threads, uint64_t *d_long_state, uint64_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2, int variant, uint8_t nonce_flag);
+void cryptonight_core_cpu_hash(int thr_id, int blocks, int threads, uint64_t *d_long_state, uint64_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2, int variant, uint32_t *d_ctx_tweak1_2);
 
 void cryptonight_extra_cpu_setData(int thr_id, const void *data, const void *pTargetIn);
 void cryptonight_extra_cpu_init(int thr_id, uint32_t threads);
 void cryptonight_extra_cpu_free(int thr_id);
-void cryptonight_extra_cpu_prepare(int thr_id, uint32_t threads, uint32_t startNonce, uint64_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2);
+void cryptonight_extra_cpu_prepare(int thr_id, uint32_t threads, uint32_t startNonce, uint64_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2, int variant, uint32_t *d_ctx_tweak1_2);
 void cryptonight_extra_cpu_final(int thr_id, uint32_t threads, uint32_t startNonce, uint32_t *nonce, uint64_t *d_ctx_state);
diff --git a/miner.h b/miner.h
index a4e5af90a..246e5b94d 100644
--- a/miner.h
+++ b/miner.h
@@ -894,7 +894,7 @@ void blake2s_hash(void *output, const void *input);
 void bmw_hash(void *state, const void *input);
 void c11hash(void *output, const void *input);
 void cryptolight_hash(void* output, const void* input, int len);
-void cryptonight_hash(void* output, const void* input, size_t len, int variant);
+int cryptonight_hash(void* output, const void* input, size_t len, int variant);
 void decred_hash(void *state, const void *input);
 void deephash(void *state, const void *input);
 void luffa_hash(void *state, const void *input);

From 9390e4567e65254ee0d01f2e4d13191a4bec92a3 Mon Sep 17 00:00:00 2001
From: ystarnaud <ystarnaud@gmail.com>
Date: Fri, 6 Apr 2018 12:56:15 -0400
Subject: [PATCH 3/5] Add options for new cryptonight forks

---
 algos.h               | 31 +++++++++++++++++++++++++++++++
 ccminer.cpp           | 46 +++++++++++++++++++++++++++++++++++++++++++---
 crypto/cryptonight.cu |  3 +--
 3 files changed, 75 insertions(+), 5 deletions(-)

diff --git a/algos.h b/algos.h
index ed0ff8302..e6681e86a 100644
--- a/algos.h
+++ b/algos.h
@@ -70,6 +70,9 @@ enum sha_algos {
 	ALGO_WHIRLPOOLX,
 	ALGO_WILDKECCAK,
 	ALGO_ZR5,
+	ALGO_MONERO,
+	ALGO_GRAFT,
+	ALGO_STELLITE,
 	ALGO_AUTO,
 	ALGO_COUNT
 };
@@ -142,6 +145,9 @@ static const char *algo_names[] = {
 	"whirlpoolx",
 	"wildkeccak",
 	"zr5",
+	"monero",
+	"graft",
+	"stellite",
 	"auto", /* reserved for multi algo */
 	""
 };
@@ -202,4 +208,29 @@ static inline int algo_to_int(char* arg)
 	return i;
 }
 
+static inline int get_cryptonight_algo(int fork)
+{
+	int algo = ALGO_COUNT;
+
+	switch (fork) {
+		case 8:
+			algo = ALGO_GRAFT;
+			break;
+
+		case 7:
+			algo = ALGO_MONERO;
+			break;
+
+		case 3:
+			algo = ALGO_STELLITE;
+			break;
+
+		default:
+			algo = ALGO_CRYPTONIGHT;
+			break;
+	}
+
+	return algo;
+}
+
 #endif
diff --git a/ccminer.cpp b/ccminer.cpp
index 87cd26ce4..e0e1a39a8 100644
--- a/ccminer.cpp
+++ b/ccminer.cpp
@@ -232,6 +232,8 @@ int opt_api_mcast_port = 4068;
 
 bool opt_stratum_stats = false;
 
+int cryptonight_fork = 1;
+
 static char const usage[] = "\
 Usage: " PROGRAM_NAME " [OPTIONS]\n\
 Options:\n\
@@ -243,7 +245,7 @@ Options:\n\
 			blakecoin   Fast Blake 256 (8 rounds)\n\
 			bmw         BMW 256\n\
 			cryptolight AEON cryptonight (MEM/2)\n\
-			cryptonight XMR cryptonight\n\
+			cryptonight XMR cryptonight v1 (old)\n\
 			c11/flax    X11 variant\n\
 			decred      Decred Blake256\n\
 			deep        Deepcoin\n\
@@ -251,6 +253,7 @@ Options:\n\
 			dmd-gr      Diamond-Groestl\n\
 			fresh       Freshcoin (shavite 80)\n\
 			fugue256    Fuguecoin\n\
+			graft       Cryptonight v8\n\
 			groestl     Groestlcoin\n"
 #ifdef WITH_HEAVY_ALGO
 "			heavy       Heavycoin\n"
@@ -265,6 +268,7 @@ Options:\n\
 			lyra2v2     VertCoin\n\
 			lyra2z      ZeroCoin (3rd impl)\n\
 			myr-gr      Myriad-Groestl\n\
+			monero      XMR cryptonight v7 (new)\n\
 			neoscrypt   FeatherCoin, Phoenix, UFO...\n\
 			nist5       NIST5 (TalkCoin)\n\
 			penta       Pentablake hash (5x Blake 512)\n\
@@ -281,6 +285,7 @@ Options:\n\
 			skein       Skein SHA2 (Skeincoin)\n\
 			skein2      Double Skein (Woodcoin)\n\
 			skunk       Skein Cube Fugue Streebog\n\
+			stellite    Cryptonight v3\n\
 			s3          S3 (1Coin)\n\
 			timetravel  Machinecoin permuted x8\n\
 			tribus      Denarius\n\
@@ -570,7 +575,13 @@ static bool get_blocktemplate(CURL *curl, struct work *work);
 
 void get_currentalgo(char* buf, int sz)
 {
-	snprintf(buf, sz, "%s", algo_names[opt_algo]);
+  int algo = opt_algo;
+
+  if (algo == ALGO_CRYPTONIGHT) {
+    algo = get_cryptonight_algo(cryptonight_fork);
+  }
+
+  snprintf(buf, sz, "%s", algo_names[algo]);
 }
 
 void format_hashrate(double hashrate, char *output)
@@ -2345,7 +2356,13 @@ static void *miner_thread(void *userdata)
 			rc = scanhash_cryptolight(thr_id, &work, max_nonce, &hashes_done);
 			break;
 		case ALGO_CRYPTONIGHT:
-			rc = scanhash_cryptonight(thr_id, &work, max_nonce, &hashes_done);
+      int variant = 0;
+
+      if (cryptonight_fork > 1) {
+        variant = ((((unsigned char*)work->data)[0] >= cryptonight_fork) ? ((unsigned char*)work->data)[0] - cryptonight_fork + 1 : 0 );
+      }
+
+			rc = scanhash_cryptonight(thr_id, &work, max_nonce, &hashes_done, variant);
 			break;
 		case ALGO_DECRED:
 			rc = scanhash_decred(thr_id, &work, max_nonce, &hashes_done);
@@ -3105,6 +3122,29 @@ void parse_arg(int key, char *arg)
 			case ALGO_SCRYPT_JANE: opt_nfactor = 14; break;
 			}
 		}
+
+    //fix cryptonight
+    switch (opt_algo) {
+      case ALGO_MONERO:
+        opt_algo = ALGO_CRYPTONIGHT;
+        cryptonight_fork = 7;
+        break;
+
+      case ALGO_GRAFT:
+        opt_algo = ALGO_CRYPTONIGHT;
+        cryptonight_fork = 8;
+        break;
+
+      case ALGO_STELLITE:
+        opt_algo = ALGO_CRYPTONIGHT;
+        cryptonight_fork = 3;
+        break;
+
+      case ALGO_CRYPTONIGHT:
+        cryptonight_fork = 1;
+        break;
+    }
+
 		break;
 	case 'b':
 		p = strstr(arg, ":");
diff --git a/crypto/cryptonight.cu b/crypto/cryptonight.cu
index 90a5ac300..6b3b92358 100644
--- a/crypto/cryptonight.cu
+++ b/crypto/cryptonight.cu
@@ -22,7 +22,7 @@ static uint32_t *d_ctx_b[MAX_GPUS];
 
 static bool init[MAX_GPUS] = { 0 };
 
-extern "C" int scanhash_cryptonight(int thr_id, struct work* work, uint32_t max_nonce, unsigned long *hashes_done)
+extern "C" int scanhash_cryptonight(int thr_id, struct work* work, uint32_t max_nonce, unsigned long *hashes_done, int variant)
 {
 	int res = 0;
 	uint32_t throughput = 0;
@@ -30,7 +30,6 @@ extern "C" int scanhash_cryptonight(int thr_id, struct work* work, uint32_t max_
 	uint32_t *ptarget = work->target;
 	uint8_t *pdata = (uint8_t*) work->data;
 	uint32_t *nonceptr = (uint32_t*) (&pdata[39]);
-	int variant = ((uint8_t*)pdata)[0] >= 7 ? ((uint8_t*)pdata)[0] - 6 : 0;
 	const uint32_t first_nonce = *nonceptr;
 	uint32_t nonce = first_nonce;
 	int dev_id = device_map[thr_id];

From 561b02108aba6e9d019e6daa94bd420637c2928d Mon Sep 17 00:00:00 2001
From: ystarnaud <ystarnaud@gmail.com>
Date: Fri, 6 Apr 2018 14:31:11 -0400
Subject: [PATCH 4/5] Cryptonight fixes

---
 ccminer.cpp                 |   5 +-
 crypto/cl_aes.cuh           | 989 ++++++++++++++++++++++++++++++++++++++++++++
 crypto/cn_blake.cuh         | 269 ++++++------
 crypto/cn_groestl.cuh       | 582 +++++++++++++-------------
 crypto/cn_jh.cuh            | 388 +++++++++--------
 crypto/cn_keccak.cuh        |  14 +-
 crypto/cn_skein.cuh         | 426 ++++++++++---------
 crypto/cryptolight-core.cu  |   8 +-
 crypto/cryptolight.cu       |   8 +-
 crypto/cryptolight.h        |   9 +-
 crypto/cryptonight-core.cu  |   6 +-
 crypto/cryptonight-extra.cu |   8 +-
 crypto/cryptonight.cu       |   8 +-
 crypto/cryptonight.h        |   8 +-
 crypto/xmr-rpc.cpp          |   8 +-
 miner.h                     |   4 +-
 util.cpp                    |   2 +-
 17 files changed, 1864 insertions(+), 878 deletions(-)
 create mode 100644 crypto/cl_aes.cuh

diff --git a/ccminer.cpp b/ccminer.cpp
index e0e1a39a8..33f2915b7 100644
--- a/ccminer.cpp
+++ b/ccminer.cpp
@@ -1824,6 +1824,7 @@ static void *miner_thread(void *userdata)
 	bool extrajob = false;
 	char s[16];
 	int rc = 0;
+  int variant;
 
 	memset(&work, 0, sizeof(work)); // prevent work from being used uninitialized
 
@@ -2356,10 +2357,10 @@ static void *miner_thread(void *userdata)
 			rc = scanhash_cryptolight(thr_id, &work, max_nonce, &hashes_done);
 			break;
 		case ALGO_CRYPTONIGHT:
-      int variant = 0;
+      variant = 0;
 
       if (cryptonight_fork > 1) {
-        variant = ((((unsigned char*)work->data)[0] >= cryptonight_fork) ? ((unsigned char*)work->data)[0] - cryptonight_fork + 1 : 0 );
+        variant = ((((unsigned char*)work.data)[0] >= cryptonight_fork) ? ((unsigned char*)work.data)[0] - cryptonight_fork + 1 : 0 );
       }
 
 			rc = scanhash_cryptonight(thr_id, &work, max_nonce, &hashes_done, variant);
diff --git a/crypto/cl_aes.cuh b/crypto/cl_aes.cuh
new file mode 100644
index 000000000..5fc5b6aac
--- /dev/null
+++ b/crypto/cl_aes.cuh
@@ -0,0 +1,989 @@
+
+#define N_COLS          4
+#define WPOLY           0x011b
+/*
+static const __device__ __align__(16) uint32_t d_t_fn[1024] = {
+  0xa56363c6U, 0x847c7cf8U, 0x997777eeU, 0x8d7b7bf6U, 0x0df2f2ffU, 0xbd6b6bd6U, 0xb16f6fdeU, 0x54c5c591U,
+  0x50303060U, 0x03010102U, 0xa96767ceU, 0x7d2b2b56U, 0x19fefee7U, 0x62d7d7b5U, 0xe6abab4dU, 0x9a7676ecU,
+  0x45caca8fU, 0x9d82821fU, 0x40c9c989U, 0x877d7dfaU, 0x15fafaefU, 0xeb5959b2U, 0xc947478eU, 0x0bf0f0fbU,
+  0xecadad41U, 0x67d4d4b3U, 0xfda2a25fU, 0xeaafaf45U, 0xbf9c9c23U, 0xf7a4a453U, 0x967272e4U, 0x5bc0c09bU,
+  0xc2b7b775U, 0x1cfdfde1U, 0xae93933dU, 0x6a26264cU, 0x5a36366cU, 0x413f3f7eU, 0x02f7f7f5U, 0x4fcccc83U,
+  0x5c343468U, 0xf4a5a551U, 0x34e5e5d1U, 0x08f1f1f9U, 0x937171e2U, 0x73d8d8abU, 0x53313162U, 0x3f15152aU,
+  0x0c040408U, 0x52c7c795U, 0x65232346U, 0x5ec3c39dU, 0x28181830U, 0xa1969637U, 0x0f05050aU, 0xb59a9a2fU,
+  0x0907070eU, 0x36121224U, 0x9b80801bU, 0x3de2e2dfU, 0x26ebebcdU, 0x6927274eU, 0xcdb2b27fU, 0x9f7575eaU,
+  0x1b090912U, 0x9e83831dU, 0x742c2c58U, 0x2e1a1a34U, 0x2d1b1b36U, 0xb26e6edcU, 0xee5a5ab4U, 0xfba0a05bU,
+  0xf65252a4U, 0x4d3b3b76U, 0x61d6d6b7U, 0xceb3b37dU, 0x7b292952U, 0x3ee3e3ddU, 0x712f2f5eU, 0x97848413U,
+  0xf55353a6U, 0x68d1d1b9U, 0x00000000U, 0x2cededc1U, 0x60202040U, 0x1ffcfce3U, 0xc8b1b179U, 0xed5b5bb6U,
+  0xbe6a6ad4U, 0x46cbcb8dU, 0xd9bebe67U, 0x4b393972U, 0xde4a4a94U, 0xd44c4c98U, 0xe85858b0U, 0x4acfcf85U,
+  0x6bd0d0bbU, 0x2aefefc5U, 0xe5aaaa4fU, 0x16fbfbedU, 0xc5434386U, 0xd74d4d9aU, 0x55333366U, 0x94858511U,
+  0xcf45458aU, 0x10f9f9e9U, 0x06020204U, 0x817f7ffeU, 0xf05050a0U, 0x443c3c78U, 0xba9f9f25U, 0xe3a8a84bU,
+  0xf35151a2U, 0xfea3a35dU, 0xc0404080U, 0x8a8f8f05U, 0xad92923fU, 0xbc9d9d21U, 0x48383870U, 0x04f5f5f1U,
+  0xdfbcbc63U, 0xc1b6b677U, 0x75dadaafU, 0x63212142U, 0x30101020U, 0x1affffe5U, 0x0ef3f3fdU, 0x6dd2d2bfU,
+  0x4ccdcd81U, 0x140c0c18U, 0x35131326U, 0x2fececc3U, 0xe15f5fbeU, 0xa2979735U, 0xcc444488U, 0x3917172eU,
+  0x57c4c493U, 0xf2a7a755U, 0x827e7efcU, 0x473d3d7aU, 0xac6464c8U, 0xe75d5dbaU, 0x2b191932U, 0x957373e6U,
+  0xa06060c0U, 0x98818119U, 0xd14f4f9eU, 0x7fdcdca3U, 0x66222244U, 0x7e2a2a54U, 0xab90903bU, 0x8388880bU,
+  0xca46468cU, 0x29eeeec7U, 0xd3b8b86bU, 0x3c141428U, 0x79dedea7U, 0xe25e5ebcU, 0x1d0b0b16U, 0x76dbdbadU,
+  0x3be0e0dbU, 0x56323264U, 0x4e3a3a74U, 0x1e0a0a14U, 0xdb494992U, 0x0a06060cU, 0x6c242448U, 0xe45c5cb8U,
+  0x5dc2c29fU, 0x6ed3d3bdU, 0xefacac43U, 0xa66262c4U, 0xa8919139U, 0xa4959531U, 0x37e4e4d3U, 0x8b7979f2U,
+  0x32e7e7d5U, 0x43c8c88bU, 0x5937376eU, 0xb76d6ddaU, 0x8c8d8d01U, 0x64d5d5b1U, 0xd24e4e9cU, 0xe0a9a949U,
+  0xb46c6cd8U, 0xfa5656acU, 0x07f4f4f3U, 0x25eaeacfU, 0xaf6565caU, 0x8e7a7af4U, 0xe9aeae47U, 0x18080810U,
+  0xd5baba6fU, 0x887878f0U, 0x6f25254aU, 0x722e2e5cU, 0x241c1c38U, 0xf1a6a657U, 0xc7b4b473U, 0x51c6c697U,
+  0x23e8e8cbU, 0x7cdddda1U, 0x9c7474e8U, 0x211f1f3eU, 0xdd4b4b96U, 0xdcbdbd61U, 0x868b8b0dU, 0x858a8a0fU,
+  0x907070e0U, 0x423e3e7cU, 0xc4b5b571U, 0xaa6666ccU, 0xd8484890U, 0x05030306U, 0x01f6f6f7U, 0x120e0e1cU,
+  0xa36161c2U, 0x5f35356aU, 0xf95757aeU, 0xd0b9b969U, 0x91868617U, 0x58c1c199U, 0x271d1d3aU, 0xb99e9e27U,
+  0x38e1e1d9U, 0x13f8f8ebU, 0xb398982bU, 0x33111122U, 0xbb6969d2U, 0x70d9d9a9U, 0x898e8e07U, 0xa7949433U,
+  0xb69b9b2dU, 0x221e1e3cU, 0x92878715U, 0x20e9e9c9U, 0x49cece87U, 0xff5555aaU, 0x78282850U, 0x7adfdfa5U,
+  0x8f8c8c03U, 0xf8a1a159U, 0x80898909U, 0x170d0d1aU, 0xdabfbf65U, 0x31e6e6d7U, 0xc6424284U, 0xb86868d0U,
+  0xc3414182U, 0xb0999929U, 0x772d2d5aU, 0x110f0f1eU, 0xcbb0b07bU, 0xfc5454a8U, 0xd6bbbb6dU, 0x3a16162cU,
+
+  0x6363c6a5U, 0x7c7cf884U, 0x7777ee99U, 0x7b7bf68dU, 0xf2f2ff0dU, 0x6b6bd6bdU, 0x6f6fdeb1U, 0xc5c59154U,
+  0x30306050U, 0x01010203U, 0x6767cea9U, 0x2b2b567dU, 0xfefee719U, 0xd7d7b562U, 0xabab4de6U, 0x7676ec9aU,
+  0xcaca8f45U, 0x82821f9dU, 0xc9c98940U, 0x7d7dfa87U, 0xfafaef15U, 0x5959b2ebU, 0x47478ec9U, 0xf0f0fb0bU,
+  0xadad41ecU, 0xd4d4b367U, 0xa2a25ffdU, 0xafaf45eaU, 0x9c9c23bfU, 0xa4a453f7U, 0x7272e496U, 0xc0c09b5bU,
+  0xb7b775c2U, 0xfdfde11cU, 0x93933daeU, 0x26264c6aU, 0x36366c5aU, 0x3f3f7e41U, 0xf7f7f502U, 0xcccc834fU,
+  0x3434685cU, 0xa5a551f4U, 0xe5e5d134U, 0xf1f1f908U, 0x7171e293U, 0xd8d8ab73U, 0x31316253U, 0x15152a3fU,
+  0x0404080cU, 0xc7c79552U, 0x23234665U, 0xc3c39d5eU, 0x18183028U, 0x969637a1U, 0x05050a0fU, 0x9a9a2fb5U,
+  0x07070e09U, 0x12122436U, 0x80801b9bU, 0xe2e2df3dU, 0xebebcd26U, 0x27274e69U, 0xb2b27fcdU, 0x7575ea9fU,
+  0x0909121bU, 0x83831d9eU, 0x2c2c5874U, 0x1a1a342eU, 0x1b1b362dU, 0x6e6edcb2U, 0x5a5ab4eeU, 0xa0a05bfbU,
+  0x5252a4f6U, 0x3b3b764dU, 0xd6d6b761U, 0xb3b37dceU, 0x2929527bU, 0xe3e3dd3eU, 0x2f2f5e71U, 0x84841397U,
+  0x5353a6f5U, 0xd1d1b968U, 0x00000000U, 0xededc12cU, 0x20204060U, 0xfcfce31fU, 0xb1b179c8U, 0x5b5bb6edU,
+  0x6a6ad4beU, 0xcbcb8d46U, 0xbebe67d9U, 0x3939724bU, 0x4a4a94deU, 0x4c4c98d4U, 0x5858b0e8U, 0xcfcf854aU,
+  0xd0d0bb6bU, 0xefefc52aU, 0xaaaa4fe5U, 0xfbfbed16U, 0x434386c5U, 0x4d4d9ad7U, 0x33336655U, 0x85851194U,
+  0x45458acfU, 0xf9f9e910U, 0x02020406U, 0x7f7ffe81U, 0x5050a0f0U, 0x3c3c7844U, 0x9f9f25baU, 0xa8a84be3U,
+  0x5151a2f3U, 0xa3a35dfeU, 0x404080c0U, 0x8f8f058aU, 0x92923fadU, 0x9d9d21bcU, 0x38387048U, 0xf5f5f104U,
+  0xbcbc63dfU, 0xb6b677c1U, 0xdadaaf75U, 0x21214263U, 0x10102030U, 0xffffe51aU, 0xf3f3fd0eU, 0xd2d2bf6dU,
+  0xcdcd814cU, 0x0c0c1814U, 0x13132635U, 0xececc32fU, 0x5f5fbee1U, 0x979735a2U, 0x444488ccU, 0x17172e39U,
+  0xc4c49357U, 0xa7a755f2U, 0x7e7efc82U, 0x3d3d7a47U, 0x6464c8acU, 0x5d5dbae7U, 0x1919322bU, 0x7373e695U,
+  0x6060c0a0U, 0x81811998U, 0x4f4f9ed1U, 0xdcdca37fU, 0x22224466U, 0x2a2a547eU, 0x90903babU, 0x88880b83U,
+  0x46468ccaU, 0xeeeec729U, 0xb8b86bd3U, 0x1414283cU, 0xdedea779U, 0x5e5ebce2U, 0x0b0b161dU, 0xdbdbad76U,
+  0xe0e0db3bU, 0x32326456U, 0x3a3a744eU, 0x0a0a141eU, 0x494992dbU, 0x06060c0aU, 0x2424486cU, 0x5c5cb8e4U,
+  0xc2c29f5dU, 0xd3d3bd6eU, 0xacac43efU, 0x6262c4a6U, 0x919139a8U, 0x959531a4U, 0xe4e4d337U, 0x7979f28bU,
+  0xe7e7d532U, 0xc8c88b43U, 0x37376e59U, 0x6d6ddab7U, 0x8d8d018cU, 0xd5d5b164U, 0x4e4e9cd2U, 0xa9a949e0U,
+  0x6c6cd8b4U, 0x5656acfaU, 0xf4f4f307U, 0xeaeacf25U, 0x6565caafU, 0x7a7af48eU, 0xaeae47e9U, 0x08081018U,
+  0xbaba6fd5U, 0x7878f088U, 0x25254a6fU, 0x2e2e5c72U, 0x1c1c3824U, 0xa6a657f1U, 0xb4b473c7U, 0xc6c69751U,
+  0xe8e8cb23U, 0xdddda17cU, 0x7474e89cU, 0x1f1f3e21U, 0x4b4b96ddU, 0xbdbd61dcU, 0x8b8b0d86U, 0x8a8a0f85U,
+  0x7070e090U, 0x3e3e7c42U, 0xb5b571c4U, 0x6666ccaaU, 0x484890d8U, 0x03030605U, 0xf6f6f701U, 0x0e0e1c12U,
+  0x6161c2a3U, 0x35356a5fU, 0x5757aef9U, 0xb9b969d0U, 0x86861791U, 0xc1c19958U, 0x1d1d3a27U, 0x9e9e27b9U,
+  0xe1e1d938U, 0xf8f8eb13U, 0x98982bb3U, 0x11112233U, 0x6969d2bbU, 0xd9d9a970U, 0x8e8e0789U, 0x949433a7U,
+  0x9b9b2db6U, 0x1e1e3c22U, 0x87871592U, 0xe9e9c920U, 0xcece8749U, 0x5555aaffU, 0x28285078U, 0xdfdfa57aU,
+  0x8c8c038fU, 0xa1a159f8U, 0x89890980U, 0x0d0d1a17U, 0xbfbf65daU, 0xe6e6d731U, 0x424284c6U, 0x6868d0b8U,
+  0x414182c3U, 0x999929b0U, 0x2d2d5a77U, 0x0f0f1e11U, 0xb0b07bcbU, 0x5454a8fcU, 0xbbbb6dd6U, 0x16162c3aU,
+
+  0x63c6a563U, 0x7cf8847cU, 0x77ee9977U, 0x7bf68d7bU, 0xf2ff0df2U, 0x6bd6bd6bU, 0x6fdeb16fU, 0xc59154c5U,
+  0x30605030U, 0x01020301U, 0x67cea967U, 0x2b567d2bU, 0xfee719feU, 0xd7b562d7U, 0xab4de6abU, 0x76ec9a76U,
+  0xca8f45caU, 0x821f9d82U, 0xc98940c9U, 0x7dfa877dU, 0xfaef15faU, 0x59b2eb59U, 0x478ec947U, 0xf0fb0bf0U,
+  0xad41ecadU, 0xd4b367d4U, 0xa25ffda2U, 0xaf45eaafU, 0x9c23bf9cU, 0xa453f7a4U, 0x72e49672U, 0xc09b5bc0U,
+  0xb775c2b7U, 0xfde11cfdU, 0x933dae93U, 0x264c6a26U, 0x366c5a36U, 0x3f7e413fU, 0xf7f502f7U, 0xcc834fccU,
+  0x34685c34U, 0xa551f4a5U, 0xe5d134e5U, 0xf1f908f1U, 0x71e29371U, 0xd8ab73d8U, 0x31625331U, 0x152a3f15U,
+  0x04080c04U, 0xc79552c7U, 0x23466523U, 0xc39d5ec3U, 0x18302818U, 0x9637a196U, 0x050a0f05U, 0x9a2fb59aU,
+  0x070e0907U, 0x12243612U, 0x801b9b80U, 0xe2df3de2U, 0xebcd26ebU, 0x274e6927U, 0xb27fcdb2U, 0x75ea9f75U,
+  0x09121b09U, 0x831d9e83U, 0x2c58742cU, 0x1a342e1aU, 0x1b362d1bU, 0x6edcb26eU, 0x5ab4ee5aU, 0xa05bfba0U,
+  0x52a4f652U, 0x3b764d3bU, 0xd6b761d6U, 0xb37dceb3U, 0x29527b29U, 0xe3dd3ee3U, 0x2f5e712fU, 0x84139784U,
+  0x53a6f553U, 0xd1b968d1U, 0x00000000U, 0xedc12cedU, 0x20406020U, 0xfce31ffcU, 0xb179c8b1U, 0x5bb6ed5bU,
+  0x6ad4be6aU, 0xcb8d46cbU, 0xbe67d9beU, 0x39724b39U, 0x4a94de4aU, 0x4c98d44cU, 0x58b0e858U, 0xcf854acfU,
+  0xd0bb6bd0U, 0xefc52aefU, 0xaa4fe5aaU, 0xfbed16fbU, 0x4386c543U, 0x4d9ad74dU, 0x33665533U, 0x85119485U,
+  0x458acf45U, 0xf9e910f9U, 0x02040602U, 0x7ffe817fU, 0x50a0f050U, 0x3c78443cU, 0x9f25ba9fU, 0xa84be3a8U,
+  0x51a2f351U, 0xa35dfea3U, 0x4080c040U, 0x8f058a8fU, 0x923fad92U, 0x9d21bc9dU, 0x38704838U, 0xf5f104f5U,
+  0xbc63dfbcU, 0xb677c1b6U, 0xdaaf75daU, 0x21426321U, 0x10203010U, 0xffe51affU, 0xf3fd0ef3U, 0xd2bf6dd2U,
+  0xcd814ccdU, 0x0c18140cU, 0x13263513U, 0xecc32fecU, 0x5fbee15fU, 0x9735a297U, 0x4488cc44U, 0x172e3917U,
+  0xc49357c4U, 0xa755f2a7U, 0x7efc827eU, 0x3d7a473dU, 0x64c8ac64U, 0x5dbae75dU, 0x19322b19U, 0x73e69573U,
+  0x60c0a060U, 0x81199881U, 0x4f9ed14fU, 0xdca37fdcU, 0x22446622U, 0x2a547e2aU, 0x903bab90U, 0x880b8388U,
+  0x468cca46U, 0xeec729eeU, 0xb86bd3b8U, 0x14283c14U, 0xdea779deU, 0x5ebce25eU, 0x0b161d0bU, 0xdbad76dbU,
+  0xe0db3be0U, 0x32645632U, 0x3a744e3aU, 0x0a141e0aU, 0x4992db49U, 0x060c0a06U, 0x24486c24U, 0x5cb8e45cU,
+  0xc29f5dc2U, 0xd3bd6ed3U, 0xac43efacU, 0x62c4a662U, 0x9139a891U, 0x9531a495U, 0xe4d337e4U, 0x79f28b79U,
+  0xe7d532e7U, 0xc88b43c8U, 0x376e5937U, 0x6ddab76dU, 0x8d018c8dU, 0xd5b164d5U, 0x4e9cd24eU, 0xa949e0a9U,
+  0x6cd8b46cU, 0x56acfa56U, 0xf4f307f4U, 0xeacf25eaU, 0x65caaf65U, 0x7af48e7aU, 0xae47e9aeU, 0x08101808U,
+  0xba6fd5baU, 0x78f08878U, 0x254a6f25U, 0x2e5c722eU, 0x1c38241cU, 0xa657f1a6U, 0xb473c7b4U, 0xc69751c6U,
+  0xe8cb23e8U, 0xdda17cddU, 0x74e89c74U, 0x1f3e211fU, 0x4b96dd4bU, 0xbd61dcbdU, 0x8b0d868bU, 0x8a0f858aU,
+  0x70e09070U, 0x3e7c423eU, 0xb571c4b5U, 0x66ccaa66U, 0x4890d848U, 0x03060503U, 0xf6f701f6U, 0x0e1c120eU,
+  0x61c2a361U, 0x356a5f35U, 0x57aef957U, 0xb969d0b9U, 0x86179186U, 0xc19958c1U, 0x1d3a271dU, 0x9e27b99eU,
+  0xe1d938e1U, 0xf8eb13f8U, 0x982bb398U, 0x11223311U, 0x69d2bb69U, 0xd9a970d9U, 0x8e07898eU, 0x9433a794U,
+  0x9b2db69bU, 0x1e3c221eU, 0x87159287U, 0xe9c920e9U, 0xce8749ceU, 0x55aaff55U, 0x28507828U, 0xdfa57adfU,
+  0x8c038f8cU, 0xa159f8a1U, 0x89098089U, 0x0d1a170dU, 0xbf65dabfU, 0xe6d731e6U, 0x4284c642U, 0x68d0b868U,
+  0x4182c341U, 0x9929b099U, 0x2d5a772dU, 0x0f1e110fU, 0xb07bcbb0U, 0x54a8fc54U, 0xbb6dd6bbU, 0x162c3a16U,
+
+  0xc6a56363U, 0xf8847c7cU, 0xee997777U, 0xf68d7b7bU, 0xff0df2f2U, 0xd6bd6b6bU, 0xdeb16f6fU, 0x9154c5c5U,
+  0x60503030U, 0x02030101U, 0xcea96767U, 0x567d2b2bU, 0xe719fefeU, 0xb562d7d7U, 0x4de6ababU, 0xec9a7676U,
+  0x8f45cacaU, 0x1f9d8282U, 0x8940c9c9U, 0xfa877d7dU, 0xef15fafaU, 0xb2eb5959U, 0x8ec94747U, 0xfb0bf0f0U,
+  0x41ecadadU, 0xb367d4d4U, 0x5ffda2a2U, 0x45eaafafU, 0x23bf9c9cU, 0x53f7a4a4U, 0xe4967272U, 0x9b5bc0c0U,
+  0x75c2b7b7U, 0xe11cfdfdU, 0x3dae9393U, 0x4c6a2626U, 0x6c5a3636U, 0x7e413f3fU, 0xf502f7f7U, 0x834fccccU,
+  0x685c3434U, 0x51f4a5a5U, 0xd134e5e5U, 0xf908f1f1U, 0xe2937171U, 0xab73d8d8U, 0x62533131U, 0x2a3f1515U,
+  0x080c0404U, 0x9552c7c7U, 0x46652323U, 0x9d5ec3c3U, 0x30281818U, 0x37a19696U, 0x0a0f0505U, 0x2fb59a9aU,
+  0x0e090707U, 0x24361212U, 0x1b9b8080U, 0xdf3de2e2U, 0xcd26ebebU, 0x4e692727U, 0x7fcdb2b2U, 0xea9f7575U,
+  0x121b0909U, 0x1d9e8383U, 0x58742c2cU, 0x342e1a1aU, 0x362d1b1bU, 0xdcb26e6eU, 0xb4ee5a5aU, 0x5bfba0a0U,
+  0xa4f65252U, 0x764d3b3bU, 0xb761d6d6U, 0x7dceb3b3U, 0x527b2929U, 0xdd3ee3e3U, 0x5e712f2fU, 0x13978484U,
+  0xa6f55353U, 0xb968d1d1U, 0x00000000U, 0xc12cededU, 0x40602020U, 0xe31ffcfcU, 0x79c8b1b1U, 0xb6ed5b5bU,
+  0xd4be6a6aU, 0x8d46cbcbU, 0x67d9bebeU, 0x724b3939U, 0x94de4a4aU, 0x98d44c4cU, 0xb0e85858U, 0x854acfcfU,
+  0xbb6bd0d0U, 0xc52aefefU, 0x4fe5aaaaU, 0xed16fbfbU, 0x86c54343U, 0x9ad74d4dU, 0x66553333U, 0x11948585U,
+  0x8acf4545U, 0xe910f9f9U, 0x04060202U, 0xfe817f7fU, 0xa0f05050U, 0x78443c3cU, 0x25ba9f9fU, 0x4be3a8a8U,
+  0xa2f35151U, 0x5dfea3a3U, 0x80c04040U, 0x058a8f8fU, 0x3fad9292U, 0x21bc9d9dU, 0x70483838U, 0xf104f5f5U,
+  0x63dfbcbcU, 0x77c1b6b6U, 0xaf75dadaU, 0x42632121U, 0x20301010U, 0xe51affffU, 0xfd0ef3f3U, 0xbf6dd2d2U,
+  0x814ccdcdU, 0x18140c0cU, 0x26351313U, 0xc32fececU, 0xbee15f5fU, 0x35a29797U, 0x88cc4444U, 0x2e391717U,
+  0x9357c4c4U, 0x55f2a7a7U, 0xfc827e7eU, 0x7a473d3dU, 0xc8ac6464U, 0xbae75d5dU, 0x322b1919U, 0xe6957373U,
+  0xc0a06060U, 0x19988181U, 0x9ed14f4fU, 0xa37fdcdcU, 0x44662222U, 0x547e2a2aU, 0x3bab9090U, 0x0b838888U,
+  0x8cca4646U, 0xc729eeeeU, 0x6bd3b8b8U, 0x283c1414U, 0xa779dedeU, 0xbce25e5eU, 0x161d0b0bU, 0xad76dbdbU,
+  0xdb3be0e0U, 0x64563232U, 0x744e3a3aU, 0x141e0a0aU, 0x92db4949U, 0x0c0a0606U, 0x486c2424U, 0xb8e45c5cU,
+  0x9f5dc2c2U, 0xbd6ed3d3U, 0x43efacacU, 0xc4a66262U, 0x39a89191U, 0x31a49595U, 0xd337e4e4U, 0xf28b7979U,
+  0xd532e7e7U, 0x8b43c8c8U, 0x6e593737U, 0xdab76d6dU, 0x018c8d8dU, 0xb164d5d5U, 0x9cd24e4eU, 0x49e0a9a9U,
+  0xd8b46c6cU, 0xacfa5656U, 0xf307f4f4U, 0xcf25eaeaU, 0xcaaf6565U, 0xf48e7a7aU, 0x47e9aeaeU, 0x10180808U,
+  0x6fd5babaU, 0xf0887878U, 0x4a6f2525U, 0x5c722e2eU, 0x38241c1cU, 0x57f1a6a6U, 0x73c7b4b4U, 0x9751c6c6U,
+  0xcb23e8e8U, 0xa17cddddU, 0xe89c7474U, 0x3e211f1fU, 0x96dd4b4bU, 0x61dcbdbdU, 0x0d868b8bU, 0x0f858a8aU,
+  0xe0907070U, 0x7c423e3eU, 0x71c4b5b5U, 0xccaa6666U, 0x90d84848U, 0x06050303U, 0xf701f6f6U, 0x1c120e0eU,
+  0xc2a36161U, 0x6a5f3535U, 0xaef95757U, 0x69d0b9b9U, 0x17918686U, 0x9958c1c1U, 0x3a271d1dU, 0x27b99e9eU,
+  0xd938e1e1U, 0xeb13f8f8U, 0x2bb39898U, 0x22331111U, 0xd2bb6969U, 0xa970d9d9U, 0x07898e8eU, 0x33a79494U,
+  0x2db69b9bU, 0x3c221e1eU, 0x15928787U, 0xc920e9e9U, 0x8749ceceU, 0xaaff5555U, 0x50782828U, 0xa57adfdfU,
+  0x038f8c8cU, 0x59f8a1a1U, 0x09808989U, 0x1a170d0dU, 0x65dabfbfU, 0xd731e6e6U, 0x84c64242U, 0xd0b86868U,
+  0x82c34141U, 0x29b09999U, 0x5a772d2dU, 0x1e110f0fU, 0x7bcbb0b0U, 0xa8fc5454U, 0x6dd6bbbbU, 0x2c3a1616U
+};
+*/
+
+#define AS_U32(addr) *((uint32_t*)(addr))
+#define AS_UINT2(addr) *((uint2*)(addr))
+#define AS_UINT4(addr) *((uint4*)(addr))
+#define AS_UL2(addr) *((ulonglong2*)(addr))
+
+#define t_fn0(x) (sharedMemory[x])
+#define t_fn1(x) (sharedMemory[0x100U | (x)])
+#define t_fn2(x) (sharedMemory[0x200U | (x)])
+#define t_fn3(x) (sharedMemory[0x300U | (x)])
+
+#define round(shared, out, x, k) \
+  out[0] = (k)[0] ^ (t_fn0(x[0] & 0xff) ^ t_fn1((x[1] >> 8) & 0xff) ^ t_fn2((x[2] >> 16) & 0xff) ^ t_fn3((x[3] >> 24) & 0xff)); \
+  out[1] = (k)[1] ^ (t_fn0(x[1] & 0xff) ^ t_fn1((x[2] >> 8) & 0xff) ^ t_fn2((x[3] >> 16) & 0xff) ^ t_fn3((x[0] >> 24) & 0xff)); \
+  out[2] = (k)[2] ^ (t_fn0(x[2] & 0xff) ^ t_fn1((x[3] >> 8) & 0xff) ^ t_fn2((x[0] >> 16) & 0xff) ^ t_fn3((x[1] >> 24) & 0xff)); \
+  out[3] = (k)[3] ^ (t_fn0(x[3] & 0xff) ^ t_fn1((x[0] >> 8) & 0xff) ^ t_fn2((x[1] >> 16) & 0xff) ^ t_fn3((x[2] >> 24) & 0xff));
+
+#define round_u4(shared, out, in, k) \
+  ((uint32_t*)out)[0] = (k)[0] ^ t_fn0(in[0].x) ^ t_fn1(in[1].y) ^ t_fn2(in[2].z) ^ t_fn3(in[3].w); \
+  ((uint32_t*)out)[1] = (k)[1] ^ t_fn0(in[1].x) ^ t_fn1(in[2].y) ^ t_fn2(in[3].z) ^ t_fn3(in[0].w); \
+  ((uint32_t*)out)[2] = (k)[2] ^ t_fn0(in[2].x) ^ t_fn1(in[3].y) ^ t_fn2(in[0].z) ^ t_fn3(in[1].w); \
+  ((uint32_t*)out)[3] = (k)[3] ^ t_fn0(in[3].x) ^ t_fn1(in[0].y) ^ t_fn2(in[1].z) ^ t_fn3(in[2].w);
+
+#ifdef __INTELLISENSE__
+#define __byte_perm(a,b,c) a
+#endif
+
+#define OFF32_0(x) (x & 0xFFu)
+#define OFF32_1(x) __byte_perm(x, 0x01, 0x5541)
+#define OFF32_2(x) __byte_perm(x, 0x02, 0x5542)
+#define OFF32_3(x) __byte_perm(x, 0x03, 0x5543)
+
+#define SHARED_0(x) sharedMemory[OFF32_0(x)]
+#define SHARED_1(x) sharedMemory[OFF32_1(x)]
+#define SHARED_2(x) sharedMemory[OFF32_2(x)]
+#define SHARED_3(x) sharedMemory[OFF32_3(x)]
+
+__device__ __forceinline__
+void cn_aes_single_round(uint32_t * const sharedMemory, uint32_t * const in, uint32_t * out, uint32_t* expandedKey)
+{
+  asm("// aes_single_round");
+  out[0] = expandedKey[0] ^ SHARED_0(in[0]) ^ SHARED_1(in[1]) ^ SHARED_2(in[2]) ^ SHARED_3(in[3]);
+  out[1] = expandedKey[1] ^ SHARED_0(in[1]) ^ SHARED_1(in[2]) ^ SHARED_2(in[3]) ^ SHARED_3(in[0]);
+  out[2] = expandedKey[2] ^ SHARED_0(in[2]) ^ SHARED_1(in[3]) ^ SHARED_2(in[0]) ^ SHARED_3(in[1]);
+  out[3] = expandedKey[3] ^ SHARED_0(in[3]) ^ SHARED_1(in[0]) ^ SHARED_2(in[1]) ^ SHARED_3(in[2]);
+}
+
+//
+#ifdef _WIN64
+/* do a mul.wide.u32 to prevent a shl + cvt 32 to 64 on ld.shared [ptr] */
+#define OFF8_0(x) (x & 0xFFu) * sizeof(uint32_t)
+#define OFF8_1(x) __byte_perm(x, 0x01, 0x5541) * sizeof(uint32_t)
+#define OFF8_2(x) __byte_perm(x, 0x02, 0x5542) * sizeof(uint32_t)
+#define OFF8_3(x) __byte_perm(x, 0x03, 0x5543) * sizeof(uint32_t)
+#else
+#define OFF8_0(x) (x & 0xFFu) << 2
+#define OFF8_1(x) __byte_perm(x, 0x01, 0x5541) << 2
+#define OFF8_2(x) __byte_perm(x, 0x02, 0x5542) << 2
+#define OFF8_3(x) __byte_perm(x, 0x03, 0x5543) << 2
+#endif
+
+#define SHAR8_0(x) AS_U32(&sharedMemory[OFF8_0(x)])
+#define SHAR8_1(x) AS_U32(&sharedMemory[OFF8_1(x)])
+#define SHAR8_2(x) AS_U32(&sharedMemory[OFF8_2(x)])
+#define SHAR8_3(x) AS_U32(&sharedMemory[OFF8_3(x)])
+
+__device__ __forceinline__
+void cn_aes_single_round_b(uint8_t * const sharedMemory, void * const long_state, const uint4 key, uint4 *res)
+{
+  asm("// aes_single_round_b");
+  uint4 in = AS_UINT4(long_state);
+  *res = key;
+  res->x ^= SHAR8_0(in.x) ^ SHAR8_1(in.y) ^ SHAR8_2(in.z) ^ SHAR8_3(in.w);
+  res->y ^= SHAR8_0(in.y) ^ SHAR8_1(in.z) ^ SHAR8_2(in.w) ^ SHAR8_3(in.x);
+  res->z ^= SHAR8_0(in.z) ^ SHAR8_1(in.w) ^ SHAR8_2(in.x) ^ SHAR8_3(in.y);
+  res->w ^= SHAR8_0(in.w) ^ SHAR8_1(in.x) ^ SHAR8_2(in.y) ^ SHAR8_3(in.z);
+}
+
+#define round_perm(shared, out, in, k) \
+  out[0] = (k)[0] ^ SHARED_0(in[0]) ^ SHARED_1(in[1]) ^ SHARED_2(in[2]) ^ SHARED_3(in[3]); \
+  out[1] = (k)[1] ^ SHARED_0(in[1]) ^ SHARED_1(in[2]) ^ SHARED_2(in[3]) ^ SHARED_3(in[0]); \
+  out[2] = (k)[2] ^ SHARED_0(in[2]) ^ SHARED_1(in[3]) ^ SHARED_2(in[0]) ^ SHARED_3(in[1]); \
+  out[3] = (k)[3] ^ SHARED_0(in[3]) ^ SHARED_1(in[0]) ^ SHARED_2(in[1]) ^ SHARED_3(in[2]);
+
+__device__ __forceinline__
+void cn_aes_pseudo_round_mut(const uint32_t * sharedMemory, uint32_t * val, uint32_t const * expandedKey)
+{
+  asm("// aes_pseudo_round_mut");
+  uint32_t b[4];
+  round_perm(sharedMemory, b, val, expandedKey);
+  round_perm(sharedMemory, val, b, expandedKey + (1 * N_COLS));
+  round_perm(sharedMemory, b, val, expandedKey + (2 * N_COLS));
+  round_perm(sharedMemory, val, b, expandedKey + (3 * N_COLS));
+  round_perm(sharedMemory, b, val, expandedKey + (4 * N_COLS));
+  round_perm(sharedMemory, val, b, expandedKey + (5 * N_COLS));
+  round_perm(sharedMemory, b, val, expandedKey + (6 * N_COLS));
+  round_perm(sharedMemory, val, b, expandedKey + (7 * N_COLS));
+  round_perm(sharedMemory, b, val, expandedKey + (8 * N_COLS));
+  round_perm(sharedMemory, val, b, expandedKey + (9 * N_COLS));
+}
+
+static __forceinline__ __device__ uint4 operator ^ (const uint4 &a, const uint4 &b) {
+  return make_uint4(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
+}
+
+#define round_perm4(in, k) {\
+  uint4 tmp; \
+  tmp.x = SHARED_0(in.x) ^ SHARED_1(in.y) ^ SHARED_2(in.z) ^ SHARED_3(in.w); \
+  tmp.y = SHARED_0(in.y) ^ SHARED_1(in.z) ^ SHARED_2(in.w) ^ SHARED_3(in.x); \
+  tmp.z = SHARED_0(in.z) ^ SHARED_1(in.w) ^ SHARED_2(in.x) ^ SHARED_3(in.y); \
+  tmp.w = SHARED_0(in.w) ^ SHARED_1(in.x) ^ SHARED_2(in.y) ^ SHARED_3(in.z); \
+  val = tmp ^ key[k]; \
+}
+
+__device__ __forceinline__
+void cn_aes_pseudo_round_mut_uint4(uint32_t * const sharedMemory, uint4 &val, uint4 const key[10])
+{
+  asm("// aes_pseudo_round_mut_uint4");
+  round_perm4(val, 0);
+  round_perm4(val, 1);
+  round_perm4(val, 2);
+  round_perm4(val, 3);
+  round_perm4(val, 4);
+  round_perm4(val, 5);
+  round_perm4(val, 6);
+  round_perm4(val, 7);
+  round_perm4(val, 8);
+  round_perm4(val, 9);
+}
+
+/*
+__device__ __forceinline__
+void cn_aes_gpu_init2(uint32_t* sharedMemory)
+{
+#if 0
+  if(blockDim.x >= 64)
+  {
+    if(threadIdx.x < 64) {
+      #define thrX (threadIdx.x << 2U) // ensure offsets aligned (16) to vector
+      #pragma unroll 4
+      for (uint32_t i = 0; i < 1024U; i += 256U) // 32x32 = 1024, 4 * 256 also
+        AS_UINT4(&sharedMemory[i + thrX]) = AS_UINT4(&d_t_fn[i + thrX]);
+    }
+
+  } else
+#endif
+  if(blockDim.x >= 32) {
+
+    if(threadIdx.x < 32) {
+#if 0
+      #pragma unroll 32
+      for(uint32_t i = 0; i < 1024; i += 32)
+        sharedMemory[threadIdx.x + i] = d_t_fn[threadIdx.x + i];
+#else
+      #define thrX (threadIdx.x << 2U) // ensure offsets aligned (16) to vector
+      #pragma unroll 8
+      for (uint32_t i = 0; i < 1024; i += 128U) // 32x32 = 1024, 8 * 128 also
+        AS_UINT4(&sharedMemory[i + thrX]) = AS_UINT4(&d_t_fn[i + thrX]);
+#endif
+    }
+
+  } else {
+
+    if(threadIdx.x < 4) {
+#if 0
+      for (uint32_t i = 0; i < 1024; i += 4)
+        sharedMemory[threadIdx.x + i] = d_t_fn[threadIdx.x + i];
+#else
+      #define thrX (threadIdx.x << 2U) // ensure offsets aligned (16) to vector
+      #pragma unroll 64
+      for (uint32_t i = 0; i < 1024; i += 16U)
+        AS_UINT4(&sharedMemory[i + thrX]) = AS_UINT4(&d_t_fn[i + thrX]);
+#endif
+    }
+  }
+}
+*/
+
+__device__ __forceinline__
+void cn_aes_gpu_init(uint32_t* sharedMemory)
+{
+  // AES 0
+  switch (threadIdx.x) {
+  case 0:
+    AS_UL2(&sharedMemory[0x000]) = make_ulonglong2(0x847c7cf8a56363c6, 0x8d7b7bf6997777ee);
+    AS_UL2(&sharedMemory[0x004]) = make_ulonglong2(0xbd6b6bd60df2f2ff, 0x54c5c591b16f6fde);
+    AS_UL2(&sharedMemory[0x008]) = make_ulonglong2(0x0301010250303060, 0x7d2b2b56a96767ce);
+    AS_UL2(&sharedMemory[0x00C]) = make_ulonglong2(0x62d7d7b519fefee7, 0x9a7676ece6abab4d);
+    AS_UL2(&sharedMemory[0x010]) = make_ulonglong2(0x9d82821f45caca8f, 0x877d7dfa40c9c989);
+    AS_UL2(&sharedMemory[0x014]) = make_ulonglong2(0xeb5959b215fafaef, 0x0bf0f0fbc947478e);
+    AS_UL2(&sharedMemory[0x018]) = make_ulonglong2(0x67d4d4b3ecadad41, 0xeaafaf45fda2a25f);
+    AS_UL2(&sharedMemory[0x01C]) = make_ulonglong2(0xf7a4a453bf9c9c23, 0x5bc0c09b967272e4);
+    break;
+  case 1:
+    AS_UL2(&sharedMemory[0x020]) = make_ulonglong2(0x1cfdfde1c2b7b775, 0x6a26264cae93933d);
+    AS_UL2(&sharedMemory[0x024]) = make_ulonglong2(0x413f3f7e5a36366c, 0x4fcccc8302f7f7f5);
+    AS_UL2(&sharedMemory[0x028]) = make_ulonglong2(0xf4a5a5515c343468, 0x08f1f1f934e5e5d1);
+    AS_UL2(&sharedMemory[0x02C]) = make_ulonglong2(0x73d8d8ab937171e2, 0x3f15152a53313162);
+    AS_UL2(&sharedMemory[0x030]) = make_ulonglong2(0x52c7c7950c040408, 0x5ec3c39d65232346);
+    AS_UL2(&sharedMemory[0x034]) = make_ulonglong2(0xa196963728181830, 0xb59a9a2f0f05050a);
+    AS_UL2(&sharedMemory[0x038]) = make_ulonglong2(0x361212240907070e, 0x3de2e2df9b80801b);
+    AS_UL2(&sharedMemory[0x03C]) = make_ulonglong2(0x6927274e26ebebcd, 0x9f7575eacdb2b27f);
+    break;
+  case 2:
+    AS_UL2(&sharedMemory[0x040]) = make_ulonglong2(0x9e83831d1b090912, 0x2e1a1a34742c2c58);
+    AS_UL2(&sharedMemory[0x044]) = make_ulonglong2(0xb26e6edc2d1b1b36, 0xfba0a05bee5a5ab4);
+    AS_UL2(&sharedMemory[0x048]) = make_ulonglong2(0x4d3b3b76f65252a4, 0xceb3b37d61d6d6b7);
+    AS_UL2(&sharedMemory[0x04C]) = make_ulonglong2(0x3ee3e3dd7b292952, 0x97848413712f2f5e);
+    AS_UL2(&sharedMemory[0x050]) = make_ulonglong2(0x68d1d1b9f55353a6, 0x2cededc100000000);
+    AS_UL2(&sharedMemory[0x054]) = make_ulonglong2(0x1ffcfce360202040, 0xed5b5bb6c8b1b179);
+    AS_UL2(&sharedMemory[0x058]) = make_ulonglong2(0x46cbcb8dbe6a6ad4, 0x4b393972d9bebe67);
+    AS_UL2(&sharedMemory[0x05C]) = make_ulonglong2(0xd44c4c98de4a4a94, 0x4acfcf85e85858b0);
+    break;
+  case 3:
+    AS_UL2(&sharedMemory[0x060]) = make_ulonglong2(0x2aefefc56bd0d0bb, 0x16fbfbede5aaaa4f);
+    AS_UL2(&sharedMemory[0x064]) = make_ulonglong2(0xd74d4d9ac5434386, 0x9485851155333366);
+    AS_UL2(&sharedMemory[0x068]) = make_ulonglong2(0x10f9f9e9cf45458a, 0x817f7ffe06020204);
+    AS_UL2(&sharedMemory[0x06C]) = make_ulonglong2(0x443c3c78f05050a0, 0xe3a8a84bba9f9f25);
+    AS_UL2(&sharedMemory[0x070]) = make_ulonglong2(0xfea3a35df35151a2, 0x8a8f8f05c0404080);
+    AS_UL2(&sharedMemory[0x074]) = make_ulonglong2(0xbc9d9d21ad92923f, 0x04f5f5f148383870);
+    AS_UL2(&sharedMemory[0x078]) = make_ulonglong2(0xc1b6b677dfbcbc63, 0x6321214275dadaaf);
+    AS_UL2(&sharedMemory[0x07C]) = make_ulonglong2(0x1affffe530101020, 0x6dd2d2bf0ef3f3fd);
+    break;
+  case 4:
+    AS_UL2(&sharedMemory[0x080]) = make_ulonglong2(0x140c0c184ccdcd81, 0x2fececc335131326);
+    AS_UL2(&sharedMemory[0x084]) = make_ulonglong2(0xa2979735e15f5fbe, 0x3917172ecc444488);
+    AS_UL2(&sharedMemory[0x088]) = make_ulonglong2(0xf2a7a75557c4c493, 0x473d3d7a827e7efc);
+    AS_UL2(&sharedMemory[0x08C]) = make_ulonglong2(0xe75d5dbaac6464c8, 0x957373e62b191932);
+    AS_UL2(&sharedMemory[0x090]) = make_ulonglong2(0x98818119a06060c0, 0x7fdcdca3d14f4f9e);
+    AS_UL2(&sharedMemory[0x094]) = make_ulonglong2(0x7e2a2a5466222244, 0x8388880bab90903b);
+    AS_UL2(&sharedMemory[0x098]) = make_ulonglong2(0x29eeeec7ca46468c, 0x3c141428d3b8b86b);
+    AS_UL2(&sharedMemory[0x09C]) = make_ulonglong2(0xe25e5ebc79dedea7, 0x76dbdbad1d0b0b16);
+    break;
+  case 5:
+    AS_UL2(&sharedMemory[0x0A0]) = make_ulonglong2(0x563232643be0e0db, 0x1e0a0a144e3a3a74);
+    AS_UL2(&sharedMemory[0x0A4]) = make_ulonglong2(0x0a06060cdb494992, 0xe45c5cb86c242448);
+    AS_UL2(&sharedMemory[0x0A8]) = make_ulonglong2(0x6ed3d3bd5dc2c29f, 0xa66262c4efacac43);
+    AS_UL2(&sharedMemory[0x0AC]) = make_ulonglong2(0xa4959531a8919139, 0x8b7979f237e4e4d3);
+    AS_UL2(&sharedMemory[0x0B0]) = make_ulonglong2(0x43c8c88b32e7e7d5, 0xb76d6dda5937376e);
+    AS_UL2(&sharedMemory[0x0B4]) = make_ulonglong2(0x64d5d5b18c8d8d01, 0xe0a9a949d24e4e9c);
+    AS_UL2(&sharedMemory[0x0B8]) = make_ulonglong2(0xfa5656acb46c6cd8, 0x25eaeacf07f4f4f3);
+    AS_UL2(&sharedMemory[0x0BC]) = make_ulonglong2(0x8e7a7af4af6565ca, 0x18080810e9aeae47);
+    break;
+  case 6:
+    AS_UL2(&sharedMemory[0x0C0]) = make_ulonglong2(0x887878f0d5baba6f, 0x722e2e5c6f25254a);
+    AS_UL2(&sharedMemory[0x0C4]) = make_ulonglong2(0xf1a6a657241c1c38, 0x51c6c697c7b4b473);
+    AS_UL2(&sharedMemory[0x0C8]) = make_ulonglong2(0x7cdddda123e8e8cb, 0x211f1f3e9c7474e8);
+    AS_UL2(&sharedMemory[0x0CC]) = make_ulonglong2(0xdcbdbd61dd4b4b96, 0x858a8a0f868b8b0d);
+    AS_UL2(&sharedMemory[0x0D0]) = make_ulonglong2(0x423e3e7c907070e0, 0xaa6666ccc4b5b571);
+    AS_UL2(&sharedMemory[0x0D4]) = make_ulonglong2(0x05030306d8484890, 0x120e0e1c01f6f6f7);
+    AS_UL2(&sharedMemory[0x0D8]) = make_ulonglong2(0x5f35356aa36161c2, 0xd0b9b969f95757ae);
+    AS_UL2(&sharedMemory[0x0DC]) = make_ulonglong2(0x58c1c19991868617, 0xb99e9e27271d1d3a);
+    break;
+  case 7:
+    AS_UL2(&sharedMemory[0x0E0]) = make_ulonglong2(0x13f8f8eb38e1e1d9, 0x33111122b398982b);
+    AS_UL2(&sharedMemory[0x0E4]) = make_ulonglong2(0x70d9d9a9bb6969d2, 0xa7949433898e8e07);
+    AS_UL2(&sharedMemory[0x0E8]) = make_ulonglong2(0x221e1e3cb69b9b2d, 0x20e9e9c992878715);
+    AS_UL2(&sharedMemory[0x0EC]) = make_ulonglong2(0xff5555aa49cece87, 0x7adfdfa578282850);
+    AS_UL2(&sharedMemory[0x0F0]) = make_ulonglong2(0xf8a1a1598f8c8c03, 0x170d0d1a80898909);
+    AS_UL2(&sharedMemory[0x0F4]) = make_ulonglong2(0x31e6e6d7dabfbf65, 0xb86868d0c6424284);
+    AS_UL2(&sharedMemory[0x0F8]) = make_ulonglong2(0xb0999929c3414182, 0x110f0f1e772d2d5a);
+    AS_UL2(&sharedMemory[0x0FC]) = make_ulonglong2(0xfc5454a8cbb0b07b, 0x3a16162cd6bbbb6d);
+    break;
+  }
+  // AES 1
+  switch (threadIdx.x) {
+  case 0:
+    AS_UL2(&sharedMemory[0x100]) = make_ulonglong2(0x7c7cf8846363c6a5, 0x7b7bf68d7777ee99);
+    AS_UL2(&sharedMemory[0x104]) = make_ulonglong2(0x6b6bd6bdf2f2ff0d, 0xc5c591546f6fdeb1);
+    AS_UL2(&sharedMemory[0x108]) = make_ulonglong2(0x0101020330306050, 0x2b2b567d6767cea9);
+    AS_UL2(&sharedMemory[0x10C]) = make_ulonglong2(0xd7d7b562fefee719, 0x7676ec9aabab4de6);
+    AS_UL2(&sharedMemory[0x110]) = make_ulonglong2(0x82821f9dcaca8f45, 0x7d7dfa87c9c98940);
+    AS_UL2(&sharedMemory[0x114]) = make_ulonglong2(0x5959b2ebfafaef15, 0xf0f0fb0b47478ec9);
+    AS_UL2(&sharedMemory[0x118]) = make_ulonglong2(0xd4d4b367adad41ec, 0xafaf45eaa2a25ffd);
+    AS_UL2(&sharedMemory[0x11C]) = make_ulonglong2(0xa4a453f79c9c23bf, 0xc0c09b5b7272e496);
+    break;
+  case 1:
+    AS_UL2(&sharedMemory[0x120]) = make_ulonglong2(0xfdfde11cb7b775c2, 0x26264c6a93933dae);
+    AS_UL2(&sharedMemory[0x124]) = make_ulonglong2(0x3f3f7e4136366c5a, 0xcccc834ff7f7f502);
+    AS_UL2(&sharedMemory[0x128]) = make_ulonglong2(0xa5a551f43434685c, 0xf1f1f908e5e5d134);
+    AS_UL2(&sharedMemory[0x12C]) = make_ulonglong2(0xd8d8ab737171e293, 0x15152a3f31316253);
+    AS_UL2(&sharedMemory[0x130]) = make_ulonglong2(0xc7c795520404080c, 0xc3c39d5e23234665);
+    AS_UL2(&sharedMemory[0x134]) = make_ulonglong2(0x969637a118183028, 0x9a9a2fb505050a0f);
+    AS_UL2(&sharedMemory[0x138]) = make_ulonglong2(0x1212243607070e09, 0xe2e2df3d80801b9b);
+    AS_UL2(&sharedMemory[0x13C]) = make_ulonglong2(0x27274e69ebebcd26, 0x7575ea9fb2b27fcd);
+    break;
+  case 2:
+    AS_UL2(&sharedMemory[0x140]) = make_ulonglong2(0x83831d9e0909121b, 0x1a1a342e2c2c5874);
+    AS_UL2(&sharedMemory[0x144]) = make_ulonglong2(0x6e6edcb21b1b362d, 0xa0a05bfb5a5ab4ee);
+    AS_UL2(&sharedMemory[0x148]) = make_ulonglong2(0x3b3b764d5252a4f6, 0xb3b37dced6d6b761);
+    AS_UL2(&sharedMemory[0x14C]) = make_ulonglong2(0xe3e3dd3e2929527b, 0x848413972f2f5e71);
+    AS_UL2(&sharedMemory[0x150]) = make_ulonglong2(0xd1d1b9685353a6f5, 0xededc12c00000000);
+    AS_UL2(&sharedMemory[0x154]) = make_ulonglong2(0xfcfce31f20204060, 0x5b5bb6edb1b179c8);
+    AS_UL2(&sharedMemory[0x158]) = make_ulonglong2(0xcbcb8d466a6ad4be, 0x3939724bbebe67d9);
+    AS_UL2(&sharedMemory[0x15C]) = make_ulonglong2(0x4c4c98d44a4a94de, 0xcfcf854a5858b0e8);
+    break;
+  case 3:
+    AS_UL2(&sharedMemory[0x160]) = make_ulonglong2(0xefefc52ad0d0bb6b, 0xfbfbed16aaaa4fe5);
+    AS_UL2(&sharedMemory[0x164]) = make_ulonglong2(0x4d4d9ad7434386c5, 0x8585119433336655);
+    AS_UL2(&sharedMemory[0x168]) = make_ulonglong2(0xf9f9e91045458acf, 0x7f7ffe8102020406);
+    AS_UL2(&sharedMemory[0x16C]) = make_ulonglong2(0x3c3c78445050a0f0, 0xa8a84be39f9f25ba);
+    AS_UL2(&sharedMemory[0x170]) = make_ulonglong2(0xa3a35dfe5151a2f3, 0x8f8f058a404080c0);
+    AS_UL2(&sharedMemory[0x174]) = make_ulonglong2(0x9d9d21bc92923fad, 0xf5f5f10438387048);
+    AS_UL2(&sharedMemory[0x178]) = make_ulonglong2(0xb6b677c1bcbc63df, 0x21214263dadaaf75);
+    AS_UL2(&sharedMemory[0x17C]) = make_ulonglong2(0xffffe51a10102030, 0xd2d2bf6df3f3fd0e);
+    break;
+  case 4:
+    AS_UL2(&sharedMemory[0x180]) = make_ulonglong2(0x0c0c1814cdcd814c, 0xececc32f13132635);
+    AS_UL2(&sharedMemory[0x184]) = make_ulonglong2(0x979735a25f5fbee1, 0x17172e39444488cc);
+    AS_UL2(&sharedMemory[0x188]) = make_ulonglong2(0xa7a755f2c4c49357, 0x3d3d7a477e7efc82);
+    AS_UL2(&sharedMemory[0x18C]) = make_ulonglong2(0x5d5dbae76464c8ac, 0x7373e6951919322b);
+    AS_UL2(&sharedMemory[0x190]) = make_ulonglong2(0x818119986060c0a0, 0xdcdca37f4f4f9ed1);
+    AS_UL2(&sharedMemory[0x194]) = make_ulonglong2(0x2a2a547e22224466, 0x88880b8390903bab);
+    AS_UL2(&sharedMemory[0x198]) = make_ulonglong2(0xeeeec72946468cca, 0x1414283cb8b86bd3);
+    AS_UL2(&sharedMemory[0x19C]) = make_ulonglong2(0x5e5ebce2dedea779, 0xdbdbad760b0b161d);
+    break;
+  case 5:
+    AS_UL2(&sharedMemory[0x1A0]) = make_ulonglong2(0x32326456e0e0db3b, 0x0a0a141e3a3a744e);
+    AS_UL2(&sharedMemory[0x1A4]) = make_ulonglong2(0x06060c0a494992db, 0x5c5cb8e42424486c);
+    AS_UL2(&sharedMemory[0x1A8]) = make_ulonglong2(0xd3d3bd6ec2c29f5d, 0x6262c4a6acac43ef);
+    AS_UL2(&sharedMemory[0x1AC]) = make_ulonglong2(0x959531a4919139a8, 0x7979f28be4e4d337);
+    AS_UL2(&sharedMemory[0x1B0]) = make_ulonglong2(0xc8c88b43e7e7d532, 0x6d6ddab737376e59);
+    AS_UL2(&sharedMemory[0x1B4]) = make_ulonglong2(0xd5d5b1648d8d018c, 0xa9a949e04e4e9cd2);
+    AS_UL2(&sharedMemory[0x1B8]) = make_ulonglong2(0x5656acfa6c6cd8b4, 0xeaeacf25f4f4f307);
+    AS_UL2(&sharedMemory[0x1BC]) = make_ulonglong2(0x7a7af48e6565caaf, 0x08081018aeae47e9);
+    break;
+  case 6:
+    AS_UL2(&sharedMemory[0x1C0]) = make_ulonglong2(0x7878f088baba6fd5, 0x2e2e5c7225254a6f);
+    AS_UL2(&sharedMemory[0x1C4]) = make_ulonglong2(0xa6a657f11c1c3824, 0xc6c69751b4b473c7);
+    AS_UL2(&sharedMemory[0x1C8]) = make_ulonglong2(0xdddda17ce8e8cb23, 0x1f1f3e217474e89c);
+    AS_UL2(&sharedMemory[0x1CC]) = make_ulonglong2(0xbdbd61dc4b4b96dd, 0x8a8a0f858b8b0d86);
+    AS_UL2(&sharedMemory[0x1D0]) = make_ulonglong2(0x3e3e7c427070e090, 0x6666ccaab5b571c4);
+    AS_UL2(&sharedMemory[0x1D4]) = make_ulonglong2(0x03030605484890d8, 0x0e0e1c12f6f6f701);
+    AS_UL2(&sharedMemory[0x1D8]) = make_ulonglong2(0x35356a5f6161c2a3, 0xb9b969d05757aef9);
+    AS_UL2(&sharedMemory[0x1DC]) = make_ulonglong2(0xc1c1995886861791, 0x9e9e27b91d1d3a27);
+    break;
+  case 7:
+    AS_UL2(&sharedMemory[0x1E0]) = make_ulonglong2(0xf8f8eb13e1e1d938, 0x1111223398982bb3);
+    AS_UL2(&sharedMemory[0x1E4]) = make_ulonglong2(0xd9d9a9706969d2bb, 0x949433a78e8e0789);
+    AS_UL2(&sharedMemory[0x1E8]) = make_ulonglong2(0x1e1e3c229b9b2db6, 0xe9e9c92087871592);
+    AS_UL2(&sharedMemory[0x1EC]) = make_ulonglong2(0x5555aaffcece8749, 0xdfdfa57a28285078);
+    AS_UL2(&sharedMemory[0x1F0]) = make_ulonglong2(0xa1a159f88c8c038f, 0x0d0d1a1789890980);
+    AS_UL2(&sharedMemory[0x1F4]) = make_ulonglong2(0xe6e6d731bfbf65da, 0x6868d0b8424284c6);
+    AS_UL2(&sharedMemory[0x1F8]) = make_ulonglong2(0x999929b0414182c3, 0x0f0f1e112d2d5a77);
+    AS_UL2(&sharedMemory[0x1FC]) = make_ulonglong2(0x5454a8fcb0b07bcb, 0x16162c3abbbb6dd6);
+    break;
+  }
+  // AES 2
+  switch (threadIdx.x) {
+  case 0:
+    AS_UL2(&sharedMemory[0x200]) = make_ulonglong2(0x7cf8847c63c6a563, 0x7bf68d7b77ee9977);
+    AS_UL2(&sharedMemory[0x204]) = make_ulonglong2(0x6bd6bd6bf2ff0df2, 0xc59154c56fdeb16f);
+    AS_UL2(&sharedMemory[0x208]) = make_ulonglong2(0x0102030130605030, 0x2b567d2b67cea967);
+    AS_UL2(&sharedMemory[0x20C]) = make_ulonglong2(0xd7b562d7fee719fe, 0x76ec9a76ab4de6ab);
+    AS_UL2(&sharedMemory[0x210]) = make_ulonglong2(0x821f9d82ca8f45ca, 0x7dfa877dc98940c9);
+    AS_UL2(&sharedMemory[0x214]) = make_ulonglong2(0x59b2eb59faef15fa, 0xf0fb0bf0478ec947);
+    AS_UL2(&sharedMemory[0x218]) = make_ulonglong2(0xd4b367d4ad41ecad, 0xaf45eaafa25ffda2);
+    AS_UL2(&sharedMemory[0x21C]) = make_ulonglong2(0xa453f7a49c23bf9c, 0xc09b5bc072e49672);
+    break;
+  case 1:
+    AS_UL2(&sharedMemory[0x220]) = make_ulonglong2(0xfde11cfdb775c2b7, 0x264c6a26933dae93);
+    AS_UL2(&sharedMemory[0x224]) = make_ulonglong2(0x3f7e413f366c5a36, 0xcc834fccf7f502f7);
+    AS_UL2(&sharedMemory[0x228]) = make_ulonglong2(0xa551f4a534685c34, 0xf1f908f1e5d134e5);
+    AS_UL2(&sharedMemory[0x22C]) = make_ulonglong2(0xd8ab73d871e29371, 0x152a3f1531625331);
+    AS_UL2(&sharedMemory[0x230]) = make_ulonglong2(0xc79552c704080c04, 0xc39d5ec323466523);
+    AS_UL2(&sharedMemory[0x234]) = make_ulonglong2(0x9637a19618302818, 0x9a2fb59a050a0f05);
+    AS_UL2(&sharedMemory[0x238]) = make_ulonglong2(0x12243612070e0907, 0xe2df3de2801b9b80);
+    AS_UL2(&sharedMemory[0x23C]) = make_ulonglong2(0x274e6927ebcd26eb, 0x75ea9f75b27fcdb2);
+    break;
+  case 2:
+    AS_UL2(&sharedMemory[0x240]) = make_ulonglong2(0x831d9e8309121b09, 0x1a342e1a2c58742c);
+    AS_UL2(&sharedMemory[0x244]) = make_ulonglong2(0x6edcb26e1b362d1b, 0xa05bfba05ab4ee5a);
+    AS_UL2(&sharedMemory[0x248]) = make_ulonglong2(0x3b764d3b52a4f652, 0xb37dceb3d6b761d6);
+    AS_UL2(&sharedMemory[0x24C]) = make_ulonglong2(0xe3dd3ee329527b29, 0x841397842f5e712f);
+    AS_UL2(&sharedMemory[0x250]) = make_ulonglong2(0xd1b968d153a6f553, 0xedc12ced00000000);
+    AS_UL2(&sharedMemory[0x254]) = make_ulonglong2(0xfce31ffc20406020, 0x5bb6ed5bb179c8b1);
+    AS_UL2(&sharedMemory[0x258]) = make_ulonglong2(0xcb8d46cb6ad4be6a, 0x39724b39be67d9be);
+    AS_UL2(&sharedMemory[0x25C]) = make_ulonglong2(0x4c98d44c4a94de4a, 0xcf854acf58b0e858);
+    break;
+  case 3:
+    AS_UL2(&sharedMemory[0x260]) = make_ulonglong2(0xefc52aefd0bb6bd0, 0xfbed16fbaa4fe5aa);
+    AS_UL2(&sharedMemory[0x264]) = make_ulonglong2(0x4d9ad74d4386c543, 0x8511948533665533);
+    AS_UL2(&sharedMemory[0x268]) = make_ulonglong2(0xf9e910f9458acf45, 0x7ffe817f02040602);
+    AS_UL2(&sharedMemory[0x26C]) = make_ulonglong2(0x3c78443c50a0f050, 0xa84be3a89f25ba9f);
+    AS_UL2(&sharedMemory[0x270]) = make_ulonglong2(0xa35dfea351a2f351, 0x8f058a8f4080c040);
+    AS_UL2(&sharedMemory[0x274]) = make_ulonglong2(0x9d21bc9d923fad92, 0xf5f104f538704838);
+    AS_UL2(&sharedMemory[0x278]) = make_ulonglong2(0xb677c1b6bc63dfbc, 0x21426321daaf75da);
+    AS_UL2(&sharedMemory[0x27C]) = make_ulonglong2(0xffe51aff10203010, 0xd2bf6dd2f3fd0ef3);
+    break;
+  case 4:
+    AS_UL2(&sharedMemory[0x280]) = make_ulonglong2(0x0c18140ccd814ccd, 0xecc32fec13263513);
+    AS_UL2(&sharedMemory[0x284]) = make_ulonglong2(0x9735a2975fbee15f, 0x172e39174488cc44);
+    AS_UL2(&sharedMemory[0x288]) = make_ulonglong2(0xa755f2a7c49357c4, 0x3d7a473d7efc827e);
+    AS_UL2(&sharedMemory[0x28C]) = make_ulonglong2(0x5dbae75d64c8ac64, 0x73e6957319322b19);
+    AS_UL2(&sharedMemory[0x290]) = make_ulonglong2(0x8119988160c0a060, 0xdca37fdc4f9ed14f);
+    AS_UL2(&sharedMemory[0x294]) = make_ulonglong2(0x2a547e2a22446622, 0x880b8388903bab90);
+    AS_UL2(&sharedMemory[0x298]) = make_ulonglong2(0xeec729ee468cca46, 0x14283c14b86bd3b8);
+    AS_UL2(&sharedMemory[0x29C]) = make_ulonglong2(0x5ebce25edea779de, 0xdbad76db0b161d0b);
+    break;
+  case 5:
+    AS_UL2(&sharedMemory[0x2A0]) = make_ulonglong2(0x32645632e0db3be0, 0x0a141e0a3a744e3a);
+    AS_UL2(&sharedMemory[0x2A4]) = make_ulonglong2(0x060c0a064992db49, 0x5cb8e45c24486c24);
+    AS_UL2(&sharedMemory[0x2A8]) = make_ulonglong2(0xd3bd6ed3c29f5dc2, 0x62c4a662ac43efac);
+    AS_UL2(&sharedMemory[0x2AC]) = make_ulonglong2(0x9531a4959139a891, 0x79f28b79e4d337e4);
+    AS_UL2(&sharedMemory[0x2B0]) = make_ulonglong2(0xc88b43c8e7d532e7, 0x6ddab76d376e5937);
+    AS_UL2(&sharedMemory[0x2B4]) = make_ulonglong2(0xd5b164d58d018c8d, 0xa949e0a94e9cd24e);
+    AS_UL2(&sharedMemory[0x2B8]) = make_ulonglong2(0x56acfa566cd8b46c, 0xeacf25eaf4f307f4);
+    AS_UL2(&sharedMemory[0x2BC]) = make_ulonglong2(0x7af48e7a65caaf65, 0x08101808ae47e9ae);
+    break;
+  case 6:
+    AS_UL2(&sharedMemory[0x2C0]) = make_ulonglong2(0x78f08878ba6fd5ba, 0x2e5c722e254a6f25);
+    AS_UL2(&sharedMemory[0x2C4]) = make_ulonglong2(0xa657f1a61c38241c, 0xc69751c6b473c7b4);
+    AS_UL2(&sharedMemory[0x2C8]) = make_ulonglong2(0xdda17cdde8cb23e8, 0x1f3e211f74e89c74);
+    AS_UL2(&sharedMemory[0x2CC]) = make_ulonglong2(0xbd61dcbd4b96dd4b, 0x8a0f858a8b0d868b);
+    AS_UL2(&sharedMemory[0x2D0]) = make_ulonglong2(0x3e7c423e70e09070, 0x66ccaa66b571c4b5);
+    AS_UL2(&sharedMemory[0x2D4]) = make_ulonglong2(0x030605034890d848, 0x0e1c120ef6f701f6);
+    AS_UL2(&sharedMemory[0x2D8]) = make_ulonglong2(0x356a5f3561c2a361, 0xb969d0b957aef957);
+    AS_UL2(&sharedMemory[0x2DC]) = make_ulonglong2(0xc19958c186179186, 0x9e27b99e1d3a271d);
+    break;
+  case 7:
+    AS_UL2(&sharedMemory[0x2E0]) = make_ulonglong2(0xf8eb13f8e1d938e1, 0x11223311982bb398);
+    AS_UL2(&sharedMemory[0x2E4]) = make_ulonglong2(0xd9a970d969d2bb69, 0x9433a7948e07898e);
+    AS_UL2(&sharedMemory[0x2E8]) = make_ulonglong2(0x1e3c221e9b2db69b, 0xe9c920e987159287);
+    AS_UL2(&sharedMemory[0x2EC]) = make_ulonglong2(0x55aaff55ce8749ce, 0xdfa57adf28507828);
+    AS_UL2(&sharedMemory[0x2F0]) = make_ulonglong2(0xa159f8a18c038f8c, 0x0d1a170d89098089);
+    AS_UL2(&sharedMemory[0x2F4]) = make_ulonglong2(0xe6d731e6bf65dabf, 0x68d0b8684284c642);
+    AS_UL2(&sharedMemory[0x2F8]) = make_ulonglong2(0x9929b0994182c341, 0x0f1e110f2d5a772d);
+    AS_UL2(&sharedMemory[0x2FC]) = make_ulonglong2(0x54a8fc54b07bcbb0, 0x162c3a16bb6dd6bb);
+    break;
+  }
+  // AES 3
+  switch (threadIdx.x) {
+  case 0:
+    AS_UL2(&sharedMemory[0x300]) = make_ulonglong2(0xf8847c7cc6a56363, 0xf68d7b7bee997777);
+    AS_UL2(&sharedMemory[0x304]) = make_ulonglong2(0xd6bd6b6bff0df2f2, 0x9154c5c5deb16f6f);
+    AS_UL2(&sharedMemory[0x308]) = make_ulonglong2(0x0203010160503030, 0x567d2b2bcea96767);
+    AS_UL2(&sharedMemory[0x30C]) = make_ulonglong2(0xb562d7d7e719fefe, 0xec9a76764de6abab);
+    AS_UL2(&sharedMemory[0x310]) = make_ulonglong2(0x1f9d82828f45caca, 0xfa877d7d8940c9c9);
+    AS_UL2(&sharedMemory[0x314]) = make_ulonglong2(0xb2eb5959ef15fafa, 0xfb0bf0f08ec94747);
+    AS_UL2(&sharedMemory[0x318]) = make_ulonglong2(0xb367d4d441ecadad, 0x45eaafaf5ffda2a2);
+    AS_UL2(&sharedMemory[0x31C]) = make_ulonglong2(0x53f7a4a423bf9c9c, 0x9b5bc0c0e4967272);
+    break;
+  case 1:
+    AS_UL2(&sharedMemory[0x320]) = make_ulonglong2(0xe11cfdfd75c2b7b7, 0x4c6a26263dae9393);
+    AS_UL2(&sharedMemory[0x324]) = make_ulonglong2(0x7e413f3f6c5a3636, 0x834fccccf502f7f7);
+    AS_UL2(&sharedMemory[0x328]) = make_ulonglong2(0x51f4a5a5685c3434, 0xf908f1f1d134e5e5);
+    AS_UL2(&sharedMemory[0x32C]) = make_ulonglong2(0xab73d8d8e2937171, 0x2a3f151562533131);
+    AS_UL2(&sharedMemory[0x330]) = make_ulonglong2(0x9552c7c7080c0404, 0x9d5ec3c346652323);
+    AS_UL2(&sharedMemory[0x334]) = make_ulonglong2(0x37a1969630281818, 0x2fb59a9a0a0f0505);
+    AS_UL2(&sharedMemory[0x338]) = make_ulonglong2(0x243612120e090707, 0xdf3de2e21b9b8080);
+    AS_UL2(&sharedMemory[0x33C]) = make_ulonglong2(0x4e692727cd26ebeb, 0xea9f75757fcdb2b2);
+    break;
+  case 2:
+    AS_UL2(&sharedMemory[0x340]) = make_ulonglong2(0x1d9e8383121b0909, 0x342e1a1a58742c2c);
+    AS_UL2(&sharedMemory[0x344]) = make_ulonglong2(0xdcb26e6e362d1b1b, 0x5bfba0a0b4ee5a5a);
+    AS_UL2(&sharedMemory[0x348]) = make_ulonglong2(0x764d3b3ba4f65252, 0x7dceb3b3b761d6d6);
+    AS_UL2(&sharedMemory[0x34C]) = make_ulonglong2(0xdd3ee3e3527b2929, 0x139784845e712f2f);
+    AS_UL2(&sharedMemory[0x350]) = make_ulonglong2(0xb968d1d1a6f55353, 0xc12ceded00000000);
+    AS_UL2(&sharedMemory[0x354]) = make_ulonglong2(0xe31ffcfc40602020, 0xb6ed5b5b79c8b1b1);
+    AS_UL2(&sharedMemory[0x358]) = make_ulonglong2(0x8d46cbcbd4be6a6a, 0x724b393967d9bebe);
+    AS_UL2(&sharedMemory[0x35C]) = make_ulonglong2(0x98d44c4c94de4a4a, 0x854acfcfb0e85858);
+    break;
+  case 3:
+    AS_UL2(&sharedMemory[0x360]) = make_ulonglong2(0xc52aefefbb6bd0d0, 0xed16fbfb4fe5aaaa);
+    AS_UL2(&sharedMemory[0x364]) = make_ulonglong2(0x9ad74d4d86c54343, 0x1194858566553333);
+    AS_UL2(&sharedMemory[0x368]) = make_ulonglong2(0xe910f9f98acf4545, 0xfe817f7f04060202);
+    AS_UL2(&sharedMemory[0x36C]) = make_ulonglong2(0x78443c3ca0f05050, 0x4be3a8a825ba9f9f);
+    AS_UL2(&sharedMemory[0x370]) = make_ulonglong2(0x5dfea3a3a2f35151, 0x058a8f8f80c04040);
+    AS_UL2(&sharedMemory[0x374]) = make_ulonglong2(0x21bc9d9d3fad9292, 0xf104f5f570483838);
+    AS_UL2(&sharedMemory[0x378]) = make_ulonglong2(0x77c1b6b663dfbcbc, 0x42632121af75dada);
+    AS_UL2(&sharedMemory[0x37C]) = make_ulonglong2(0xe51affff20301010, 0xbf6dd2d2fd0ef3f3);
+    break;
+  case 4:
+    AS_UL2(&sharedMemory[0x380]) = make_ulonglong2(0x18140c0c814ccdcd, 0xc32fecec26351313);
+    AS_UL2(&sharedMemory[0x384]) = make_ulonglong2(0x35a29797bee15f5f, 0x2e39171788cc4444);
+    AS_UL2(&sharedMemory[0x388]) = make_ulonglong2(0x55f2a7a79357c4c4, 0x7a473d3dfc827e7e);
+    AS_UL2(&sharedMemory[0x38C]) = make_ulonglong2(0xbae75d5dc8ac6464, 0xe6957373322b1919);
+    AS_UL2(&sharedMemory[0x390]) = make_ulonglong2(0x19988181c0a06060, 0xa37fdcdc9ed14f4f);
+    AS_UL2(&sharedMemory[0x394]) = make_ulonglong2(0x547e2a2a44662222, 0x0b8388883bab9090);
+    AS_UL2(&sharedMemory[0x398]) = make_ulonglong2(0xc729eeee8cca4646, 0x283c14146bd3b8b8);
+    AS_UL2(&sharedMemory[0x39C]) = make_ulonglong2(0xbce25e5ea779dede, 0xad76dbdb161d0b0b);
+    break;
+  case 5:
+    AS_UL2(&sharedMemory[0x3A0]) = make_ulonglong2(0x64563232db3be0e0, 0x141e0a0a744e3a3a);
+    AS_UL2(&sharedMemory[0x3A4]) = make_ulonglong2(0x0c0a060692db4949, 0xb8e45c5c486c2424);
+    AS_UL2(&sharedMemory[0x3A8]) = make_ulonglong2(0xbd6ed3d39f5dc2c2, 0xc4a6626243efacac);
+    AS_UL2(&sharedMemory[0x3AC]) = make_ulonglong2(0x31a4959539a89191, 0xf28b7979d337e4e4);
+    AS_UL2(&sharedMemory[0x3B0]) = make_ulonglong2(0x8b43c8c8d532e7e7, 0xdab76d6d6e593737);
+    AS_UL2(&sharedMemory[0x3B4]) = make_ulonglong2(0xb164d5d5018c8d8d, 0x49e0a9a99cd24e4e);
+    AS_UL2(&sharedMemory[0x3B8]) = make_ulonglong2(0xacfa5656d8b46c6c, 0xcf25eaeaf307f4f4);
+    AS_UL2(&sharedMemory[0x3BC]) = make_ulonglong2(0xf48e7a7acaaf6565, 0x1018080847e9aeae);
+    break;
+  case 6:
+    AS_UL2(&sharedMemory[0x3C0]) = make_ulonglong2(0xf08878786fd5baba, 0x5c722e2e4a6f2525);
+    AS_UL2(&sharedMemory[0x3C4]) = make_ulonglong2(0x57f1a6a638241c1c, 0x9751c6c673c7b4b4);
+    AS_UL2(&sharedMemory[0x3C8]) = make_ulonglong2(0xa17cddddcb23e8e8, 0x3e211f1fe89c7474);
+    AS_UL2(&sharedMemory[0x3CC]) = make_ulonglong2(0x61dcbdbd96dd4b4b, 0x0f858a8a0d868b8b);
+    AS_UL2(&sharedMemory[0x3D0]) = make_ulonglong2(0x7c423e3ee0907070, 0xccaa666671c4b5b5);
+    AS_UL2(&sharedMemory[0x3D4]) = make_ulonglong2(0x0605030390d84848, 0x1c120e0ef701f6f6);
+    AS_UL2(&sharedMemory[0x3D8]) = make_ulonglong2(0x6a5f3535c2a36161, 0x69d0b9b9aef95757);
+    AS_UL2(&sharedMemory[0x3DC]) = make_ulonglong2(0x9958c1c117918686, 0x27b99e9e3a271d1d);
+    break;
+  case 7:
+    AS_UL2(&sharedMemory[0x3E0]) = make_ulonglong2(0xeb13f8f8d938e1e1, 0x223311112bb39898);
+    AS_UL2(&sharedMemory[0x3E4]) = make_ulonglong2(0xa970d9d9d2bb6969, 0x33a7949407898e8e);
+    AS_UL2(&sharedMemory[0x3E8]) = make_ulonglong2(0x3c221e1e2db69b9b, 0xc920e9e915928787);
+    AS_UL2(&sharedMemory[0x3EC]) = make_ulonglong2(0xaaff55558749cece, 0xa57adfdf50782828);
+    AS_UL2(&sharedMemory[0x3F0]) = make_ulonglong2(0x59f8a1a1038f8c8c, 0x1a170d0d09808989);
+    AS_UL2(&sharedMemory[0x3F4]) = make_ulonglong2(0xd731e6e665dabfbf, 0xd0b8686884c64242);
+    AS_UL2(&sharedMemory[0x3F8]) = make_ulonglong2(0x29b0999982c34141, 0x1e110f0f5a772d2d);
+    AS_UL2(&sharedMemory[0x3FC]) = make_ulonglong2(0xa8fc54547bcbb0b0, 0x2c3a16166dd6bbbb);
+    break;
+  }
+}
+
+__device__ __forceinline__
+void cn_aes_gpu_init_u4(uint32_t* sharedMemory)
+{
+  // AES 0
+  switch (threadIdx.x) {
+  case 0:
+    AS_UINT4(&sharedMemory[0x000]) = make_uint4(0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6);
+    AS_UINT4(&sharedMemory[0x004]) = make_uint4(0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591);
+    AS_UINT4(&sharedMemory[0x008]) = make_uint4(0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56);
+    AS_UINT4(&sharedMemory[0x00C]) = make_uint4(0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec);
+    AS_UINT4(&sharedMemory[0x010]) = make_uint4(0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa);
+    AS_UINT4(&sharedMemory[0x014]) = make_uint4(0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb);
+    AS_UINT4(&sharedMemory[0x018]) = make_uint4(0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45);
+    AS_UINT4(&sharedMemory[0x01C]) = make_uint4(0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b);
+    break;
+  case 1:
+    AS_UINT4(&sharedMemory[0x020]) = make_uint4(0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c);
+    AS_UINT4(&sharedMemory[0x024]) = make_uint4(0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83);
+    AS_UINT4(&sharedMemory[0x028]) = make_uint4(0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9);
+    AS_UINT4(&sharedMemory[0x02C]) = make_uint4(0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a);
+    AS_UINT4(&sharedMemory[0x030]) = make_uint4(0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d);
+    AS_UINT4(&sharedMemory[0x034]) = make_uint4(0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f);
+    AS_UINT4(&sharedMemory[0x038]) = make_uint4(0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df);
+    AS_UINT4(&sharedMemory[0x03C]) = make_uint4(0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea);
+    break;
+  case 2:
+    AS_UINT4(&sharedMemory[0x040]) = make_uint4(0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34);
+    AS_UINT4(&sharedMemory[0x044]) = make_uint4(0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b);
+    AS_UINT4(&sharedMemory[0x048]) = make_uint4(0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d);
+    AS_UINT4(&sharedMemory[0x04C]) = make_uint4(0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413);
+    AS_UINT4(&sharedMemory[0x050]) = make_uint4(0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1);
+    AS_UINT4(&sharedMemory[0x054]) = make_uint4(0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6);
+    AS_UINT4(&sharedMemory[0x058]) = make_uint4(0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972);
+    AS_UINT4(&sharedMemory[0x05C]) = make_uint4(0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85);
+    break;
+  case 3:
+    AS_UINT4(&sharedMemory[0x060]) = make_uint4(0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed);
+    AS_UINT4(&sharedMemory[0x064]) = make_uint4(0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511);
+    AS_UINT4(&sharedMemory[0x068]) = make_uint4(0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe);
+    AS_UINT4(&sharedMemory[0x06C]) = make_uint4(0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b);
+    AS_UINT4(&sharedMemory[0x070]) = make_uint4(0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05);
+    AS_UINT4(&sharedMemory[0x074]) = make_uint4(0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1);
+    AS_UINT4(&sharedMemory[0x078]) = make_uint4(0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142);
+    AS_UINT4(&sharedMemory[0x07C]) = make_uint4(0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf);
+    break;
+  case 4:
+    AS_UINT4(&sharedMemory[0x080]) = make_uint4(0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3);
+    AS_UINT4(&sharedMemory[0x084]) = make_uint4(0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e);
+    AS_UINT4(&sharedMemory[0x088]) = make_uint4(0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a);
+    AS_UINT4(&sharedMemory[0x08C]) = make_uint4(0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6);
+    AS_UINT4(&sharedMemory[0x090]) = make_uint4(0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3);
+    AS_UINT4(&sharedMemory[0x094]) = make_uint4(0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b);
+    AS_UINT4(&sharedMemory[0x098]) = make_uint4(0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428);
+    AS_UINT4(&sharedMemory[0x09C]) = make_uint4(0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad);
+    break;
+  case 5:
+    AS_UINT4(&sharedMemory[0x0A0]) = make_uint4(0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14);
+    AS_UINT4(&sharedMemory[0x0A4]) = make_uint4(0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8);
+    AS_UINT4(&sharedMemory[0x0A8]) = make_uint4(0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4);
+    AS_UINT4(&sharedMemory[0x0AC]) = make_uint4(0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2);
+    AS_UINT4(&sharedMemory[0x0B0]) = make_uint4(0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda);
+    AS_UINT4(&sharedMemory[0x0B4]) = make_uint4(0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949);
+    AS_UINT4(&sharedMemory[0x0B8]) = make_uint4(0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf);
+    AS_UINT4(&sharedMemory[0x0BC]) = make_uint4(0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810);
+    break;
+  case 6:
+    AS_UINT4(&sharedMemory[0x0C0]) = make_uint4(0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c);
+    AS_UINT4(&sharedMemory[0x0C4]) = make_uint4(0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697);
+    AS_UINT4(&sharedMemory[0x0C8]) = make_uint4(0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e);
+    AS_UINT4(&sharedMemory[0x0CC]) = make_uint4(0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f);
+    AS_UINT4(&sharedMemory[0x0D0]) = make_uint4(0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc);
+    AS_UINT4(&sharedMemory[0x0D4]) = make_uint4(0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c);
+    AS_UINT4(&sharedMemory[0x0D8]) = make_uint4(0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969);
+    AS_UINT4(&sharedMemory[0x0DC]) = make_uint4(0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27);
+    break;
+  case 7:
+    AS_UINT4(&sharedMemory[0x0E0]) = make_uint4(0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122);
+    AS_UINT4(&sharedMemory[0x0E4]) = make_uint4(0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433);
+    AS_UINT4(&sharedMemory[0x0E8]) = make_uint4(0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9);
+    AS_UINT4(&sharedMemory[0x0EC]) = make_uint4(0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5);
+    AS_UINT4(&sharedMemory[0x0F0]) = make_uint4(0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a);
+    AS_UINT4(&sharedMemory[0x0F4]) = make_uint4(0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0);
+    AS_UINT4(&sharedMemory[0x0F8]) = make_uint4(0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e);
+    AS_UINT4(&sharedMemory[0x0FC]) = make_uint4(0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c);
+    break;
+  }
+  // AES 1
+  switch (threadIdx.x) {
+  case 0:
+    AS_UINT4(&sharedMemory[0x100]) = make_uint4(0x6363c6a5, 0x7c7cf884, 0x7777ee99, 0x7b7bf68d);
+    AS_UINT4(&sharedMemory[0x104]) = make_uint4(0xf2f2ff0d, 0x6b6bd6bd, 0x6f6fdeb1, 0xc5c59154);
+    AS_UINT4(&sharedMemory[0x108]) = make_uint4(0x30306050, 0x01010203, 0x6767cea9, 0x2b2b567d);
+    AS_UINT4(&sharedMemory[0x10C]) = make_uint4(0xfefee719, 0xd7d7b562, 0xabab4de6, 0x7676ec9a);
+    AS_UINT4(&sharedMemory[0x110]) = make_uint4(0xcaca8f45, 0x82821f9d, 0xc9c98940, 0x7d7dfa87);
+    AS_UINT4(&sharedMemory[0x114]) = make_uint4(0xfafaef15, 0x5959b2eb, 0x47478ec9, 0xf0f0fb0b);
+    AS_UINT4(&sharedMemory[0x118]) = make_uint4(0xadad41ec, 0xd4d4b367, 0xa2a25ffd, 0xafaf45ea);
+    AS_UINT4(&sharedMemory[0x11C]) = make_uint4(0x9c9c23bf, 0xa4a453f7, 0x7272e496, 0xc0c09b5b);
+    break;
+  case 1:
+    AS_UINT4(&sharedMemory[0x120]) = make_uint4(0xb7b775c2, 0xfdfde11c, 0x93933dae, 0x26264c6a);
+    AS_UINT4(&sharedMemory[0x124]) = make_uint4(0x36366c5a, 0x3f3f7e41, 0xf7f7f502, 0xcccc834f);
+    AS_UINT4(&sharedMemory[0x128]) = make_uint4(0x3434685c, 0xa5a551f4, 0xe5e5d134, 0xf1f1f908);
+    AS_UINT4(&sharedMemory[0x12C]) = make_uint4(0x7171e293, 0xd8d8ab73, 0x31316253, 0x15152a3f);
+    AS_UINT4(&sharedMemory[0x130]) = make_uint4(0x0404080c, 0xc7c79552, 0x23234665, 0xc3c39d5e);
+    AS_UINT4(&sharedMemory[0x134]) = make_uint4(0x18183028, 0x969637a1, 0x05050a0f, 0x9a9a2fb5);
+    AS_UINT4(&sharedMemory[0x138]) = make_uint4(0x07070e09, 0x12122436, 0x80801b9b, 0xe2e2df3d);
+    AS_UINT4(&sharedMemory[0x13C]) = make_uint4(0xebebcd26, 0x27274e69, 0xb2b27fcd, 0x7575ea9f);
+    break;
+  case 2:
+    AS_UINT4(&sharedMemory[0x140]) = make_uint4(0x0909121b, 0x83831d9e, 0x2c2c5874, 0x1a1a342e);
+    AS_UINT4(&sharedMemory[0x144]) = make_uint4(0x1b1b362d, 0x6e6edcb2, 0x5a5ab4ee, 0xa0a05bfb);
+    AS_UINT4(&sharedMemory[0x148]) = make_uint4(0x5252a4f6, 0x3b3b764d, 0xd6d6b761, 0xb3b37dce);
+    AS_UINT4(&sharedMemory[0x14C]) = make_uint4(0x2929527b, 0xe3e3dd3e, 0x2f2f5e71, 0x84841397);
+    AS_UINT4(&sharedMemory[0x150]) = make_uint4(0x5353a6f5, 0xd1d1b968, 0x00000000, 0xededc12c);
+    AS_UINT4(&sharedMemory[0x154]) = make_uint4(0x20204060, 0xfcfce31f, 0xb1b179c8, 0x5b5bb6ed);
+    AS_UINT4(&sharedMemory[0x158]) = make_uint4(0x6a6ad4be, 0xcbcb8d46, 0xbebe67d9, 0x3939724b);
+    AS_UINT4(&sharedMemory[0x15C]) = make_uint4(0x4a4a94de, 0x4c4c98d4, 0x5858b0e8, 0xcfcf854a);
+    break;
+  case 3:
+    AS_UINT4(&sharedMemory[0x160]) = make_uint4(0xd0d0bb6b, 0xefefc52a, 0xaaaa4fe5, 0xfbfbed16);
+    AS_UINT4(&sharedMemory[0x164]) = make_uint4(0x434386c5, 0x4d4d9ad7, 0x33336655, 0x85851194);
+    AS_UINT4(&sharedMemory[0x168]) = make_uint4(0x45458acf, 0xf9f9e910, 0x02020406, 0x7f7ffe81);
+    AS_UINT4(&sharedMemory[0x16C]) = make_uint4(0x5050a0f0, 0x3c3c7844, 0x9f9f25ba, 0xa8a84be3);
+    AS_UINT4(&sharedMemory[0x170]) = make_uint4(0x5151a2f3, 0xa3a35dfe, 0x404080c0, 0x8f8f058a);
+    AS_UINT4(&sharedMemory[0x174]) = make_uint4(0x92923fad, 0x9d9d21bc, 0x38387048, 0xf5f5f104);
+    AS_UINT4(&sharedMemory[0x178]) = make_uint4(0xbcbc63df, 0xb6b677c1, 0xdadaaf75, 0x21214263);
+    AS_UINT4(&sharedMemory[0x17C]) = make_uint4(0x10102030, 0xffffe51a, 0xf3f3fd0e, 0xd2d2bf6d);
+    break;
+  case 4:
+    AS_UINT4(&sharedMemory[0x180]) = make_uint4(0xcdcd814c, 0x0c0c1814, 0x13132635, 0xececc32f);
+    AS_UINT4(&sharedMemory[0x184]) = make_uint4(0x5f5fbee1, 0x979735a2, 0x444488cc, 0x17172e39);
+    AS_UINT4(&sharedMemory[0x188]) = make_uint4(0xc4c49357, 0xa7a755f2, 0x7e7efc82, 0x3d3d7a47);
+    AS_UINT4(&sharedMemory[0x18C]) = make_uint4(0x6464c8ac, 0x5d5dbae7, 0x1919322b, 0x7373e695);
+    AS_UINT4(&sharedMemory[0x190]) = make_uint4(0x6060c0a0, 0x81811998, 0x4f4f9ed1, 0xdcdca37f);
+    AS_UINT4(&sharedMemory[0x194]) = make_uint4(0x22224466, 0x2a2a547e, 0x90903bab, 0x88880b83);
+    AS_UINT4(&sharedMemory[0x198]) = make_uint4(0x46468cca, 0xeeeec729, 0xb8b86bd3, 0x1414283c);
+    AS_UINT4(&sharedMemory[0x19C]) = make_uint4(0xdedea779, 0x5e5ebce2, 0x0b0b161d, 0xdbdbad76);
+    break;
+  case 5:
+    AS_UINT4(&sharedMemory[0x1A0]) = make_uint4(0xe0e0db3b, 0x32326456, 0x3a3a744e, 0x0a0a141e);
+    AS_UINT4(&sharedMemory[0x1A4]) = make_uint4(0x494992db, 0x06060c0a, 0x2424486c, 0x5c5cb8e4);
+    AS_UINT4(&sharedMemory[0x1A8]) = make_uint4(0xc2c29f5d, 0xd3d3bd6e, 0xacac43ef, 0x6262c4a6);
+    AS_UINT4(&sharedMemory[0x1AC]) = make_uint4(0x919139a8, 0x959531a4, 0xe4e4d337, 0x7979f28b);
+    AS_UINT4(&sharedMemory[0x1B0]) = make_uint4(0xe7e7d532, 0xc8c88b43, 0x37376e59, 0x6d6ddab7);
+    AS_UINT4(&sharedMemory[0x1B4]) = make_uint4(0x8d8d018c, 0xd5d5b164, 0x4e4e9cd2, 0xa9a949e0);
+    AS_UINT4(&sharedMemory[0x1B8]) = make_uint4(0x6c6cd8b4, 0x5656acfa, 0xf4f4f307, 0xeaeacf25);
+    AS_UINT4(&sharedMemory[0x1BC]) = make_uint4(0x6565caaf, 0x7a7af48e, 0xaeae47e9, 0x08081018);
+    break;
+  case 6:
+    AS_UINT4(&sharedMemory[0x1C0]) = make_uint4(0xbaba6fd5, 0x7878f088, 0x25254a6f, 0x2e2e5c72);
+    AS_UINT4(&sharedMemory[0x1C4]) = make_uint4(0x1c1c3824, 0xa6a657f1, 0xb4b473c7, 0xc6c69751);
+    AS_UINT4(&sharedMemory[0x1C8]) = make_uint4(0xe8e8cb23, 0xdddda17c, 0x7474e89c, 0x1f1f3e21);
+    AS_UINT4(&sharedMemory[0x1CC]) = make_uint4(0x4b4b96dd, 0xbdbd61dc, 0x8b8b0d86, 0x8a8a0f85);
+    AS_UINT4(&sharedMemory[0x1D0]) = make_uint4(0x7070e090, 0x3e3e7c42, 0xb5b571c4, 0x6666ccaa);
+    AS_UINT4(&sharedMemory[0x1D4]) = make_uint4(0x484890d8, 0x03030605, 0xf6f6f701, 0x0e0e1c12);
+    AS_UINT4(&sharedMemory[0x1D8]) = make_uint4(0x6161c2a3, 0x35356a5f, 0x5757aef9, 0xb9b969d0);
+    AS_UINT4(&sharedMemory[0x1DC]) = make_uint4(0x86861791, 0xc1c19958, 0x1d1d3a27, 0x9e9e27b9);
+    break;
+  case 7:
+    AS_UINT4(&sharedMemory[0x1E0]) = make_uint4(0xe1e1d938, 0xf8f8eb13, 0x98982bb3, 0x11112233);
+    AS_UINT4(&sharedMemory[0x1E4]) = make_uint4(0x6969d2bb, 0xd9d9a970, 0x8e8e0789, 0x949433a7);
+    AS_UINT4(&sharedMemory[0x1E8]) = make_uint4(0x9b9b2db6, 0x1e1e3c22, 0x87871592, 0xe9e9c920);
+    AS_UINT4(&sharedMemory[0x1EC]) = make_uint4(0xcece8749, 0x5555aaff, 0x28285078, 0xdfdfa57a);
+    AS_UINT4(&sharedMemory[0x1F0]) = make_uint4(0x8c8c038f, 0xa1a159f8, 0x89890980, 0x0d0d1a17);
+    AS_UINT4(&sharedMemory[0x1F4]) = make_uint4(0xbfbf65da, 0xe6e6d731, 0x424284c6, 0x6868d0b8);
+    AS_UINT4(&sharedMemory[0x1F8]) = make_uint4(0x414182c3, 0x999929b0, 0x2d2d5a77, 0x0f0f1e11);
+    AS_UINT4(&sharedMemory[0x1FC]) = make_uint4(0xb0b07bcb, 0x5454a8fc, 0xbbbb6dd6, 0x16162c3a);
+    break;
+  }
+  // AES 2
+  switch (threadIdx.x) {
+  case 0:
+    AS_UINT4(&sharedMemory[0x200]) = make_uint4(0x63c6a563, 0x7cf8847c, 0x77ee9977, 0x7bf68d7b);
+    AS_UINT4(&sharedMemory[0x204]) = make_uint4(0xf2ff0df2, 0x6bd6bd6b, 0x6fdeb16f, 0xc59154c5);
+    AS_UINT4(&sharedMemory[0x208]) = make_uint4(0x30605030, 0x01020301, 0x67cea967, 0x2b567d2b);
+    AS_UINT4(&sharedMemory[0x20C]) = make_uint4(0xfee719fe, 0xd7b562d7, 0xab4de6ab, 0x76ec9a76);
+    AS_UINT4(&sharedMemory[0x210]) = make_uint4(0xca8f45ca, 0x821f9d82, 0xc98940c9, 0x7dfa877d);
+    AS_UINT4(&sharedMemory[0x214]) = make_uint4(0xfaef15fa, 0x59b2eb59, 0x478ec947, 0xf0fb0bf0);
+    AS_UINT4(&sharedMemory[0x218]) = make_uint4(0xad41ecad, 0xd4b367d4, 0xa25ffda2, 0xaf45eaaf);
+    AS_UINT4(&sharedMemory[0x21C]) = make_uint4(0x9c23bf9c, 0xa453f7a4, 0x72e49672, 0xc09b5bc0);
+    break;
+  case 1:
+    AS_UINT4(&sharedMemory[0x220]) = make_uint4(0xb775c2b7, 0xfde11cfd, 0x933dae93, 0x264c6a26);
+    AS_UINT4(&sharedMemory[0x224]) = make_uint4(0x366c5a36, 0x3f7e413f, 0xf7f502f7, 0xcc834fcc);
+    AS_UINT4(&sharedMemory[0x228]) = make_uint4(0x34685c34, 0xa551f4a5, 0xe5d134e5, 0xf1f908f1);
+    AS_UINT4(&sharedMemory[0x22C]) = make_uint4(0x71e29371, 0xd8ab73d8, 0x31625331, 0x152a3f15);
+    AS_UINT4(&sharedMemory[0x230]) = make_uint4(0x04080c04, 0xc79552c7, 0x23466523, 0xc39d5ec3);
+    AS_UINT4(&sharedMemory[0x234]) = make_uint4(0x18302818, 0x9637a196, 0x050a0f05, 0x9a2fb59a);
+    AS_UINT4(&sharedMemory[0x238]) = make_uint4(0x070e0907, 0x12243612, 0x801b9b80, 0xe2df3de2);
+    AS_UINT4(&sharedMemory[0x23C]) = make_uint4(0xebcd26eb, 0x274e6927, 0xb27fcdb2, 0x75ea9f75);
+    break;
+  case 2:
+    AS_UINT4(&sharedMemory[0x240]) = make_uint4(0x09121b09, 0x831d9e83, 0x2c58742c, 0x1a342e1a);
+    AS_UINT4(&sharedMemory[0x244]) = make_uint4(0x1b362d1b, 0x6edcb26e, 0x5ab4ee5a, 0xa05bfba0);
+    AS_UINT4(&sharedMemory[0x248]) = make_uint4(0x52a4f652, 0x3b764d3b, 0xd6b761d6, 0xb37dceb3);
+    AS_UINT4(&sharedMemory[0x24C]) = make_uint4(0x29527b29, 0xe3dd3ee3, 0x2f5e712f, 0x84139784);
+    AS_UINT4(&sharedMemory[0x250]) = make_uint4(0x53a6f553, 0xd1b968d1, 0x00000000, 0xedc12ced);
+    AS_UINT4(&sharedMemory[0x254]) = make_uint4(0x20406020, 0xfce31ffc, 0xb179c8b1, 0x5bb6ed5b);
+    AS_UINT4(&sharedMemory[0x258]) = make_uint4(0x6ad4be6a, 0xcb8d46cb, 0xbe67d9be, 0x39724b39);
+    AS_UINT4(&sharedMemory[0x25C]) = make_uint4(0x4a94de4a, 0x4c98d44c, 0x58b0e858, 0xcf854acf);
+    break;
+  case 3:
+    AS_UINT4(&sharedMemory[0x260]) = make_uint4(0xd0bb6bd0, 0xefc52aef, 0xaa4fe5aa, 0xfbed16fb);
+    AS_UINT4(&sharedMemory[0x264]) = make_uint4(0x4386c543, 0x4d9ad74d, 0x33665533, 0x85119485);
+    AS_UINT4(&sharedMemory[0x268]) = make_uint4(0x458acf45, 0xf9e910f9, 0x02040602, 0x7ffe817f);
+    AS_UINT4(&sharedMemory[0x26C]) = make_uint4(0x50a0f050, 0x3c78443c, 0x9f25ba9f, 0xa84be3a8);
+    AS_UINT4(&sharedMemory[0x270]) = make_uint4(0x51a2f351, 0xa35dfea3, 0x4080c040, 0x8f058a8f);
+    AS_UINT4(&sharedMemory[0x274]) = make_uint4(0x923fad92, 0x9d21bc9d, 0x38704838, 0xf5f104f5);
+    AS_UINT4(&sharedMemory[0x278]) = make_uint4(0xbc63dfbc, 0xb677c1b6, 0xdaaf75da, 0x21426321);
+    AS_UINT4(&sharedMemory[0x27C]) = make_uint4(0x10203010, 0xffe51aff, 0xf3fd0ef3, 0xd2bf6dd2);
+    break;
+  case 4:
+    AS_UINT4(&sharedMemory[0x280]) = make_uint4(0xcd814ccd, 0x0c18140c, 0x13263513, 0xecc32fec);
+    AS_UINT4(&sharedMemory[0x284]) = make_uint4(0x5fbee15f, 0x9735a297, 0x4488cc44, 0x172e3917);
+    AS_UINT4(&sharedMemory[0x288]) = make_uint4(0xc49357c4, 0xa755f2a7, 0x7efc827e, 0x3d7a473d);
+    AS_UINT4(&sharedMemory[0x28C]) = make_uint4(0x64c8ac64, 0x5dbae75d, 0x19322b19, 0x73e69573);
+    AS_UINT4(&sharedMemory[0x290]) = make_uint4(0x60c0a060, 0x81199881, 0x4f9ed14f, 0xdca37fdc);
+    AS_UINT4(&sharedMemory[0x294]) = make_uint4(0x22446622, 0x2a547e2a, 0x903bab90, 0x880b8388);
+    AS_UINT4(&sharedMemory[0x298]) = make_uint4(0x468cca46, 0xeec729ee, 0xb86bd3b8, 0x14283c14);
+    AS_UINT4(&sharedMemory[0x29C]) = make_uint4(0xdea779de, 0x5ebce25e, 0x0b161d0b, 0xdbad76db);
+    break;
+  case 5:
+    AS_UINT4(&sharedMemory[0x2A0]) = make_uint4(0xe0db3be0, 0x32645632, 0x3a744e3a, 0x0a141e0a);
+    AS_UINT4(&sharedMemory[0x2A4]) = make_uint4(0x4992db49, 0x060c0a06, 0x24486c24, 0x5cb8e45c);
+    AS_UINT4(&sharedMemory[0x2A8]) = make_uint4(0xc29f5dc2, 0xd3bd6ed3, 0xac43efac, 0x62c4a662);
+    AS_UINT4(&sharedMemory[0x2AC]) = make_uint4(0x9139a891, 0x9531a495, 0xe4d337e4, 0x79f28b79);
+    AS_UINT4(&sharedMemory[0x2B0]) = make_uint4(0xe7d532e7, 0xc88b43c8, 0x376e5937, 0x6ddab76d);
+    AS_UINT4(&sharedMemory[0x2B4]) = make_uint4(0x8d018c8d, 0xd5b164d5, 0x4e9cd24e, 0xa949e0a9);
+    AS_UINT4(&sharedMemory[0x2B8]) = make_uint4(0x6cd8b46c, 0x56acfa56, 0xf4f307f4, 0xeacf25ea);
+    AS_UINT4(&sharedMemory[0x2BC]) = make_uint4(0x65caaf65, 0x7af48e7a, 0xae47e9ae, 0x08101808);
+    break;
+  case 6:
+    AS_UINT4(&sharedMemory[0x2C0]) = make_uint4(0xba6fd5ba, 0x78f08878, 0x254a6f25, 0x2e5c722e);
+    AS_UINT4(&sharedMemory[0x2C4]) = make_uint4(0x1c38241c, 0xa657f1a6, 0xb473c7b4, 0xc69751c6);
+    AS_UINT4(&sharedMemory[0x2C8]) = make_uint4(0xe8cb23e8, 0xdda17cdd, 0x74e89c74, 0x1f3e211f);
+    AS_UINT4(&sharedMemory[0x2CC]) = make_uint4(0x4b96dd4b, 0xbd61dcbd, 0x8b0d868b, 0x8a0f858a);
+    AS_UINT4(&sharedMemory[0x2D0]) = make_uint4(0x70e09070, 0x3e7c423e, 0xb571c4b5, 0x66ccaa66);
+    AS_UINT4(&sharedMemory[0x2D4]) = make_uint4(0x4890d848, 0x03060503, 0xf6f701f6, 0x0e1c120e);
+    AS_UINT4(&sharedMemory[0x2D8]) = make_uint4(0x61c2a361, 0x356a5f35, 0x57aef957, 0xb969d0b9);
+    AS_UINT4(&sharedMemory[0x2DC]) = make_uint4(0x86179186, 0xc19958c1, 0x1d3a271d, 0x9e27b99e);
+    break;
+  case 7:
+    AS_UINT4(&sharedMemory[0x2E0]) = make_uint4(0xe1d938e1, 0xf8eb13f8, 0x982bb398, 0x11223311);
+    AS_UINT4(&sharedMemory[0x2E4]) = make_uint4(0x69d2bb69, 0xd9a970d9, 0x8e07898e, 0x9433a794);
+    AS_UINT4(&sharedMemory[0x2E8]) = make_uint4(0x9b2db69b, 0x1e3c221e, 0x87159287, 0xe9c920e9);
+    AS_UINT4(&sharedMemory[0x2EC]) = make_uint4(0xce8749ce, 0x55aaff55, 0x28507828, 0xdfa57adf);
+    AS_UINT4(&sharedMemory[0x2F0]) = make_uint4(0x8c038f8c, 0xa159f8a1, 0x89098089, 0x0d1a170d);
+    AS_UINT4(&sharedMemory[0x2F4]) = make_uint4(0xbf65dabf, 0xe6d731e6, 0x4284c642, 0x68d0b868);
+    AS_UINT4(&sharedMemory[0x2F8]) = make_uint4(0x4182c341, 0x9929b099, 0x2d5a772d, 0x0f1e110f);
+    AS_UINT4(&sharedMemory[0x2FC]) = make_uint4(0xb07bcbb0, 0x54a8fc54, 0xbb6dd6bb, 0x162c3a16);
+    break;
+  }
+  // AES 3
+  switch (threadIdx.x) {
+  case 0:
+    AS_UINT4(&sharedMemory[0x300]) = make_uint4(0xc6a56363, 0xf8847c7c, 0xee997777, 0xf68d7b7b);
+    AS_UINT4(&sharedMemory[0x304]) = make_uint4(0xff0df2f2, 0xd6bd6b6b, 0xdeb16f6f, 0x9154c5c5);
+    AS_UINT4(&sharedMemory[0x308]) = make_uint4(0x60503030, 0x02030101, 0xcea96767, 0x567d2b2b);
+    AS_UINT4(&sharedMemory[0x30C]) = make_uint4(0xe719fefe, 0xb562d7d7, 0x4de6abab, 0xec9a7676);
+    AS_UINT4(&sharedMemory[0x310]) = make_uint4(0x8f45caca, 0x1f9d8282, 0x8940c9c9, 0xfa877d7d);
+    AS_UINT4(&sharedMemory[0x314]) = make_uint4(0xef15fafa, 0xb2eb5959, 0x8ec94747, 0xfb0bf0f0);
+    AS_UINT4(&sharedMemory[0x318]) = make_uint4(0x41ecadad, 0xb367d4d4, 0x5ffda2a2, 0x45eaafaf);
+    AS_UINT4(&sharedMemory[0x31C]) = make_uint4(0x23bf9c9c, 0x53f7a4a4, 0xe4967272, 0x9b5bc0c0);
+    break;
+  case 1:
+    AS_UINT4(&sharedMemory[0x320]) = make_uint4(0x75c2b7b7, 0xe11cfdfd, 0x3dae9393, 0x4c6a2626);
+    AS_UINT4(&sharedMemory[0x324]) = make_uint4(0x6c5a3636, 0x7e413f3f, 0xf502f7f7, 0x834fcccc);
+    AS_UINT4(&sharedMemory[0x328]) = make_uint4(0x685c3434, 0x51f4a5a5, 0xd134e5e5, 0xf908f1f1);
+    AS_UINT4(&sharedMemory[0x32C]) = make_uint4(0xe2937171, 0xab73d8d8, 0x62533131, 0x2a3f1515);
+    AS_UINT4(&sharedMemory[0x330]) = make_uint4(0x080c0404, 0x9552c7c7, 0x46652323, 0x9d5ec3c3);
+    AS_UINT4(&sharedMemory[0x334]) = make_uint4(0x30281818, 0x37a19696, 0x0a0f0505, 0x2fb59a9a);
+    AS_UINT4(&sharedMemory[0x338]) = make_uint4(0x0e090707, 0x24361212, 0x1b9b8080, 0xdf3de2e2);
+    AS_UINT4(&sharedMemory[0x33C]) = make_uint4(0xcd26ebeb, 0x4e692727, 0x7fcdb2b2, 0xea9f7575);
+    break;
+  case 2:
+    AS_UINT4(&sharedMemory[0x340]) = make_uint4(0x121b0909, 0x1d9e8383, 0x58742c2c, 0x342e1a1a);
+    AS_UINT4(&sharedMemory[0x344]) = make_uint4(0x362d1b1b, 0xdcb26e6e, 0xb4ee5a5a, 0x5bfba0a0);
+    AS_UINT4(&sharedMemory[0x348]) = make_uint4(0xa4f65252, 0x764d3b3b, 0xb761d6d6, 0x7dceb3b3);
+    AS_UINT4(&sharedMemory[0x34C]) = make_uint4(0x527b2929, 0xdd3ee3e3, 0x5e712f2f, 0x13978484);
+    AS_UINT4(&sharedMemory[0x350]) = make_uint4(0xa6f55353, 0xb968d1d1, 0x00000000, 0xc12ceded);
+    AS_UINT4(&sharedMemory[0x354]) = make_uint4(0x40602020, 0xe31ffcfc, 0x79c8b1b1, 0xb6ed5b5b);
+    AS_UINT4(&sharedMemory[0x358]) = make_uint4(0xd4be6a6a, 0x8d46cbcb, 0x67d9bebe, 0x724b3939);
+    AS_UINT4(&sharedMemory[0x35C]) = make_uint4(0x94de4a4a, 0x98d44c4c, 0xb0e85858, 0x854acfcf);
+    break;
+  case 3:
+    AS_UINT4(&sharedMemory[0x360]) = make_uint4(0xbb6bd0d0, 0xc52aefef, 0x4fe5aaaa, 0xed16fbfb);
+    AS_UINT4(&sharedMemory[0x364]) = make_uint4(0x86c54343, 0x9ad74d4d, 0x66553333, 0x11948585);
+    AS_UINT4(&sharedMemory[0x368]) = make_uint4(0x8acf4545, 0xe910f9f9, 0x04060202, 0xfe817f7f);
+    AS_UINT4(&sharedMemory[0x36C]) = make_uint4(0xa0f05050, 0x78443c3c, 0x25ba9f9f, 0x4be3a8a8);
+    AS_UINT4(&sharedMemory[0x370]) = make_uint4(0xa2f35151, 0x5dfea3a3, 0x80c04040, 0x058a8f8f);
+    AS_UINT4(&sharedMemory[0x374]) = make_uint4(0x3fad9292, 0x21bc9d9d, 0x70483838, 0xf104f5f5);
+    AS_UINT4(&sharedMemory[0x378]) = make_uint4(0x63dfbcbc, 0x77c1b6b6, 0xaf75dada, 0x42632121);
+    AS_UINT4(&sharedMemory[0x37C]) = make_uint4(0x20301010, 0xe51affff, 0xfd0ef3f3, 0xbf6dd2d2);
+    break;
+  case 4:
+    AS_UINT4(&sharedMemory[0x380]) = make_uint4(0x814ccdcd, 0x18140c0c, 0x26351313, 0xc32fecec);
+    AS_UINT4(&sharedMemory[0x384]) = make_uint4(0xbee15f5f, 0x35a29797, 0x88cc4444, 0x2e391717);
+    AS_UINT4(&sharedMemory[0x388]) = make_uint4(0x9357c4c4, 0x55f2a7a7, 0xfc827e7e, 0x7a473d3d);
+    AS_UINT4(&sharedMemory[0x38C]) = make_uint4(0xc8ac6464, 0xbae75d5d, 0x322b1919, 0xe6957373);
+    AS_UINT4(&sharedMemory[0x390]) = make_uint4(0xc0a06060, 0x19988181, 0x9ed14f4f, 0xa37fdcdc);
+    AS_UINT4(&sharedMemory[0x394]) = make_uint4(0x44662222, 0x547e2a2a, 0x3bab9090, 0x0b838888);
+    AS_UINT4(&sharedMemory[0x398]) = make_uint4(0x8cca4646, 0xc729eeee, 0x6bd3b8b8, 0x283c1414);
+    AS_UINT4(&sharedMemory[0x39C]) = make_uint4(0xa779dede, 0xbce25e5e, 0x161d0b0b, 0xad76dbdb);
+    break;
+  case 5:
+    AS_UINT4(&sharedMemory[0x3A0]) = make_uint4(0xdb3be0e0, 0x64563232, 0x744e3a3a, 0x141e0a0a);
+    AS_UINT4(&sharedMemory[0x3A4]) = make_uint4(0x92db4949, 0x0c0a0606, 0x486c2424, 0xb8e45c5c);
+    AS_UINT4(&sharedMemory[0x3A8]) = make_uint4(0x9f5dc2c2, 0xbd6ed3d3, 0x43efacac, 0xc4a66262);
+    AS_UINT4(&sharedMemory[0x3AC]) = make_uint4(0x39a89191, 0x31a49595, 0xd337e4e4, 0xf28b7979);
+    AS_UINT4(&sharedMemory[0x3B0]) = make_uint4(0xd532e7e7, 0x8b43c8c8, 0x6e593737, 0xdab76d6d);
+    AS_UINT4(&sharedMemory[0x3B4]) = make_uint4(0x018c8d8d, 0xb164d5d5, 0x9cd24e4e, 0x49e0a9a9);
+    AS_UINT4(&sharedMemory[0x3B8]) = make_uint4(0xd8b46c6c, 0xacfa5656, 0xf307f4f4, 0xcf25eaea);
+    AS_UINT4(&sharedMemory[0x3BC]) = make_uint4(0xcaaf6565, 0xf48e7a7a, 0x47e9aeae, 0x10180808);
+    break;
+  case 6:
+    AS_UINT4(&sharedMemory[0x3C0]) = make_uint4(0x6fd5baba, 0xf0887878, 0x4a6f2525, 0x5c722e2e);
+    AS_UINT4(&sharedMemory[0x3C4]) = make_uint4(0x38241c1c, 0x57f1a6a6, 0x73c7b4b4, 0x9751c6c6);
+    AS_UINT4(&sharedMemory[0x3C8]) = make_uint4(0xcb23e8e8, 0xa17cdddd, 0xe89c7474, 0x3e211f1f);
+    AS_UINT4(&sharedMemory[0x3CC]) = make_uint4(0x96dd4b4b, 0x61dcbdbd, 0x0d868b8b, 0x0f858a8a);
+    AS_UINT4(&sharedMemory[0x3D0]) = make_uint4(0xe0907070, 0x7c423e3e, 0x71c4b5b5, 0xccaa6666);
+    AS_UINT4(&sharedMemory[0x3D4]) = make_uint4(0x90d84848, 0x06050303, 0xf701f6f6, 0x1c120e0e);
+    AS_UINT4(&sharedMemory[0x3D8]) = make_uint4(0xc2a36161, 0x6a5f3535, 0xaef95757, 0x69d0b9b9);
+    AS_UINT4(&sharedMemory[0x3DC]) = make_uint4(0x17918686, 0x9958c1c1, 0x3a271d1d, 0x27b99e9e);
+    break;
+  case 7:
+    AS_UINT4(&sharedMemory[0x3E0]) = make_uint4(0xd938e1e1, 0xeb13f8f8, 0x2bb39898, 0x22331111);
+    AS_UINT4(&sharedMemory[0x3E4]) = make_uint4(0xd2bb6969, 0xa970d9d9, 0x07898e8e, 0x33a79494);
+    AS_UINT4(&sharedMemory[0x3E8]) = make_uint4(0x2db69b9b, 0x3c221e1e, 0x15928787, 0xc920e9e9);
+    AS_UINT4(&sharedMemory[0x3EC]) = make_uint4(0x8749cece, 0xaaff5555, 0x50782828, 0xa57adfdf);
+    AS_UINT4(&sharedMemory[0x3F0]) = make_uint4(0x038f8c8c, 0x59f8a1a1, 0x09808989, 0x1a170d0d);
+    AS_UINT4(&sharedMemory[0x3F4]) = make_uint4(0x65dabfbf, 0xd731e6e6, 0x84c64242, 0xd0b86868);
+    AS_UINT4(&sharedMemory[0x3F8]) = make_uint4(0x82c34141, 0x29b09999, 0x5a772d2d, 0x1e110f0f);
+    AS_UINT4(&sharedMemory[0x3FC]) = make_uint4(0x7bcbb0b0, 0xa8fc5454, 0x6dd6bbbb, 0x2c3a1616);
+    break;
+  }
+}
\ No newline at end of file
diff --git a/crypto/cn_blake.cuh b/crypto/cn_blake.cuh
index 5c0d09f27..3f410f73d 100644
--- a/crypto/cn_blake.cuh
+++ b/crypto/cn_blake.cuh
@@ -1,4 +1,3 @@
-//#include <cuda_helper.h>
 
 typedef struct {
   uint32_t h[8], s[4], t[2];
@@ -7,25 +6,24 @@ typedef struct {
 } blake_state;
 
 #define U8TO32(p) \
-	(((uint32_t)((p)[0]) << 24) | ((uint32_t)((p)[1]) << 16) | \
-	 ((uint32_t)((p)[2]) <<  8) | ((uint32_t)((p)[3])      ))
-
+    (((uint32_t)((p)[0]) << 24) | ((uint32_t)((p)[1]) << 16) |    \
+     ((uint32_t)((p)[2]) <<  8) | ((uint32_t)((p)[3])      ))
 #define U32TO8(p, v) \
-	(p)[0] = (uint8_t)((v) >> 24); (p)[1] = (uint8_t)((v) >> 16); \
-	(p)[2] = (uint8_t)((v) >>  8); (p)[3] = (uint8_t)((v)      );
-
+    (p)[0] = (uint8_t)((v) >> 24); (p)[1] = (uint8_t)((v) >> 16); \
+    (p)[2] = (uint8_t)((v) >>  8); (p)[3] = (uint8_t)((v)      );
 #define BLAKE_ROT(x,n) ROTR32(x, n)
 #define BLAKE_G(a,b,c,d,e)                                      \
-	v[a] += (m[d_blake_sigma[i][e]] ^ d_blake_cst[d_blake_sigma[i][e+1]]) + v[b]; \
-	v[d] = BLAKE_ROT(v[d] ^ v[a],16); \
-	v[c] += v[d]; \
-	v[b] = BLAKE_ROT(v[b] ^ v[c],12); \
-	v[a] += (m[d_blake_sigma[i][e+1]] ^ d_blake_cst[d_blake_sigma[i][e]]) + v[b]; \
-	v[d] = BLAKE_ROT(v[d] ^ v[a], 8); \
-	v[c] += v[d]; \
-	v[b] = BLAKE_ROT(v[b] ^ v[c], 7);
-
-__constant__ uint8_t d_blake_sigma[14][16] = {
+    v[a] += (m[d_blake_sigma[i][e]] ^ d_blake_cst[d_blake_sigma[i][e+1]]) + v[b]; \
+    v[d] = BLAKE_ROT(v[d] ^ v[a],16);                           \
+    v[c] += v[d];                                         \
+    v[b] = BLAKE_ROT(v[b] ^ v[c],12);                           \
+    v[a] += (m[d_blake_sigma[i][e+1]] ^ d_blake_cst[d_blake_sigma[i][e]])+v[b];   \
+    v[d] = BLAKE_ROT(v[d] ^ v[a], 8);                           \
+    v[c] += v[d];                                         \
+    v[b] = BLAKE_ROT(v[b] ^ v[c], 7);
+
+__constant__ uint8_t d_blake_sigma[14][16] =
+{
 	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
 	{14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3},
 	{11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4},
@@ -41,140 +39,137 @@ __constant__ uint8_t d_blake_sigma[14][16] = {
 	{11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4},
 	{7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8}
 };
-
-__constant__ uint32_t d_blake_cst[16] = {
+__constant__ uint32_t d_blake_cst[16]
+= {
 	0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,
 	0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,
 	0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,
 	0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917
 };
 
-__device__
-void cn_blake_compress(blake_state * __restrict__ S, const uint8_t * __restrict__ block)
+__device__ void cn_blake_compress(blake_state * __restrict__ S, const uint8_t * __restrict__ block)
 {
-	uint32_t v[16], m[16], i;
-
-	for (i = 0; i < 16; ++i) m[i] = U8TO32(block + i * 4);
-	for (i = 0; i < 8;  ++i) v[i] = S->h[i];
-	v[ 8] = S->s[0] ^ 0x243F6A88;
-	v[ 9] = S->s[1] ^ 0x85A308D3;
-	v[10] = S->s[2] ^ 0x13198A2E;
-	v[11] = S->s[3] ^ 0x03707344;
-	v[12] = 0xA4093822;
-	v[13] = 0x299F31D0;
-	v[14] = 0x082EFA98;
-	v[15] = 0xEC4E6C89;
-
-	if (S->nullt == 0) {
-		v[12] ^= S->t[0];
-		v[13] ^= S->t[0];
-		v[14] ^= S->t[1];
-		v[15] ^= S->t[1];
-	}
-
-	for (i = 0; i < 14; ++i) {
-		BLAKE_G(0, 4,  8, 12,  0);
-		BLAKE_G(1, 5,  9, 13,  2);
-		BLAKE_G(2, 6, 10, 14,  4);
-		BLAKE_G(3, 7, 11, 15,  6);
-		BLAKE_G(3, 4,  9, 14, 14);
-		BLAKE_G(2, 7,  8, 13, 12);
-		BLAKE_G(0, 5, 10, 15,  8);
-		BLAKE_G(1, 6, 11, 12, 10);
-	}
-
-	for (i = 0; i < 16; ++i) S->h[i % 8] ^= v[i];
-	for (i = 0; i < 8;  ++i) S->h[i] ^= S->s[i % 4];
+    uint32_t v[16], m[16], i;
+
+    for (i = 0; i < 16; ++i) m[i] = U8TO32(block + i * 4);
+    for (i = 0; i < 8;  ++i) v[i] = S->h[i];
+    v[ 8] = S->s[0] ^ 0x243F6A88;
+    v[ 9] = S->s[1] ^ 0x85A308D3;
+    v[10] = S->s[2] ^ 0x13198A2E;
+    v[11] = S->s[3] ^ 0x03707344;
+    v[12] = 0xA4093822;
+    v[13] = 0x299F31D0;
+    v[14] = 0x082EFA98;
+    v[15] = 0xEC4E6C89;
+
+    if (S->nullt == 0) {
+        v[12] ^= S->t[0];
+        v[13] ^= S->t[0];
+        v[14] ^= S->t[1];
+        v[15] ^= S->t[1];
+    }
+
+    for (i = 0; i < 14; ++i) {
+        BLAKE_G(0, 4,  8, 12,  0);
+        BLAKE_G(1, 5,  9, 13,  2);
+        BLAKE_G(2, 6, 10, 14,  4);
+        BLAKE_G(3, 7, 11, 15,  6);
+        BLAKE_G(3, 4,  9, 14, 14);
+        BLAKE_G(2, 7,  8, 13, 12);
+        BLAKE_G(0, 5, 10, 15,  8);
+        BLAKE_G(1, 6, 11, 12, 10);
+    }
+
+    for (i = 0; i < 16; ++i) S->h[i % 8] ^= v[i];
+    for (i = 0; i < 8;  ++i) S->h[i] ^= S->s[i % 4];
 }
 
 __device__ void cn_blake_update(blake_state * __restrict__ S, const uint8_t * __restrict__ data, uint64_t datalen)
 {
-	int left = S->buflen >> 3;
-	int fill = 64 - left;
-
-	if (left && (((datalen >> 3) & 0x3F) >= (unsigned) fill)) {
-		memcpy((void *) (S->buf + left), (void *) data, fill);
-		S->t[0] += 512;
-		if (S->t[0] == 0) S->t[1]++;
-		cn_blake_compress(S, S->buf);
-		data += fill;
-		datalen -= (fill << 3);
-		left = 0;
-	}
-
-	while (datalen >= 512) {
-		S->t[0] += 512;
-		if (S->t[0] == 0) S->t[1]++;
-		cn_blake_compress(S, data);
-		data += 64;
-		datalen -= 512;
-	}
-
-	if (datalen > 0) {
-		memcpy((void *) (S->buf + left), (void *) data, datalen >> 3);
-		S->buflen = (left << 3) + datalen;
-	} else {
-		S->buflen = 0;
-	}
+    int left = S->buflen >> 3;
+    int fill = 64 - left;
+
+    if (left && (((datalen >> 3) & 0x3F) >= (unsigned) fill)) {
+        memcpy((void *) (S->buf + left), (void *) data, fill);
+        S->t[0] += 512;
+        if (S->t[0] == 0) S->t[1]++;
+        cn_blake_compress(S, S->buf);
+        data += fill;
+        datalen -= (fill << 3);
+        left = 0;
+    }
+
+    while (datalen >= 512) {
+        S->t[0] += 512;
+        if (S->t[0] == 0) S->t[1]++;
+        cn_blake_compress(S, data);
+        data += 64;
+        datalen -= 512;
+    }
+
+    if (datalen > 0) {
+        memcpy((void *) (S->buf + left), (void *) data, datalen >> 3);
+        S->buflen = (left << 3) + datalen;
+    } else {
+        S->buflen = 0;
+    }
 }
 
-__device__
-void cn_blake_final(blake_state * __restrict__ S, uint8_t * __restrict__ digest)
+__device__ void cn_blake_final(blake_state * __restrict__ S, uint8_t * __restrict__ digest)
 {
-	const uint8_t padding[] = {
-		0x80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
-	};
-	uint8_t pa = 0x81, pb = 0x01;
-	uint8_t msglen[8];
-	uint32_t lo = S->t[0] + S->buflen, hi = S->t[1];
-	if (lo < (unsigned) S->buflen) hi++;
-	U32TO8(msglen + 0, hi);
-	U32TO8(msglen + 4, lo);
-
-	if (S->buflen == 440) {
-		S->t[0] -= 8;
-		cn_blake_update(S, &pa, 8);
-	} else {
-		if (S->buflen < 440) {
-			if (S->buflen == 0) S->nullt = 1;
-			S->t[0] -= 440 - S->buflen;
-			cn_blake_update(S, padding, 440 - S->buflen);
-		} else {
-			S->t[0] -= 512 - S->buflen;
-			cn_blake_update(S, padding, 512 - S->buflen);
-			S->t[0] -= 440;
-			cn_blake_update(S, padding + 1, 440);
-			S->nullt = 1;
-		}
-		cn_blake_update(S, &pb, 8);
-		S->t[0] -= 8;
-	}
-	S->t[0] -= 64;
-	cn_blake_update(S, msglen, 64);
-
-	U32TO8(digest +  0, S->h[0]);
-	U32TO8(digest +  4, S->h[1]);
-	U32TO8(digest +  8, S->h[2]);
-	U32TO8(digest + 12, S->h[3]);
-	U32TO8(digest + 16, S->h[4]);
-	U32TO8(digest + 20, S->h[5]);
-	U32TO8(digest + 24, S->h[6]);
-	U32TO8(digest + 28, S->h[7]);
+    const uint8_t padding[] = {
+        0x80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+    };
+    uint8_t pa = 0x81, pb = 0x01;
+    uint8_t msglen[8];
+    uint32_t lo = S->t[0] + S->buflen, hi = S->t[1];
+    if (lo < (unsigned) S->buflen) hi++;
+    U32TO8(msglen + 0, hi);
+    U32TO8(msglen + 4, lo);
+
+    if (S->buflen == 440) {
+        S->t[0] -= 8;
+        cn_blake_update(S, &pa, 8);
+    } else {
+        if (S->buflen < 440) {
+            if (S->buflen == 0) S->nullt = 1;
+            S->t[0] -= 440 - S->buflen;
+            cn_blake_update(S, padding, 440 - S->buflen);
+        } else {
+            S->t[0] -= 512 - S->buflen;
+            cn_blake_update(S, padding, 512 - S->buflen);
+            S->t[0] -= 440;
+            cn_blake_update(S, padding + 1, 440);
+            S->nullt = 1;
+        }
+        cn_blake_update(S, &pb, 8);
+        S->t[0] -= 8;
+    }
+    S->t[0] -= 64;
+    cn_blake_update(S, msglen, 64);
+
+    U32TO8(digest +  0, S->h[0]);
+    U32TO8(digest +  4, S->h[1]);
+    U32TO8(digest +  8, S->h[2]);
+    U32TO8(digest + 12, S->h[3]);
+    U32TO8(digest + 16, S->h[4]);
+    U32TO8(digest + 20, S->h[5]);
+    U32TO8(digest + 24, S->h[6]);
+    U32TO8(digest + 28, S->h[7]);
 }
 
-__device__
-void cn_blake(const uint8_t * __restrict__ in, uint64_t inlen, uint8_t * __restrict__ out)
+__device__ void cn_blake(const uint8_t * __restrict__ in, uint64_t inlen, uint8_t * __restrict__ out)
 {
-	blake_state bs;
-	blake_state *S = (blake_state *)&bs;
-
-	S->h[0] = 0x6A09E667; S->h[1] = 0xBB67AE85; S->h[2] = 0x3C6EF372;
-	S->h[3] = 0xA54FF53A; S->h[4] = 0x510E527F; S->h[5] = 0x9B05688C;
-	S->h[6] = 0x1F83D9AB; S->h[7] = 0x5BE0CD19;
-	S->t[0] = S->t[1] = S->buflen = S->nullt = 0;
-	S->s[0] = S->s[1] = S->s[2] = S->s[3] = 0;
-
-	cn_blake_update(S, (uint8_t *)in, inlen * 8);
-	cn_blake_final(S, (uint8_t *)out);
-}
+    blake_state bs;
+    blake_state *S = (blake_state *)&bs;
+
+    S->h[0] = 0x6A09E667; S->h[1] = 0xBB67AE85; S->h[2] = 0x3C6EF372;
+    S->h[3] = 0xA54FF53A; S->h[4] = 0x510E527F; S->h[5] = 0x9B05688C;
+    S->h[6] = 0x1F83D9AB; S->h[7] = 0x5BE0CD19;
+    S->t[0] = S->t[1] = S->buflen = S->nullt = 0;
+    S->s[0] = S->s[1] = S->s[2] = S->s[3] = 0;
+    
+    cn_blake_update(S, (uint8_t *)in, inlen * 8);
+    cn_blake_final(S, (uint8_t *)out);
+}
\ No newline at end of file
diff --git a/crypto/cn_groestl.cuh b/crypto/cn_groestl.cuh
index 62530d44d..75b61b58f 100644
--- a/crypto/cn_groestl.cuh
+++ b/crypto/cn_groestl.cuh
@@ -2,18 +2,22 @@
 #define GROESTL_ROWS 8
 #define GROESTL_LENGTHFIELDLEN GROESTL_ROWS
 #define GROESTL_COLS512 8
+
 #define GROESTL_SIZE512 (GROESTL_ROWS*GROESTL_COLS512)
+
 #define GROESTL_ROUNDS512 10
 #define GROESTL_HASH_BIT_LEN 256
 
 #define GROESTL_ROTL32(v, n) ROTL32(v, n)
 
+
 #define li_32(h) 0x##h##u
 #define GROESTL_EXT_BYTE(var,n) ((uint8_t)((uint32_t)(var) >> (8*n)))
 #define u32BIG(a)				\
-  ((GROESTL_ROTL32(a,8) & li_32(00FF00FF)) | \
+  ((GROESTL_ROTL32(a,8) & li_32(00FF00FF)) |		\
    (GROESTL_ROTL32(a,24) & li_32(FF00FF00)))
 
+
 typedef struct {
   uint32_t chaining[GROESTL_SIZE512/sizeof(uint32_t)];
   uint32_t block_counter1, block_counter2;
@@ -22,326 +26,320 @@ typedef struct {
   int bits_in_last_byte;
 } groestlHashState;
 
-__constant__ uint32_t d_groestl_T[512] = {
-	0xa5f432c6, 0xc6a597f4, 0x84976ff8, 0xf884eb97, 0x99b05eee, 0xee99c7b0, 0x8d8c7af6, 0xf68df78c, 0x0d17e8ff, 0xff0de517, 0xbddc0ad6, 0xd6bdb7dc, 0xb1c816de, 0xdeb1a7c8, 0x54fc6d91, 0x915439fc,
-	0x50f09060, 0x6050c0f0, 0x03050702, 0x02030405, 0xa9e02ece, 0xcea987e0, 0x7d87d156, 0x567dac87, 0x192bcce7, 0xe719d52b, 0x62a613b5, 0xb56271a6, 0xe6317c4d, 0x4de69a31, 0x9ab559ec, 0xec9ac3b5,
-	0x45cf408f, 0x8f4505cf, 0x9dbca31f, 0x1f9d3ebc, 0x40c04989, 0x894009c0, 0x879268fa, 0xfa87ef92, 0x153fd0ef, 0xef15c53f, 0xeb2694b2, 0xb2eb7f26, 0xc940ce8e, 0x8ec90740, 0x0b1de6fb, 0xfb0bed1d,
-	0xec2f6e41, 0x41ec822f, 0x67a91ab3, 0xb3677da9, 0xfd1c435f, 0x5ffdbe1c, 0xea256045, 0x45ea8a25, 0xbfdaf923, 0x23bf46da, 0xf7025153, 0x53f7a602, 0x96a145e4, 0xe496d3a1, 0x5bed769b, 0x9b5b2ded,
-	0xc25d2875, 0x75c2ea5d, 0x1c24c5e1, 0xe11cd924, 0xaee9d43d, 0x3dae7ae9, 0x6abef24c, 0x4c6a98be, 0x5aee826c, 0x6c5ad8ee, 0x41c3bd7e, 0x7e41fcc3, 0x0206f3f5, 0xf502f106, 0x4fd15283, 0x834f1dd1,
-	0x5ce48c68, 0x685cd0e4, 0xf4075651, 0x51f4a207, 0x345c8dd1, 0xd134b95c, 0x0818e1f9, 0xf908e918, 0x93ae4ce2, 0xe293dfae, 0x73953eab, 0xab734d95, 0x53f59762, 0x6253c4f5, 0x3f416b2a, 0x2a3f5441,
-	0x0c141c08, 0x080c1014, 0x52f66395, 0x955231f6, 0x65afe946, 0x46658caf, 0x5ee27f9d, 0x9d5e21e2, 0x28784830, 0x30286078, 0xa1f8cf37, 0x37a16ef8, 0x0f111b0a, 0x0a0f1411, 0xb5c4eb2f, 0x2fb55ec4,
-	0x091b150e, 0x0e091c1b, 0x365a7e24, 0x2436485a, 0x9bb6ad1b, 0x1b9b36b6, 0x3d4798df, 0xdf3da547, 0x266aa7cd, 0xcd26816a, 0x69bbf54e, 0x4e699cbb, 0xcd4c337f, 0x7fcdfe4c, 0x9fba50ea, 0xea9fcfba,
-	0x1b2d3f12, 0x121b242d, 0x9eb9a41d, 0x1d9e3ab9, 0x749cc458, 0x5874b09c, 0x2e724634, 0x342e6872, 0x2d774136, 0x362d6c77, 0xb2cd11dc, 0xdcb2a3cd, 0xee299db4, 0xb4ee7329, 0xfb164d5b, 0x5bfbb616,
-	0xf601a5a4, 0xa4f65301, 0x4dd7a176, 0x764decd7, 0x61a314b7, 0xb76175a3, 0xce49347d, 0x7dcefa49, 0x7b8ddf52, 0x527ba48d, 0x3e429fdd, 0xdd3ea142, 0x7193cd5e, 0x5e71bc93, 0x97a2b113, 0x139726a2,
-	0xf504a2a6, 0xa6f55704, 0x68b801b9, 0xb96869b8,          0,          0, 0x2c74b5c1, 0xc12c9974, 0x60a0e040, 0x406080a0, 0x1f21c2e3, 0xe31fdd21, 0xc8433a79, 0x79c8f243, 0xed2c9ab6, 0xb6ed772c,
-	0xbed90dd4, 0xd4beb3d9, 0x46ca478d, 0x8d4601ca, 0xd9701767, 0x67d9ce70, 0x4bddaf72, 0x724be4dd, 0xde79ed94, 0x94de3379, 0xd467ff98, 0x98d42b67, 0xe82393b0, 0xb0e87b23, 0x4ade5b85, 0x854a11de,
-	0x6bbd06bb, 0xbb6b6dbd, 0x2a7ebbc5, 0xc52a917e, 0xe5347b4f, 0x4fe59e34, 0x163ad7ed, 0xed16c13a, 0xc554d286, 0x86c51754, 0xd762f89a, 0x9ad72f62, 0x55ff9966, 0x6655ccff, 0x94a7b611, 0x119422a7,
-	0xcf4ac08a, 0x8acf0f4a, 0x1030d9e9, 0xe910c930, 0x060a0e04, 0x0406080a, 0x819866fe, 0xfe81e798, 0xf00baba0, 0xa0f05b0b, 0x44ccb478, 0x7844f0cc, 0xbad5f025, 0x25ba4ad5, 0xe33e754b, 0x4be3963e,
-	0xf30eaca2, 0xa2f35f0e, 0xfe19445d, 0x5dfeba19, 0xc05bdb80, 0x80c01b5b, 0x8a858005, 0x058a0a85, 0xadecd33f, 0x3fad7eec, 0xbcdffe21, 0x21bc42df, 0x48d8a870, 0x7048e0d8, 0x040cfdf1, 0xf104f90c,
-	0xdf7a1963, 0x63dfc67a, 0xc1582f77, 0x77c1ee58, 0x759f30af, 0xaf75459f, 0x63a5e742, 0x426384a5, 0x30507020, 0x20304050, 0x1a2ecbe5, 0xe51ad12e, 0x0e12effd, 0xfd0ee112, 0x6db708bf, 0xbf6d65b7,
-	0x4cd45581, 0x814c19d4, 0x143c2418, 0x1814303c, 0x355f7926, 0x26354c5f, 0x2f71b2c3, 0xc32f9d71, 0xe13886be, 0xbee16738, 0xa2fdc835, 0x35a26afd, 0xcc4fc788, 0x88cc0b4f, 0x394b652e, 0x2e395c4b,
-	0x57f96a93, 0x93573df9, 0xf20d5855, 0x55f2aa0d, 0x829d61fc, 0xfc82e39d, 0x47c9b37a, 0x7a47f4c9, 0xacef27c8, 0xc8ac8bef, 0xe73288ba, 0xbae76f32, 0x2b7d4f32, 0x322b647d, 0x95a442e6, 0xe695d7a4,
-	0xa0fb3bc0, 0xc0a09bfb, 0x98b3aa19, 0x199832b3, 0xd168f69e, 0x9ed12768, 0x7f8122a3, 0xa37f5d81, 0x66aaee44, 0x446688aa, 0x7e82d654, 0x547ea882, 0xabe6dd3b, 0x3bab76e6, 0x839e950b, 0xb83169e,
-	0xca45c98c, 0x8cca0345, 0x297bbcc7, 0xc729957b, 0xd36e056b, 0x6bd3d66e, 0x3c446c28, 0x283c5044, 0x798b2ca7, 0xa779558b, 0xe23d81bc, 0xbce2633d, 0x1d273116, 0x161d2c27, 0x769a37ad, 0xad76419a,
-	0x3b4d96db, 0xdb3bad4d, 0x56fa9e64, 0x6456c8fa, 0x4ed2a674, 0x744ee8d2, 0x1e223614, 0x141e2822, 0xdb76e492, 0x92db3f76, 0x0a1e120c, 0x0c0a181e, 0x6cb4fc48, 0x486c90b4, 0xe4378fb8, 0xb8e46b37,
-	0x5de7789f, 0x9f5d25e7, 0x6eb20fbd, 0xbd6e61b2, 0xef2a6943, 0x43ef862a, 0xa6f135c4, 0xc4a693f1, 0xa8e3da39, 0x39a872e3, 0xa4f7c631, 0x31a462f7, 0x37598ad3, 0xd337bd59, 0x8b8674f2, 0xf28bff86,
-	0x325683d5, 0xd532b156, 0x43c54e8b, 0x8b430dc5, 0x59eb856e, 0x6e59dceb, 0xb7c218da, 0xdab7afc2, 0x8c8f8e01, 0x018c028f, 0x64ac1db1, 0xb16479ac, 0xd26df19c, 0x9cd2236d, 0xe03b7249, 0x49e0923b,
-	0xb4c71fd8, 0xd8b4abc7, 0xfa15b9ac, 0xacfa4315, 0x0709faf3, 0xf307fd09, 0x256fa0cf, 0xcf25856f, 0xafea20ca, 0xcaaf8fea, 0x8e897df4, 0xf48ef389, 0xe9206747, 0x47e98e20, 0x18283810, 0x10182028,
-	0xd5640b6f, 0x6fd5de64, 0x888373f0, 0xf088fb83, 0x6fb1fb4a, 0x4a6f94b1, 0x7296ca5c, 0x5c72b896, 0x246c5438, 0x3824706c, 0xf1085f57, 0x57f1ae08, 0xc7522173, 0x73c7e652, 0x51f36497, 0x975135f3,
-	0x2365aecb, 0xcb238d65, 0x7c8425a1, 0xa17c5984, 0x9cbf57e8, 0xe89ccbbf, 0x21635d3e, 0x3e217c63, 0xdd7cea96, 0x96dd377c, 0xdc7f1e61, 0x61dcc27f, 0x86919c0d, 0x0d861a91, 0x85949b0f, 0xf851e94,
-	0x90ab4be0, 0xe090dbab, 0x42c6ba7c, 0x7c42f8c6, 0xc4572671, 0x71c4e257, 0xaae529cc, 0xccaa83e5, 0xd873e390, 0x90d83b73, 0x050f0906, 0x06050c0f, 0x0103f4f7, 0xf701f503, 0x12362a1c, 0x1c123836,
-	0xa3fe3cc2, 0xc2a39ffe, 0x5fe18b6a, 0x6a5fd4e1, 0xf910beae, 0xaef94710, 0xd06b0269, 0x69d0d26b, 0x91a8bf17, 0x17912ea8, 0x58e87199, 0x995829e8, 0x2769533a, 0x3a277469, 0xb9d0f727, 0x27b94ed0,
-	0x384891d9, 0xd938a948, 0x1335deeb, 0xeb13cd35, 0xb3cee52b, 0x2bb356ce, 0x33557722, 0x22334455, 0xbbd604d2, 0xd2bbbfd6, 0x709039a9, 0xa9704990, 0x89808707, 0x07890e80, 0xa7f2c133, 0x33a766f2,
-	0xb6c1ec2d, 0x2db65ac1, 0x22665a3c, 0x3c227866, 0x92adb815, 0x15922aad, 0x2060a9c9, 0xc9208960, 0x49db5c87, 0x874915db, 0xff1ab0aa, 0xaaff4f1a, 0x7888d850, 0x5078a088, 0x7a8e2ba5, 0xa57a518e,
-	0x8f8a8903, 0x038f068a, 0xf8134a59, 0x59f8b213, 0x809b9209, 0x0980129b, 0x1739231a, 0x1a173439, 0xda751065, 0x65daca75, 0x315384d7, 0xd731b553, 0xc651d584, 0x84c61351, 0xb8d303d0, 0xd0b8bbd3,
-	0xc35edc82, 0x82c31f5e, 0xb0cbe229, 0x29b052cb, 0x7799c35a, 0x5a77b499, 0x11332d1e, 0x1e113c33, 0xcb463d7b, 0x7bcbf646, 0xfc1fb7a8, 0xa8fc4b1f, 0xd6610c6d, 0x6dd6da61, 0x3a4e622c, 0x2c3a584e
-};
 
-#define GROESTL_ROTATE_COLUMN_DOWN(v1, v2, amount_bytes, temp_var) { \
-	temp_var = (v1<<(8*amount_bytes))|(v2>>(8*(4-amount_bytes))); \
-	v2 = (v2<<(8*amount_bytes))|(v1>>(8*(4-amount_bytes))); \
-	v1 = temp_var; \
-}
 
-#define GROESTL_COLUMN(x,y,i, c0,c1,c2,c3,c4,c5,c6,c7, tv1,tv2,tu,tl,t) \
-   tu = d_groestl_T[2*(uint32_t)x[4*c0+0]]; \
-   tl = d_groestl_T[2*(uint32_t)x[4*c0+0]+1]; \
-   tv1 = d_groestl_T[2*(uint32_t)x[4*c1+1]]; \
-   tv2 = d_groestl_T[2*(uint32_t)x[4*c1+1]+1]; \
-   GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,1,t) \
-   tu ^= tv1; \
-   tl ^= tv2; \
-   tv1 = d_groestl_T[2*(uint32_t)x[4*c2+2]]; \
-   tv2 = d_groestl_T[2*(uint32_t)x[4*c2+2]+1]; \
-   GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,2,t) \
-   tu ^= tv1; \
-   tl ^= tv2; \
-   tv1 = d_groestl_T[2*(uint32_t)x[4*c3+3]]; \
-   tv2 = d_groestl_T[2*(uint32_t)x[4*c3+3]+1]; \
-   GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,3,t) \
-   tu ^= tv1; \
-   tl ^= tv2; \
-   tl ^= d_groestl_T[2*(uint32_t)x[4*c4+0]]; \
-   tu ^= d_groestl_T[2*(uint32_t)x[4*c4+0]+1]; \
-   tv1 = d_groestl_T[2*(uint32_t)x[4*c5+1]]; \
-   tv2 = d_groestl_T[2*(uint32_t)x[4*c5+1]+1]; \
-   GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,1,t) \
-   tl ^= tv1; \
-   tu ^= tv2; \
-   tv1 = d_groestl_T[2*(uint32_t)x[4*c6+2]]; \
-   tv2 = d_groestl_T[2*(uint32_t)x[4*c6+2]+1]; \
-   GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,2,t) \
-   tl ^= tv1; \
-   tu ^= tv2; \
-   tv1 = d_groestl_T[2*(uint32_t)x[4*c7+3]]; \
-   tv2 = d_groestl_T[2*(uint32_t)x[4*c7+3]+1]; \
-   GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,3,t) \
-   tl ^= tv1; \
-   tu ^= tv2; \
-   y[i] = tu; \
+__constant__ uint32_t d_groestl_T[512] =
+{
+	0xa5f432c6, 0xc6a597f4, 0x84976ff8, 0xf884eb97, 0x99b05eee, 0xee99c7b0, 0x8d8c7af6, 0xf68df78c, 0xd17e8ff, 0xff0de517, 0xbddc0ad6, 0xd6bdb7dc, 0xb1c816de, 0xdeb1a7c8, 0x54fc6d91, 0x915439fc
+, 0x50f09060, 0x6050c0f0, 0x3050702, 0x2030405, 0xa9e02ece, 0xcea987e0, 0x7d87d156, 0x567dac87, 0x192bcce7, 0xe719d52b, 0x62a613b5, 0xb56271a6, 0xe6317c4d, 0x4de69a31, 0x9ab559ec, 0xec9ac3b5
+, 0x45cf408f, 0x8f4505cf, 0x9dbca31f, 0x1f9d3ebc, 0x40c04989, 0x894009c0, 0x879268fa, 0xfa87ef92, 0x153fd0ef, 0xef15c53f, 0xeb2694b2, 0xb2eb7f26, 0xc940ce8e, 0x8ec90740, 0xb1de6fb, 0xfb0bed1d
+, 0xec2f6e41, 0x41ec822f, 0x67a91ab3, 0xb3677da9, 0xfd1c435f, 0x5ffdbe1c, 0xea256045, 0x45ea8a25, 0xbfdaf923, 0x23bf46da, 0xf7025153, 0x53f7a602, 0x96a145e4, 0xe496d3a1, 0x5bed769b, 0x9b5b2ded
+, 0xc25d2875, 0x75c2ea5d, 0x1c24c5e1, 0xe11cd924, 0xaee9d43d, 0x3dae7ae9, 0x6abef24c, 0x4c6a98be, 0x5aee826c, 0x6c5ad8ee, 0x41c3bd7e, 0x7e41fcc3, 0x206f3f5, 0xf502f106, 0x4fd15283, 0x834f1dd1
+, 0x5ce48c68, 0x685cd0e4, 0xf4075651, 0x51f4a207, 0x345c8dd1, 0xd134b95c, 0x818e1f9, 0xf908e918, 0x93ae4ce2, 0xe293dfae, 0x73953eab, 0xab734d95, 0x53f59762, 0x6253c4f5, 0x3f416b2a, 0x2a3f5441
+, 0xc141c08, 0x80c1014, 0x52f66395, 0x955231f6, 0x65afe946, 0x46658caf, 0x5ee27f9d, 0x9d5e21e2, 0x28784830, 0x30286078, 0xa1f8cf37, 0x37a16ef8, 0xf111b0a, 0xa0f1411, 0xb5c4eb2f, 0x2fb55ec4
+, 0x91b150e, 0xe091c1b, 0x365a7e24, 0x2436485a, 0x9bb6ad1b, 0x1b9b36b6, 0x3d4798df, 0xdf3da547, 0x266aa7cd, 0xcd26816a, 0x69bbf54e, 0x4e699cbb, 0xcd4c337f, 0x7fcdfe4c, 0x9fba50ea, 0xea9fcfba
+, 0x1b2d3f12, 0x121b242d, 0x9eb9a41d, 0x1d9e3ab9, 0x749cc458, 0x5874b09c, 0x2e724634, 0x342e6872, 0x2d774136, 0x362d6c77, 0xb2cd11dc, 0xdcb2a3cd, 0xee299db4, 0xb4ee7329, 0xfb164d5b, 0x5bfbb616
+, 0xf601a5a4, 0xa4f65301, 0x4dd7a176, 0x764decd7, 0x61a314b7, 0xb76175a3, 0xce49347d, 0x7dcefa49, 0x7b8ddf52, 0x527ba48d, 0x3e429fdd, 0xdd3ea142, 0x7193cd5e, 0x5e71bc93, 0x97a2b113, 0x139726a2
+, 0xf504a2a6, 0xa6f55704, 0x68b801b9, 0xb96869b8, 0x0, 0x0, 0x2c74b5c1, 0xc12c9974, 0x60a0e040, 0x406080a0, 0x1f21c2e3, 0xe31fdd21, 0xc8433a79, 0x79c8f243, 0xed2c9ab6, 0xb6ed772c
+, 0xbed90dd4, 0xd4beb3d9, 0x46ca478d, 0x8d4601ca, 0xd9701767, 0x67d9ce70, 0x4bddaf72, 0x724be4dd, 0xde79ed94, 0x94de3379, 0xd467ff98, 0x98d42b67, 0xe82393b0, 0xb0e87b23, 0x4ade5b85, 0x854a11de
+, 0x6bbd06bb, 0xbb6b6dbd, 0x2a7ebbc5, 0xc52a917e, 0xe5347b4f, 0x4fe59e34, 0x163ad7ed, 0xed16c13a, 0xc554d286, 0x86c51754, 0xd762f89a, 0x9ad72f62, 0x55ff9966, 0x6655ccff, 0x94a7b611, 0x119422a7
+, 0xcf4ac08a, 0x8acf0f4a, 0x1030d9e9, 0xe910c930, 0x60a0e04, 0x406080a, 0x819866fe, 0xfe81e798, 0xf00baba0, 0xa0f05b0b, 0x44ccb478, 0x7844f0cc, 0xbad5f025, 0x25ba4ad5, 0xe33e754b, 0x4be3963e
+, 0xf30eaca2, 0xa2f35f0e, 0xfe19445d, 0x5dfeba19, 0xc05bdb80, 0x80c01b5b, 0x8a858005, 0x58a0a85, 0xadecd33f, 0x3fad7eec, 0xbcdffe21, 0x21bc42df, 0x48d8a870, 0x7048e0d8, 0x40cfdf1, 0xf104f90c
+, 0xdf7a1963, 0x63dfc67a, 0xc1582f77, 0x77c1ee58, 0x759f30af, 0xaf75459f, 0x63a5e742, 0x426384a5, 0x30507020, 0x20304050, 0x1a2ecbe5, 0xe51ad12e, 0xe12effd, 0xfd0ee112, 0x6db708bf, 0xbf6d65b7
+, 0x4cd45581, 0x814c19d4, 0x143c2418, 0x1814303c, 0x355f7926, 0x26354c5f, 0x2f71b2c3, 0xc32f9d71, 0xe13886be, 0xbee16738, 0xa2fdc835, 0x35a26afd, 0xcc4fc788, 0x88cc0b4f, 0x394b652e, 0x2e395c4b
+, 0x57f96a93, 0x93573df9, 0xf20d5855, 0x55f2aa0d, 0x829d61fc, 0xfc82e39d, 0x47c9b37a, 0x7a47f4c9, 0xacef27c8, 0xc8ac8bef, 0xe73288ba, 0xbae76f32, 0x2b7d4f32, 0x322b647d, 0x95a442e6, 0xe695d7a4
+, 0xa0fb3bc0, 0xc0a09bfb, 0x98b3aa19, 0x199832b3, 0xd168f69e, 0x9ed12768, 0x7f8122a3, 0xa37f5d81, 0x66aaee44, 0x446688aa, 0x7e82d654, 0x547ea882, 0xabe6dd3b, 0x3bab76e6, 0x839e950b, 0xb83169e
+, 0xca45c98c, 0x8cca0345, 0x297bbcc7, 0xc729957b, 0xd36e056b, 0x6bd3d66e, 0x3c446c28, 0x283c5044, 0x798b2ca7, 0xa779558b, 0xe23d81bc, 0xbce2633d, 0x1d273116, 0x161d2c27, 0x769a37ad, 0xad76419a
+, 0x3b4d96db, 0xdb3bad4d, 0x56fa9e64, 0x6456c8fa, 0x4ed2a674, 0x744ee8d2, 0x1e223614, 0x141e2822, 0xdb76e492, 0x92db3f76, 0xa1e120c, 0xc0a181e, 0x6cb4fc48, 0x486c90b4, 0xe4378fb8, 0xb8e46b37
+, 0x5de7789f, 0x9f5d25e7, 0x6eb20fbd, 0xbd6e61b2, 0xef2a6943, 0x43ef862a, 0xa6f135c4, 0xc4a693f1, 0xa8e3da39, 0x39a872e3, 0xa4f7c631, 0x31a462f7, 0x37598ad3, 0xd337bd59, 0x8b8674f2, 0xf28bff86
+, 0x325683d5, 0xd532b156, 0x43c54e8b, 0x8b430dc5, 0x59eb856e, 0x6e59dceb, 0xb7c218da, 0xdab7afc2, 0x8c8f8e01, 0x18c028f, 0x64ac1db1, 0xb16479ac, 0xd26df19c, 0x9cd2236d, 0xe03b7249, 0x49e0923b
+, 0xb4c71fd8, 0xd8b4abc7, 0xfa15b9ac, 0xacfa4315, 0x709faf3, 0xf307fd09, 0x256fa0cf, 0xcf25856f, 0xafea20ca, 0xcaaf8fea, 0x8e897df4, 0xf48ef389, 0xe9206747, 0x47e98e20, 0x18283810, 0x10182028
+, 0xd5640b6f, 0x6fd5de64, 0x888373f0, 0xf088fb83, 0x6fb1fb4a, 0x4a6f94b1, 0x7296ca5c, 0x5c72b896, 0x246c5438, 0x3824706c, 0xf1085f57, 0x57f1ae08, 0xc7522173, 0x73c7e652, 0x51f36497, 0x975135f3
+, 0x2365aecb, 0xcb238d65, 0x7c8425a1, 0xa17c5984, 0x9cbf57e8, 0xe89ccbbf, 0x21635d3e, 0x3e217c63, 0xdd7cea96, 0x96dd377c, 0xdc7f1e61, 0x61dcc27f, 0x86919c0d, 0xd861a91, 0x85949b0f, 0xf851e94
+, 0x90ab4be0, 0xe090dbab, 0x42c6ba7c, 0x7c42f8c6, 0xc4572671, 0x71c4e257, 0xaae529cc, 0xccaa83e5, 0xd873e390, 0x90d83b73, 0x50f0906, 0x6050c0f, 0x103f4f7, 0xf701f503, 0x12362a1c, 0x1c123836
+, 0xa3fe3cc2, 0xc2a39ffe, 0x5fe18b6a, 0x6a5fd4e1, 0xf910beae, 0xaef94710, 0xd06b0269, 0x69d0d26b, 0x91a8bf17, 0x17912ea8, 0x58e87199, 0x995829e8, 0x2769533a, 0x3a277469, 0xb9d0f727, 0x27b94ed0
+, 0x384891d9, 0xd938a948, 0x1335deeb, 0xeb13cd35, 0xb3cee52b, 0x2bb356ce, 0x33557722, 0x22334455, 0xbbd604d2, 0xd2bbbfd6, 0x709039a9, 0xa9704990, 0x89808707, 0x7890e80, 0xa7f2c133, 0x33a766f2
+, 0xb6c1ec2d, 0x2db65ac1, 0x22665a3c, 0x3c227866, 0x92adb815, 0x15922aad, 0x2060a9c9, 0xc9208960, 0x49db5c87, 0x874915db, 0xff1ab0aa, 0xaaff4f1a, 0x7888d850, 0x5078a088, 0x7a8e2ba5, 0xa57a518e
+, 0x8f8a8903, 0x38f068a, 0xf8134a59, 0x59f8b213, 0x809b9209, 0x980129b, 0x1739231a, 0x1a173439, 0xda751065, 0x65daca75, 0x315384d7, 0xd731b553, 0xc651d584, 0x84c61351, 0xb8d303d0, 0xd0b8bbd3
+, 0xc35edc82, 0x82c31f5e, 0xb0cbe229, 0x29b052cb, 0x7799c35a, 0x5a77b499, 0x11332d1e, 0x1e113c33, 0xcb463d7b, 0x7bcbf646, 0xfc1fb7a8, 0xa8fc4b1f, 0xd6610c6d, 0x6dd6da61, 0x3a4e622c, 0x2c3a584e
+};
+
+#define GROESTL_ROTATE_COLUMN_DOWN(v1, v2, amount_bytes, temp_var) {temp_var = (v1<<(8*amount_bytes))|(v2>>(8*(4-amount_bytes))); \
+															v2 = (v2<<(8*amount_bytes))|(v1>>(8*(4-amount_bytes))); \
+															v1 = temp_var;}
+
+#define GROESTL_COLUMN(x,y,i,c0,c1,c2,c3,c4,c5,c6,c7,tv1,tv2,tu,tl,t)				\
+   tu = d_groestl_T[2*(uint32_t)x[4*c0+0]];			    \
+   tl = d_groestl_T[2*(uint32_t)x[4*c0+0]+1];		    \
+   tv1 = d_groestl_T[2*(uint32_t)x[4*c1+1]];			\
+   tv2 = d_groestl_T[2*(uint32_t)x[4*c1+1]+1];			\
+   GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,1,t)	\
+   tu ^= tv1;						\
+   tl ^= tv2;						\
+   tv1 = d_groestl_T[2*(uint32_t)x[4*c2+2]];			\
+   tv2 = d_groestl_T[2*(uint32_t)x[4*c2+2]+1];			\
+   GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,2,t)	\
+   tu ^= tv1;						\
+   tl ^= tv2;   					\
+   tv1 = d_groestl_T[2*(uint32_t)x[4*c3+3]];			\
+   tv2 = d_groestl_T[2*(uint32_t)x[4*c3+3]+1];			\
+   GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,3,t)	\
+   tu ^= tv1;						\
+   tl ^= tv2;						\
+   tl ^= d_groestl_T[2*(uint32_t)x[4*c4+0]];			\
+   tu ^= d_groestl_T[2*(uint32_t)x[4*c4+0]+1];			\
+   tv1 = d_groestl_T[2*(uint32_t)x[4*c5+1]];			\
+   tv2 = d_groestl_T[2*(uint32_t)x[4*c5+1]+1];			\
+   GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,1,t)	\
+   tl ^= tv1;						\
+   tu ^= tv2;						\
+   tv1 = d_groestl_T[2*(uint32_t)x[4*c6+2]];			\
+   tv2 = d_groestl_T[2*(uint32_t)x[4*c6+2]+1];			\
+   GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,2,t)	\
+   tl ^= tv1;						\
+   tu ^= tv2;   					\
+   tv1 = d_groestl_T[2*(uint32_t)x[4*c7+3]];			\
+   tv2 = d_groestl_T[2*(uint32_t)x[4*c7+3]+1];			\
+   GROESTL_ROTATE_COLUMN_DOWN(tv1,tv2,3,t)	\
+   tl ^= tv1;						\
+   tu ^= tv2;						\
+   y[i] = tu;						\
    y[i+1] = tl;
 
-__device__
-void cn_groestl_RND512P(uint8_t * __restrict__ x, uint32_t * __restrict__ y, uint32_t r)
+__device__ void cn_groestl_RND512P(uint8_t * __restrict__ x, uint32_t * __restrict__ y, uint32_t r)
 {
-	uint32_t temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp;
-	uint32_t* x32 = (uint32_t*)x;
-	x32[ 0] ^= 0x00000000^r;
-	x32[ 2] ^= 0x00000010^r;
-	x32[ 4] ^= 0x00000020^r;
-	x32[ 6] ^= 0x00000030^r;
-	x32[ 8] ^= 0x00000040^r;
-	x32[10] ^= 0x00000050^r;
-	x32[12] ^= 0x00000060^r;
-	x32[14] ^= 0x00000070^r;
-	GROESTL_COLUMN(x,y, 0,  0,  2,  4,  6,  9, 11, 13, 15, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
-	GROESTL_COLUMN(x,y, 2,  2,  4,  6,  8, 11, 13, 15,  1, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
-	GROESTL_COLUMN(x,y, 4,  4,  6,  8, 10, 13, 15,  1,  3, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
-	GROESTL_COLUMN(x,y, 6,  6,  8, 10, 12, 15,  1,  3,  5, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
-	GROESTL_COLUMN(x,y, 8,  8, 10, 12, 14,  1,  3,  5,  7, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
-	GROESTL_COLUMN(x,y,10, 10, 12, 14,  0,  3,  5,  7,  9, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
-	GROESTL_COLUMN(x,y,12, 12, 14,  0,  2,  5,  7,  9, 11, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
-	GROESTL_COLUMN(x,y,14, 14,  0,  2,  4,  7,  9, 11, 13, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    uint32_t temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp;
+    uint32_t* x32 = (uint32_t*)x;
+    x32[ 0] ^= 0x00000000^r;
+    x32[ 2] ^= 0x00000010^r;
+    x32[ 4] ^= 0x00000020^r;
+    x32[ 6] ^= 0x00000030^r;
+    x32[ 8] ^= 0x00000040^r;
+    x32[10] ^= 0x00000050^r;
+    x32[12] ^= 0x00000060^r;
+    x32[14] ^= 0x00000070^r;
+    GROESTL_COLUMN(x,y, 0,  0,  2,  4,  6,  9, 11, 13, 15, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    GROESTL_COLUMN(x,y, 2,  2,  4,  6,  8, 11, 13, 15,  1, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    GROESTL_COLUMN(x,y, 4,  4,  6,  8, 10, 13, 15,  1,  3, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    GROESTL_COLUMN(x,y, 6,  6,  8, 10, 12, 15,  1,  3,  5, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    GROESTL_COLUMN(x,y, 8,  8, 10, 12, 14,  1,  3,  5,  7, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    GROESTL_COLUMN(x,y,10, 10, 12, 14,  0,  3,  5,  7,  9, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    GROESTL_COLUMN(x,y,12, 12, 14,  0,  2,  5,  7,  9, 11, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    GROESTL_COLUMN(x,y,14, 14,  0,  2,  4,  7,  9, 11, 13, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
 }
 
-__device__
-void cn_groestl_RND512Q(uint8_t * __restrict__ x, uint32_t * __restrict__ y, uint32_t r)
+__device__ void cn_groestl_RND512Q(uint8_t * __restrict__ x, uint32_t * __restrict__ y, uint32_t r)
 {
-	uint32_t temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp;
-	uint32_t* x32 = (uint32_t*)x;
-	x32[ 0] = ~x32[ 0];
-	x32[ 1] ^= 0xffffffff^r;
-	x32[ 2] = ~x32[ 2];
-	x32[ 3] ^= 0xefffffff^r;
-	x32[ 4] = ~x32[ 4];
-	x32[ 5] ^= 0xdfffffff^r;
-	x32[ 6] = ~x32[ 6];
-	x32[ 7] ^= 0xcfffffff^r;
-	x32[ 8] = ~x32[ 8];
-	x32[ 9] ^= 0xbfffffff^r;
-	x32[10] = ~x32[10];
-	x32[11] ^= 0xafffffff^r;
-	x32[12] = ~x32[12];
-	x32[13] ^= 0x9fffffff^r;
-	x32[14] = ~x32[14];
-	x32[15] ^= 0x8fffffff^r;
-	GROESTL_COLUMN(x,y, 0,  2,  6, 10, 14,  1,  5,  9, 13, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
-	GROESTL_COLUMN(x,y, 2,  4,  8, 12,  0,  3,  7, 11, 15, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
-	GROESTL_COLUMN(x,y, 4,  6, 10, 14,  2,  5,  9, 13,  1, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
-	GROESTL_COLUMN(x,y, 6,  8, 12,  0,  4,  7, 11, 15,  3, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
-	GROESTL_COLUMN(x,y, 8, 10, 14,  2,  6,  9, 13,  1,  5, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
-	GROESTL_COLUMN(x,y,10, 12,  0,  4,  8, 11, 15,  3,  7, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
-	GROESTL_COLUMN(x,y,12, 14,  2,  6, 10, 13,  1,  5,  9, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
-	GROESTL_COLUMN(x,y,14,  0,  4,  8, 12, 15,  3,  7, 11, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    uint32_t temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp;
+    uint32_t* x32 = (uint32_t*)x;
+    x32[ 0] = ~x32[ 0];
+    x32[ 1] ^= 0xffffffff^r;
+    x32[ 2] = ~x32[ 2];
+    x32[ 3] ^= 0xefffffff^r;
+    x32[ 4] = ~x32[ 4];
+    x32[ 5] ^= 0xdfffffff^r;
+    x32[ 6] = ~x32[ 6];
+    x32[ 7] ^= 0xcfffffff^r;
+    x32[ 8] = ~x32[ 8];
+    x32[ 9] ^= 0xbfffffff^r;
+    x32[10] = ~x32[10];
+    x32[11] ^= 0xafffffff^r;
+    x32[12] = ~x32[12];
+    x32[13] ^= 0x9fffffff^r;
+    x32[14] = ~x32[14];
+    x32[15] ^= 0x8fffffff^r;
+    GROESTL_COLUMN(x,y, 0,  2,  6, 10, 14,  1,  5,  9, 13, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    GROESTL_COLUMN(x,y, 2,  4,  8, 12,  0,  3,  7, 11, 15, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    GROESTL_COLUMN(x,y, 4,  6, 10, 14,  2,  5,  9, 13,  1, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    GROESTL_COLUMN(x,y, 6,  8, 12,  0,  4,  7, 11, 15,  3, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    GROESTL_COLUMN(x,y, 8, 10, 14,  2,  6,  9, 13,  1,  5, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    GROESTL_COLUMN(x,y,10, 12,  0,  4,  8, 11, 15,  3,  7, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    GROESTL_COLUMN(x,y,12, 14,  2,  6, 10, 13,  1,  5,  9, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
+    GROESTL_COLUMN(x,y,14,  0,  4,  8, 12, 15,  3,  7, 11, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);
 }
 
-__device__
-void cn_groestl_F512(uint32_t * __restrict__ h, const uint32_t * __restrict__ m)
+__device__ void cn_groestl_F512(uint32_t * __restrict__ h, const uint32_t * __restrict__ m)
 {
-	int i;
-	uint32_t Ptmp[2*GROESTL_COLS512];
-	uint32_t Qtmp[2*GROESTL_COLS512];
-	uint32_t y[2*GROESTL_COLS512];
-	uint32_t z[2*GROESTL_COLS512];
-
-	for (i = 0; i < 2*GROESTL_COLS512; i++) {
-		z[i] = m[i];
-		Ptmp[i] = h[i]^m[i];
-	}
-
-	cn_groestl_RND512Q((uint8_t*)z, y, 0x00000000);
-	cn_groestl_RND512Q((uint8_t*)y, z, 0x01000000);
-	cn_groestl_RND512Q((uint8_t*)z, y, 0x02000000);
-	cn_groestl_RND512Q((uint8_t*)y, z, 0x03000000);
-	cn_groestl_RND512Q((uint8_t*)z, y, 0x04000000);
-	cn_groestl_RND512Q((uint8_t*)y, z, 0x05000000);
-	cn_groestl_RND512Q((uint8_t*)z, y, 0x06000000);
-	cn_groestl_RND512Q((uint8_t*)y, z, 0x07000000);
-	cn_groestl_RND512Q((uint8_t*)z, y, 0x08000000);
-	cn_groestl_RND512Q((uint8_t*)y, Qtmp, 0x09000000);
-
-	cn_groestl_RND512P((uint8_t*)Ptmp, y, 0x00000000);
-	cn_groestl_RND512P((uint8_t*)y, z, 0x00000001);
-	cn_groestl_RND512P((uint8_t*)z, y, 0x00000002);
-	cn_groestl_RND512P((uint8_t*)y, z, 0x00000003);
-	cn_groestl_RND512P((uint8_t*)z, y, 0x00000004);
-	cn_groestl_RND512P((uint8_t*)y, z, 0x00000005);
-	cn_groestl_RND512P((uint8_t*)z, y, 0x00000006);
-	cn_groestl_RND512P((uint8_t*)y, z, 0x00000007);
-	cn_groestl_RND512P((uint8_t*)z, y, 0x00000008);
-	cn_groestl_RND512P((uint8_t*)y, Ptmp, 0x00000009);
-
-	for (i = 0; i < 2*GROESTL_COLS512; i++)
-		h[i] ^= Ptmp[i]^Qtmp[i];
+    int i;
+    uint32_t Ptmp[2*GROESTL_COLS512];
+    uint32_t Qtmp[2*GROESTL_COLS512];
+    uint32_t y[2*GROESTL_COLS512];
+    uint32_t z[2*GROESTL_COLS512];
+
+    for (i = 0; i < 2*GROESTL_COLS512; i++) {
+        z[i] = m[i];
+        Ptmp[i] = h[i]^m[i];
+    }
+
+    cn_groestl_RND512Q((uint8_t*)z, y, 0x00000000);
+    cn_groestl_RND512Q((uint8_t*)y, z, 0x01000000);
+    cn_groestl_RND512Q((uint8_t*)z, y, 0x02000000);
+    cn_groestl_RND512Q((uint8_t*)y, z, 0x03000000);
+    cn_groestl_RND512Q((uint8_t*)z, y, 0x04000000);
+    cn_groestl_RND512Q((uint8_t*)y, z, 0x05000000);
+    cn_groestl_RND512Q((uint8_t*)z, y, 0x06000000);
+    cn_groestl_RND512Q((uint8_t*)y, z, 0x07000000);
+    cn_groestl_RND512Q((uint8_t*)z, y, 0x08000000);
+    cn_groestl_RND512Q((uint8_t*)y, Qtmp, 0x09000000);
+
+    cn_groestl_RND512P((uint8_t*)Ptmp, y, 0x00000000);
+    cn_groestl_RND512P((uint8_t*)y, z, 0x00000001);
+    cn_groestl_RND512P((uint8_t*)z, y, 0x00000002);
+    cn_groestl_RND512P((uint8_t*)y, z, 0x00000003);
+    cn_groestl_RND512P((uint8_t*)z, y, 0x00000004);
+    cn_groestl_RND512P((uint8_t*)y, z, 0x00000005);
+    cn_groestl_RND512P((uint8_t*)z, y, 0x00000006);
+    cn_groestl_RND512P((uint8_t*)y, z, 0x00000007);
+    cn_groestl_RND512P((uint8_t*)z, y, 0x00000008);
+    cn_groestl_RND512P((uint8_t*)y, Ptmp, 0x00000009);
+
+    for (i = 0; i < 2*GROESTL_COLS512; i++)
+        h[i] ^= Ptmp[i]^Qtmp[i];
 }
 
-__device__
-void cn_groestl_outputtransformation(groestlHashState *ctx)
+__device__ void cn_groestl_outputtransformation(groestlHashState *ctx)
 {
-	int j;
-	uint32_t temp[2*GROESTL_COLS512];
-	uint32_t y[2*GROESTL_COLS512];
-	uint32_t z[2*GROESTL_COLS512];
-
-	for (j = 0; j < 2*GROESTL_COLS512; j++)
-		temp[j] = ctx->chaining[j];
-
-	cn_groestl_RND512P((uint8_t*)temp, y, 0x00000000);
-	cn_groestl_RND512P((uint8_t*)y, z, 0x00000001);
-	cn_groestl_RND512P((uint8_t*)z, y, 0x00000002);
-	cn_groestl_RND512P((uint8_t*)y, z, 0x00000003);
-	cn_groestl_RND512P((uint8_t*)z, y, 0x00000004);
-	cn_groestl_RND512P((uint8_t*)y, z, 0x00000005);
-	cn_groestl_RND512P((uint8_t*)z, y, 0x00000006);
-	cn_groestl_RND512P((uint8_t*)y, z, 0x00000007);
-	cn_groestl_RND512P((uint8_t*)z, y, 0x00000008);
-	cn_groestl_RND512P((uint8_t*)y, temp, 0x00000009);
-
-	for (j = 0; j < 2*GROESTL_COLS512; j++)
-		ctx->chaining[j] ^= temp[j];
+    int j;
+    uint32_t temp[2*GROESTL_COLS512];
+    uint32_t y[2*GROESTL_COLS512];
+    uint32_t z[2*GROESTL_COLS512];
+
+    for (j = 0; j < 2*GROESTL_COLS512; j++)
+        temp[j] = ctx->chaining[j];
+
+    cn_groestl_RND512P((uint8_t*)temp, y, 0x00000000);
+    cn_groestl_RND512P((uint8_t*)y, z, 0x00000001);
+    cn_groestl_RND512P((uint8_t*)z, y, 0x00000002);
+    cn_groestl_RND512P((uint8_t*)y, z, 0x00000003);
+    cn_groestl_RND512P((uint8_t*)z, y, 0x00000004);
+    cn_groestl_RND512P((uint8_t*)y, z, 0x00000005);
+    cn_groestl_RND512P((uint8_t*)z, y, 0x00000006);
+    cn_groestl_RND512P((uint8_t*)y, z, 0x00000007);
+    cn_groestl_RND512P((uint8_t*)z, y, 0x00000008);
+    cn_groestl_RND512P((uint8_t*)y, temp, 0x00000009);
+    
+    for (j = 0; j < 2*GROESTL_COLS512; j++)
+        ctx->chaining[j] ^= temp[j];
 }
 
-__device__
-void cn_groestl_transform(groestlHashState * __restrict__ ctx,
-	const uint8_t * __restrict__ input, int msglen)
+__device__ void cn_groestl_transform(groestlHashState * __restrict__ ctx,
+																		 const uint8_t * __restrict__ input,
+	       int msglen) 
 {
-	for (; msglen >= GROESTL_SIZE512; msglen -= GROESTL_SIZE512, input += GROESTL_SIZE512) {
-		cn_groestl_F512(ctx->chaining,(uint32_t*)input);
-		ctx->block_counter1++;
-		if (ctx->block_counter1 == 0) ctx->block_counter2++;
-	}
+    for (; msglen >= GROESTL_SIZE512; msglen -= GROESTL_SIZE512, input += GROESTL_SIZE512) {
+        cn_groestl_F512(ctx->chaining,(uint32_t*)input);
+        ctx->block_counter1++;
+        if (ctx->block_counter1 == 0) ctx->block_counter2++;
+    }
 }
 
-__device__
-void cn_groestl_final(groestlHashState*  __restrict__ ctx, BitSequence* __restrict__  output)
+__device__ void cn_groestl_final(groestlHashState*  __restrict__ ctx,
+																 BitSequence* __restrict__  output)
 {
-	int i, j = 0, hashbytelen = GROESTL_HASH_BIT_LEN/8;
-	uint8_t *s = (BitSequence*)ctx->chaining;
-
-	if (ctx->bits_in_last_byte) {
-		ctx->buffer[(int)ctx->buf_ptr-1] &= ((1<<ctx->bits_in_last_byte)-1)<<(8-ctx->bits_in_last_byte);
-		ctx->buffer[(int)ctx->buf_ptr-1] ^= 0x1<<(7-ctx->bits_in_last_byte);
-		ctx->bits_in_last_byte = 0;
-	}
-	else ctx->buffer[(int)ctx->buf_ptr++] = 0x80;
-
-	if (ctx->buf_ptr > GROESTL_SIZE512-GROESTL_LENGTHFIELDLEN) {
-		while (ctx->buf_ptr < GROESTL_SIZE512) {
-			ctx->buffer[(int)ctx->buf_ptr++] = 0;
-		}
-		cn_groestl_transform(ctx, ctx->buffer, GROESTL_SIZE512);
-		ctx->buf_ptr = 0;
-	}
-	while (ctx->buf_ptr < GROESTL_SIZE512-GROESTL_LENGTHFIELDLEN) {
-		ctx->buffer[(int)ctx->buf_ptr++] = 0;
-	}
-
-	ctx->block_counter1++;
-	if (ctx->block_counter1 == 0) ctx->block_counter2++;
-	ctx->buf_ptr = GROESTL_SIZE512;
-
-	while (ctx->buf_ptr > GROESTL_SIZE512-(int)sizeof(uint32_t)) {
-		ctx->buffer[(int)--ctx->buf_ptr] = (uint8_t)ctx->block_counter1;
-		ctx->block_counter1 >>= 8;
-	}
-	while (ctx->buf_ptr > GROESTL_SIZE512-GROESTL_LENGTHFIELDLEN) {
-		ctx->buffer[(int)--ctx->buf_ptr] = (uint8_t)ctx->block_counter2;
-		ctx->block_counter2 >>= 8;
-	}
-	cn_groestl_transform(ctx, ctx->buffer, GROESTL_SIZE512);
-	cn_groestl_outputtransformation(ctx);
-
-	for (i = GROESTL_SIZE512-hashbytelen; i < GROESTL_SIZE512; i++,j++) {
-		output[j] = s[i];
-	}
-
-	for (i = 0; i < GROESTL_COLS512; i++) {
-		ctx->chaining[i] = 0;
-	}
-	for (i = 0; i < GROESTL_SIZE512; i++) {
-		ctx->buffer[i] = 0;
-	}
+    int i, j = 0, hashbytelen = GROESTL_HASH_BIT_LEN/8;
+    uint8_t *s = (BitSequence*)ctx->chaining;
+
+    if (ctx->bits_in_last_byte) {
+        ctx->buffer[(int)ctx->buf_ptr-1] &= ((1<<ctx->bits_in_last_byte)-1)<<(8-ctx->bits_in_last_byte);
+        ctx->buffer[(int)ctx->buf_ptr-1] ^= 0x1<<(7-ctx->bits_in_last_byte);
+        ctx->bits_in_last_byte = 0;
+    }
+    else ctx->buffer[(int)ctx->buf_ptr++] = 0x80;
+
+    if (ctx->buf_ptr > GROESTL_SIZE512-GROESTL_LENGTHFIELDLEN) {
+        while (ctx->buf_ptr < GROESTL_SIZE512) {
+            ctx->buffer[(int)ctx->buf_ptr++] = 0;
+        }
+        cn_groestl_transform(ctx, ctx->buffer, GROESTL_SIZE512);
+        ctx->buf_ptr = 0;
+    }
+    while (ctx->buf_ptr < GROESTL_SIZE512-GROESTL_LENGTHFIELDLEN) {
+        ctx->buffer[(int)ctx->buf_ptr++] = 0;
+    }
+
+    ctx->block_counter1++;
+    if (ctx->block_counter1 == 0) ctx->block_counter2++;
+    ctx->buf_ptr = GROESTL_SIZE512;
+
+    while (ctx->buf_ptr > GROESTL_SIZE512-(int)sizeof(uint32_t)) {
+        ctx->buffer[(int)--ctx->buf_ptr] = (uint8_t)ctx->block_counter1;
+        ctx->block_counter1 >>= 8;
+    }
+    while (ctx->buf_ptr > GROESTL_SIZE512-GROESTL_LENGTHFIELDLEN) {
+        ctx->buffer[(int)--ctx->buf_ptr] = (uint8_t)ctx->block_counter2;
+        ctx->block_counter2 >>= 8;
+    }
+    cn_groestl_transform(ctx, ctx->buffer, GROESTL_SIZE512); 
+    cn_groestl_outputtransformation(ctx);
+
+    for (i = GROESTL_SIZE512-hashbytelen; i < GROESTL_SIZE512; i++,j++) {
+        output[j] = s[i];
+    }
+
+    for (i = 0; i < GROESTL_COLS512; i++) {
+        ctx->chaining[i] = 0;
+    }
+    for (i = 0; i < GROESTL_SIZE512; i++) {
+        ctx->buffer[i] = 0;
+    }
 }
 
-__device__
-void cn_groestl_update(groestlHashState* __restrict__ ctx,
-	const BitSequence* __restrict__ input, DataLength databitlen)
+__device__ void cn_groestl_update(groestlHashState* __restrict__ ctx,
+																	const BitSequence* __restrict__ input, DataLength databitlen)
 {
-	int index = 0;
-	int msglen = (int)(databitlen/8);
-	int rem = (int)(databitlen%8);
-
-	if (ctx->buf_ptr) {
-		while (ctx->buf_ptr < GROESTL_SIZE512 && index < msglen) {
-			ctx->buffer[(int)ctx->buf_ptr++] = input[index++];
-		}
-		if (ctx->buf_ptr < GROESTL_SIZE512) {
-			if (rem) {
-				ctx->bits_in_last_byte = rem;
-				ctx->buffer[(int)ctx->buf_ptr++] = input[index];
-			}
-			return;
-		}
-
-		ctx->buf_ptr = 0;
-		cn_groestl_transform(ctx, ctx->buffer, GROESTL_SIZE512);
-	}
-
-	cn_groestl_transform(ctx, input+index, msglen-index);
-	index += ((msglen-index)/GROESTL_SIZE512)*GROESTL_SIZE512;
-
-	while (index < msglen) {
-		ctx->buffer[(int)ctx->buf_ptr++] = input[index++];
-	}
-
-	if (rem) {
-		ctx->bits_in_last_byte = rem;
-		ctx->buffer[(int)ctx->buf_ptr++] = input[index];
-	}
+    int index = 0;
+    int msglen = (int)(databitlen/8);
+    int rem = (int)(databitlen%8);
+
+    if (ctx->buf_ptr) {
+        while (ctx->buf_ptr < GROESTL_SIZE512 && index < msglen) {
+            ctx->buffer[(int)ctx->buf_ptr++] = input[index++];
+        }
+        if (ctx->buf_ptr < GROESTL_SIZE512) {
+            if (rem) {
+                ctx->bits_in_last_byte = rem;
+                ctx->buffer[(int)ctx->buf_ptr++] = input[index];
+            }
+            return;
+        }
+
+        ctx->buf_ptr = 0;
+        cn_groestl_transform(ctx, ctx->buffer, GROESTL_SIZE512);
+    }
+
+    cn_groestl_transform(ctx, input+index, msglen-index);
+    index += ((msglen-index)/GROESTL_SIZE512)*GROESTL_SIZE512;
+
+    while (index < msglen) {
+        ctx->buffer[(int)ctx->buf_ptr++] = input[index++];
+    }
+
+    if (rem) {
+        ctx->bits_in_last_byte = rem;
+        ctx->buffer[(int)ctx->buf_ptr++] = input[index];
+    }
 }
 
-__device__
-void cn_groestl_init(groestlHashState* ctx)
+__device__ void cn_groestl_init(groestlHashState* ctx)
 {
-	int i = 0;
+    int i = 0;
 
-	for(;i<(GROESTL_SIZE512/sizeof(uint32_t));i++)
-		ctx->chaining[i] = 0;
+    for(;i<(GROESTL_SIZE512/sizeof(uint32_t));i++)
+        ctx->chaining[i] = 0;
 
-	ctx->chaining[2*GROESTL_COLS512-1] = u32BIG((uint32_t)GROESTL_HASH_BIT_LEN);
-	ctx->buf_ptr = 0;
-	ctx->block_counter1 = 0;
-	ctx->block_counter2 = 0;
-	ctx->bits_in_last_byte = 0;
+    ctx->chaining[2*GROESTL_COLS512-1] = u32BIG((uint32_t)GROESTL_HASH_BIT_LEN);
+    ctx->buf_ptr = 0;
+    ctx->block_counter1 = 0;
+    ctx->block_counter2 = 0;
+    ctx->bits_in_last_byte = 0;
 }
 
-__device__
-void cn_groestl(const BitSequence * __restrict__ data, DataLength len, BitSequence * __restrict__ hashval)
+__device__ void cn_groestl(const BitSequence * __restrict__ data, DataLength len, BitSequence * __restrict__ hashval)
 {
-	DataLength databitlen = len << 3;
-	groestlHashState context;
+    DataLength databitlen = len << 3;
+    groestlHashState context;
 
-	cn_groestl_init(&context);
-	cn_groestl_update(&context, data, databitlen);
-	cn_groestl_final(&context, hashval);
-}
+    cn_groestl_init(&context);
+    cn_groestl_update(&context, data, databitlen);
+    cn_groestl_final(&context, hashval);
+}
\ No newline at end of file
diff --git a/crypto/cn_jh.cuh b/crypto/cn_jh.cuh
index c2df76378..e98343ec3 100644
--- a/crypto/cn_jh.cuh
+++ b/crypto/cn_jh.cuh
@@ -7,7 +7,8 @@ typedef struct {
 	unsigned char buffer[64];
 } jhHashState;
 
-__constant__ unsigned char d_JH256_H0[512] = {
+__constant__ unsigned char d_JH256_H0[512] =
+{
 	0xeb, 0x98, 0xa3, 0x41, 0x2c, 0x20, 0xd3, 0xeb, 0x92, 0xcd, 0xbe, 0x7b, 0x9c, 0xb2, 0x45, 0xc1,
 	0x1c, 0x93, 0x51, 0x91, 0x60, 0xd4, 0xc7, 0xfa, 0x26, 0x0, 0x82, 0xd6, 0x7e, 0x50, 0x8a, 0x3,
 	0xa4, 0x23, 0x9e, 0x26, 0x77, 0x26, 0xb9, 0x45, 0xe0, 0xfb, 0x1a, 0x48, 0xd4, 0x1a, 0x94, 0x77,
@@ -18,7 +19,8 @@ __constant__ unsigned char d_JH256_H0[512] = {
 	0x7b, 0xe4, 0xd3, 0x67, 0x70, 0x24, 0x12, 0xea, 0x89, 0xe3, 0xab, 0x13, 0xd3, 0x1c, 0xd7, 0x69
 };
 
-__constant__ unsigned char d_E8_rc[42][32] = {
+__constant__ unsigned char d_E8_rc[42][32] =
+{
 	{0x72, 0xd5, 0xde, 0xa2, 0xdf, 0x15, 0xf8, 0x67, 0x7b, 0x84, 0x15, 0xa, 0xb7, 0x23, 0x15, 0x57, 0x81, 0xab, 0xd6, 0x90, 0x4d, 0x5a, 0x87, 0xf6, 0x4e, 0x9f, 0x4f, 0xc5, 0xc3, 0xd1, 0x2b, 0x40},
 	{0xea, 0x98, 0x3a, 0xe0, 0x5c, 0x45, 0xfa, 0x9c, 0x3, 0xc5, 0xd2, 0x99, 0x66, 0xb2, 0x99, 0x9a, 0x66, 0x2, 0x96, 0xb4, 0xf2, 0xbb, 0x53, 0x8a, 0xb5, 0x56, 0x14, 0x1a, 0x88, 0xdb, 0xa2, 0x31},
 	{0x3, 0xa3, 0x5a, 0x5c, 0x9a, 0x19, 0xe, 0xdb, 0x40, 0x3f, 0xb2, 0xa, 0x87, 0xc1, 0x44, 0x10, 0x1c, 0x5, 0x19, 0x80, 0x84, 0x9e, 0x95, 0x1d, 0x6f, 0x33, 0xeb, 0xad, 0x5e, 0xe7, 0xcd, 0xdc},
@@ -71,224 +73,204 @@ __constant__ unsigned char d_E8_rc[42][32] = {
 #define JH_SWAP32(x)  (x) = (((x) << 32) | ((x) >> 32));
 
 #define JH_L(m0,m1,m2,m3,m4,m5,m6,m7) \
-	(m4) ^= (m1);                \
-	(m5) ^= (m2);                \
-	(m6) ^= (m0) ^ (m3);         \
-	(m7) ^= (m0);                \
-	(m0) ^= (m5);                \
-	(m1) ^= (m6);                \
-	(m2) ^= (m4) ^ (m7);         \
-	(m3) ^= (m4);
+      (m4) ^= (m1);                \
+      (m5) ^= (m2);                \
+      (m6) ^= (m0) ^ (m3);         \
+      (m7) ^= (m0);                \
+      (m0) ^= (m5);                \
+      (m1) ^= (m6);                \
+      (m2) ^= (m4) ^ (m7);         \
+      (m3) ^= (m4);
 
 #define JH_SS(m0,m1,m2,m3,m4,m5,m6,m7,cc0,cc1)   \
-	m3  = ~(m3);                  \
-	m7  = ~(m7);                  \
-	m0 ^= ((~(m2)) & (cc0));      \
-	m4 ^= ((~(m6)) & (cc1));      \
-	temp0 = (cc0) ^ ((m0) & (m1));\
-	temp1 = (cc1) ^ ((m4) & (m5));\
-	m0 ^= ((m2) & (m3));          \
-	m4 ^= ((m6) & (m7));          \
-	m3 ^= ((~(m1)) & (m2));       \
-	m7 ^= ((~(m5)) & (m6));       \
-	m1 ^= ((m0) & (m2));          \
-	m5 ^= ((m4) & (m6));          \
-	m2 ^= ((m0) & (~(m3)));       \
-	m6 ^= ((m4) & (~(m7)));       \
-	m0 ^= ((m1) | (m3));          \
-	m4 ^= ((m5) | (m7));          \
-	m3 ^= ((m1) & (m2));          \
-	m7 ^= ((m5) & (m6));          \
-	m1 ^= (temp0 & (m0));         \
-	m5 ^= (temp1 & (m4));         \
-	m2 ^= temp0;                  \
-	m6 ^= temp1;
-
-__device__
-void cn_jh_E8(jhHashState *state)
+      m3  = ~(m3);                  \
+      m7  = ~(m7);                  \
+      m0 ^= ((~(m2)) & (cc0));      \
+      m4 ^= ((~(m6)) & (cc1));      \
+      temp0 = (cc0) ^ ((m0) & (m1));\
+      temp1 = (cc1) ^ ((m4) & (m5));\
+      m0 ^= ((m2) & (m3));          \
+      m4 ^= ((m6) & (m7));          \
+      m3 ^= ((~(m1)) & (m2));       \
+      m7 ^= ((~(m5)) & (m6));       \
+      m1 ^= ((m0) & (m2));          \
+      m5 ^= ((m4) & (m6));          \
+      m2 ^= ((m0) & (~(m3)));       \
+      m6 ^= ((m4) & (~(m7)));       \
+      m0 ^= ((m1) | (m3));          \
+      m4 ^= ((m5) | (m7));          \
+      m3 ^= ((m1) & (m2));          \
+      m7 ^= ((m5) & (m6));          \
+      m1 ^= (temp0 & (m0));         \
+      m5 ^= (temp1 & (m4));         \
+      m2 ^= temp0;                  \
+      m6 ^= temp1;
+
+__device__ void cn_jh_E8(jhHashState *state)
 {
-	uint64_t i,roundnumber,temp0,temp1;
-
-	for (roundnumber = 0; roundnumber < 42; roundnumber = roundnumber+7)
-	{
-		for (i = 0; i < 2; i++) {
-			JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],
-				((uint64_t *)d_E8_rc[roundnumber+0])[i],((uint64_t *)d_E8_rc[roundnumber+0])[i+2] );
-			JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
-			JH_SWAP1(state->x[1][i]); JH_SWAP1(state->x[3][i]); JH_SWAP1(state->x[5][i]); JH_SWAP1(state->x[7][i]);
-		}
-
-		for (i = 0; i < 2; i++) {
-			JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],
-				((uint64_t *)d_E8_rc[roundnumber+1])[i],((uint64_t *)d_E8_rc[roundnumber+1])[i+2] );
-			JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
-			JH_SWAP2(state->x[1][i]); JH_SWAP2(state->x[3][i]); JH_SWAP2(state->x[5][i]); JH_SWAP2(state->x[7][i]);
-		}
-
-		for (i = 0; i < 2; i++) {
-			JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],
-				((uint64_t *)d_E8_rc[roundnumber+2])[i],((uint64_t *)d_E8_rc[roundnumber+2])[i+2] );
-			JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
-			JH_SWAP4(state->x[1][i]); JH_SWAP4(state->x[3][i]); JH_SWAP4(state->x[5][i]); JH_SWAP4(state->x[7][i]);
-		}
-
-		for (i = 0; i < 2; i++) {
-			JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],
-				((uint64_t *)d_E8_rc[roundnumber+3])[i],((uint64_t *)d_E8_rc[roundnumber+3])[i+2] );
-			JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
-			JH_SWAP8(state->x[1][i]); JH_SWAP8(state->x[3][i]); JH_SWAP8(state->x[5][i]); JH_SWAP8(state->x[7][i]);
-		}
-
-		for (i = 0; i < 2; i++) {
-			JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],
-				((uint64_t *)d_E8_rc[roundnumber+4])[i],((uint64_t *)d_E8_rc[roundnumber+4])[i+2] );
-			JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
-			JH_SWAP16(state->x[1][i]); JH_SWAP16(state->x[3][i]); JH_SWAP16(state->x[5][i]); JH_SWAP16(state->x[7][i]);
-		}
-
-		for (i = 0; i < 2; i++) {
-			JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],
-				((uint64_t *)d_E8_rc[roundnumber+5])[i],((uint64_t *)d_E8_rc[roundnumber+5])[i+2] );
-			JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
-			JH_SWAP32(state->x[1][i]); JH_SWAP32(state->x[3][i]); JH_SWAP32(state->x[5][i]); JH_SWAP32(state->x[7][i]);
-		}
-
-		for (i = 0; i < 2; i++) {
-			JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],
-				((uint64_t *)d_E8_rc[roundnumber+6])[i],((uint64_t *)d_E8_rc[roundnumber+6])[i+2] );
-			JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
-		}
-
-		for (i = 1; i < 8; i = i+2) {
-			temp0 = state->x[i][0]; state->x[i][0] = state->x[i][1]; state->x[i][1] = temp0;
-		}
-	}
+      uint64_t i,roundnumber,temp0,temp1;
+
+      for (roundnumber = 0; roundnumber < 42; roundnumber = roundnumber+7) {
+
+            for (i = 0; i < 2; i++) {
+                  JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64_t *)d_E8_rc[roundnumber+0])[i],((uint64_t *)d_E8_rc[roundnumber+0])[i+2] );
+                  JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
+                  JH_SWAP1(state->x[1][i]); JH_SWAP1(state->x[3][i]); JH_SWAP1(state->x[5][i]); JH_SWAP1(state->x[7][i]);
+            }
+
+            for (i = 0; i < 2; i++) {
+                  JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64_t *)d_E8_rc[roundnumber+1])[i],((uint64_t *)d_E8_rc[roundnumber+1])[i+2] );
+                  JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
+                  JH_SWAP2(state->x[1][i]); JH_SWAP2(state->x[3][i]); JH_SWAP2(state->x[5][i]); JH_SWAP2(state->x[7][i]);
+            }
+
+            for (i = 0; i < 2; i++) {
+                  JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64_t *)d_E8_rc[roundnumber+2])[i],((uint64_t *)d_E8_rc[roundnumber+2])[i+2] );
+                  JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
+                  JH_SWAP4(state->x[1][i]); JH_SWAP4(state->x[3][i]); JH_SWAP4(state->x[5][i]); JH_SWAP4(state->x[7][i]);
+            }
+
+            for (i = 0; i < 2; i++) {
+                  JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64_t *)d_E8_rc[roundnumber+3])[i],((uint64_t *)d_E8_rc[roundnumber+3])[i+2] );
+                  JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
+                  JH_SWAP8(state->x[1][i]); JH_SWAP8(state->x[3][i]); JH_SWAP8(state->x[5][i]); JH_SWAP8(state->x[7][i]);
+            }
+
+            for (i = 0; i < 2; i++) {
+                  JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64_t *)d_E8_rc[roundnumber+4])[i],((uint64_t *)d_E8_rc[roundnumber+4])[i+2] );
+                  JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
+                  JH_SWAP16(state->x[1][i]); JH_SWAP16(state->x[3][i]); JH_SWAP16(state->x[5][i]); JH_SWAP16(state->x[7][i]);
+            }
+
+            for (i = 0; i < 2; i++) {
+                  JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64_t *)d_E8_rc[roundnumber+5])[i],((uint64_t *)d_E8_rc[roundnumber+5])[i+2] );
+                  JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
+                  JH_SWAP32(state->x[1][i]); JH_SWAP32(state->x[3][i]); JH_SWAP32(state->x[5][i]); JH_SWAP32(state->x[7][i]);
+            }
+
+            for (i = 0; i < 2; i++) {
+                  JH_SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64_t *)d_E8_rc[roundnumber+6])[i],((uint64_t *)d_E8_rc[roundnumber+6])[i+2] );
+                  JH_L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);
+            }
+
+            for (i = 1; i < 8; i = i+2) {
+                  temp0 = state->x[i][0]; state->x[i][0] = state->x[i][1]; state->x[i][1] = temp0;
+            }
+      }
 }
 
-__device__
-void cn_jh_F8(jhHashState *state)
+__device__ void cn_jh_F8(jhHashState *state)
 {
-	uint64_t i;
-	for (i = 0; i < 8; i++) {
-		state->x[i >> 1][i & 1] ^= ((uint64_t *)state->buffer)[i];
-	}
+      uint64_t i;
+
+      for (i = 0; i < 8; i++)  state->x[i >> 1][i & 1] ^= ((uint64_t *)state->buffer)[i];
 
-	cn_jh_E8(state);
+      cn_jh_E8(state);
 
-	for (i = 0; i < 8; i++) {
-		state->x[(8+i) >> 1][(8+i) & 1] ^= ((uint64_t *)state->buffer)[i];
-	}
+      for (i = 0; i < 8; i++)  state->x[(8+i) >> 1][(8+i) & 1] ^= ((uint64_t *)state->buffer)[i];
 }
 
-__device__
-void cn_jh_update(jhHashState * __restrict__ state, const uint8_t * __restrict__ data, DataLength databitlen)
+__device__ void cn_jh_update(jhHashState * __restrict__ state, const BitSequence * __restrict__ data, DataLength databitlen)
 {
-	DataLength index;
-
-	state->databitlen += databitlen;
-	index = 0;
-
-	if ( (state->datasize_in_buffer > 0 ) && (( state->datasize_in_buffer + databitlen) < 512)  )
-	{
-		if ( (databitlen & 7) == 0 ) {
-			memcpy(state->buffer + (state->datasize_in_buffer >> 3), data, 64-(state->datasize_in_buffer >> 3));
-		}
-		else memcpy(state->buffer + (state->datasize_in_buffer >> 3), data, 64-(state->datasize_in_buffer >> 3)+1);
-		state->datasize_in_buffer += databitlen;
-		databitlen = 0;
-	}
-
-	if ( (state->datasize_in_buffer > 0 ) && (( state->datasize_in_buffer + databitlen) >= 512)  ) {
-		memcpy( state->buffer + (state->datasize_in_buffer >> 3), data, 64-(state->datasize_in_buffer >> 3) ) ;
-		index = 64-(state->datasize_in_buffer >> 3);
-		databitlen = databitlen - (512 - state->datasize_in_buffer);
-		cn_jh_F8(state);
-		state->datasize_in_buffer = 0;
-	}
-
-	for ( ; databitlen >= 512; index = index+64, databitlen = databitlen - 512) {
-		memcpy(state->buffer, data+index, 64);
-		cn_jh_F8(state);
-	}
-
-	if ( databitlen > 0) {
-		if ((databitlen & 7) == 0)
-			memcpy(state->buffer, data+index, (databitlen & 0x1ff) >> 3);
-		else
-			memcpy(state->buffer, data+index, ((databitlen & 0x1ff) >> 3)+1);
-		state->datasize_in_buffer = databitlen;
-	}
+      DataLength index;
+
+      state->databitlen += databitlen;
+      index = 0;
+
+      if ( (state->datasize_in_buffer > 0 ) && (( state->datasize_in_buffer + databitlen) < 512)  ) {
+            if ( (databitlen & 7) == 0 ) {
+                 memcpy(state->buffer + (state->datasize_in_buffer >> 3), data, 64-(state->datasize_in_buffer >> 3)) ;
+		    }
+            else memcpy(state->buffer + (state->datasize_in_buffer >> 3), data, 64-(state->datasize_in_buffer >> 3)+1) ;
+            state->datasize_in_buffer += databitlen;
+            databitlen = 0;
+      }
+
+      if ( (state->datasize_in_buffer > 0 ) && (( state->datasize_in_buffer + databitlen) >= 512)  ) {
+	        memcpy( state->buffer + (state->datasize_in_buffer >> 3), data, 64-(state->datasize_in_buffer >> 3) ) ;
+	        index = 64-(state->datasize_in_buffer >> 3);
+	        databitlen = databitlen - (512 - state->datasize_in_buffer);
+	        cn_jh_F8(state);
+	        state->datasize_in_buffer = 0;
+      }
+
+      for ( ; databitlen >= 512; index = index+64, databitlen = databitlen - 512) {
+            memcpy(state->buffer, data+index, 64);
+            cn_jh_F8(state);
+      }
+
+      if ( databitlen > 0) {
+            if ((databitlen & 7) == 0)
+                  memcpy(state->buffer, data+index, (databitlen & 0x1ff) >> 3);
+            else
+                  memcpy(state->buffer, data+index, ((databitlen & 0x1ff) >> 3)+1);
+            state->datasize_in_buffer = databitlen;
+      }
 }
 
-/* pad the message, process the padded block(s), truncate the hash value H to obtain the message digest */
-__device__
-void cn_jh_final(jhHashState * __restrict__ state, uint32_t * __restrict__ hashval)
+/*pad the message, process the padded block(s), truncate the hash value H to obtain the message digest*/
+__device__ void cn_jh_final(jhHashState * __restrict__ state, BitSequence * __restrict__ hashval)
 {
-	unsigned int i;
-	//uint32_t *bufptr = (uint32_t *)state->buffer;
-
-	if ( (state->databitlen & 0x1ff) == 0 ) {
-		/* pad the message when databitlen is multiple of 512 bits, then process the padded block */
-		memset(state->buffer, 0, 64);
-		//for( i = 0; i < 16; i++ ) *(bufptr+i) = 0x00000000;
-		state->buffer[0]  = 0x80;
-		state->buffer[63] = state->databitlen & 0xff;
-		state->buffer[62] = (state->databitlen >> 8)  & 0xff;
-		state->buffer[61] = (state->databitlen >> 16) & 0xff;
-		state->buffer[60] = (state->databitlen >> 24) & 0xff;
-		state->buffer[59] = (state->databitlen >> 32) & 0xff;
-		state->buffer[58] = (state->databitlen >> 40) & 0xff;
-		state->buffer[57] = (state->databitlen >> 48) & 0xff;
-		state->buffer[56] = (state->databitlen >> 56) & 0xff;
-		cn_jh_F8(state);
-
-	} else {
-
-		/*set the rest of the bytes in the buffer to 0*/
-		if ( (state->datasize_in_buffer & 7) == 0) {
-			for (i = (state->databitlen & 0x1ff) >> 3; i < 64; i++) state->buffer[i] = 0;
-		} else {
-			for (i = ((state->databitlen & 0x1ff) >> 3)+1; i < 64; i++) state->buffer[i] = 0;
-		}
-
-		/*pad and process the partial block when databitlen is not multiple of 512 bits, then hash the padded blocks*/
-		state->buffer[((state->databitlen & 0x1ff) >> 3)] |= 1 << (7- (state->databitlen & 7));
-
-		cn_jh_F8(state);
-		memset(state->buffer, 0, 64);
-		//for( i = 0; i < 16; i++ ) *(bufptr+i) = 0x00000000;
-		state->buffer[63] = state->databitlen & 0xff;
-		state->buffer[62] = (state->databitlen >> 8) & 0xff;
-		state->buffer[61] = (state->databitlen >> 16) & 0xff;
-		state->buffer[60] = (state->databitlen >> 24) & 0xff;
-		state->buffer[59] = (state->databitlen >> 32) & 0xff;
-		state->buffer[58] = (state->databitlen >> 40) & 0xff;
-		state->buffer[57] = (state->databitlen >> 48) & 0xff;
-		state->buffer[56] = (state->databitlen >> 56) & 0xff;
-		cn_jh_F8(state);
-	}
-
-	MEMCPY4(hashval, ((unsigned char*)state->x) + 64 + 32, 8);
+      unsigned int i;
+      //uint32_t *bufptr = (uint32_t *)state->buffer;
+
+      if ( (state->databitlen & 0x1ff) == 0 ) {
+            /*pad the message when databitlen is multiple of 512 bits, then process the padded block*/
+            memset(state->buffer, 0, 64);
+            //for( i = 0; i < 16; i++ ) *(bufptr+i) = 0x00000000;
+            state->buffer[0]  = 0x80;
+            state->buffer[63] = state->databitlen & 0xff;
+            state->buffer[62] = (state->databitlen >> 8)  & 0xff;
+            state->buffer[61] = (state->databitlen >> 16) & 0xff;
+            state->buffer[60] = (state->databitlen >> 24) & 0xff;
+            state->buffer[59] = (state->databitlen >> 32) & 0xff;
+            state->buffer[58] = (state->databitlen >> 40) & 0xff;
+            state->buffer[57] = (state->databitlen >> 48) & 0xff;
+            state->buffer[56] = (state->databitlen >> 56) & 0xff;
+            cn_jh_F8(state);
+      }
+      else {
+		    /*set the rest of the bytes in the buffer to 0*/
+            if ( (state->datasize_in_buffer & 7) == 0)
+                  for (i = (state->databitlen & 0x1ff) >> 3; i < 64; i++)  state->buffer[i] = 0;
+            else
+                  for (i = ((state->databitlen & 0x1ff) >> 3)+1; i < 64; i++)  state->buffer[i] = 0;
+
+            /*pad and process the partial block when databitlen is not multiple of 512 bits, then hash the padded blocks*/
+            state->buffer[((state->databitlen & 0x1ff) >> 3)] |= 1 << (7- (state->databitlen & 7));
+
+            cn_jh_F8(state);
+            memset(state->buffer, 0, 64);
+            //for( i = 0; i < 16; i++ ) *(bufptr+i) = 0x00000000;
+            state->buffer[63] = state->databitlen & 0xff;
+            state->buffer[62] = (state->databitlen >> 8) & 0xff;
+            state->buffer[61] = (state->databitlen >> 16) & 0xff;
+            state->buffer[60] = (state->databitlen >> 24) & 0xff;
+            state->buffer[59] = (state->databitlen >> 32) & 0xff;
+            state->buffer[58] = (state->databitlen >> 40) & 0xff;
+            state->buffer[57] = (state->databitlen >> 48) & 0xff;
+            state->buffer[56] = (state->databitlen >> 56) & 0xff;
+            cn_jh_F8(state);
+      }
+
+      memcpy(hashval,(unsigned char*)state->x+64+32,32);
 }
 
-__device__
-void cn_jh_init(jhHashState *state, int hashbitlen)
+__device__ void cn_jh_init(jhHashState *state, int hashbitlen)
 {
-	state->databitlen = 0;
-	state->datasize_in_buffer = 0;
-	state->hashbitlen = hashbitlen;
-	//memcpy(state->x, d_JH256_H0, 128);
-	MEMCPY8(state->x, d_JH256_H0, 128 / 8);
+    state->databitlen = 0;
+    state->datasize_in_buffer = 0;
+    state->hashbitlen = hashbitlen;
+    memcpy(state->x, d_JH256_H0, 128);
 }
 
-__device__
-void cn_jh256(const uint8_t * __restrict__ data, DataLength len, uint32_t * __restrict__ hashval)
+__device__ void cn_jh(const BitSequence * __restrict__ data, DataLength len, BitSequence * __restrict__ hashval)
 {
-	const int hashbitlen = 256;
-	DataLength databitlen = len << 3;
-	jhHashState state;
-
-	cn_jh_init(&state, hashbitlen);
-	cn_jh_update(&state, data, databitlen);
-	cn_jh_final(&state, hashval);
-}
+    int hashbitlen = 256;
+    DataLength databitlen = len << 3;
+    jhHashState state;
+
+    cn_jh_init(&state, hashbitlen);
+    cn_jh_update(&state, data, databitlen);
+    cn_jh_final(&state, hashval);
+}
\ No newline at end of file
diff --git a/crypto/cn_keccak.cuh b/crypto/cn_keccak.cuh
index 3acef7ae2..985f798d6 100644
--- a/crypto/cn_keccak.cuh
+++ b/crypto/cn_keccak.cuh
@@ -1,4 +1,5 @@
-__constant__ uint64_t keccakf_rndc[24] = {
+__constant__ uint64_t keccakf_rndc[24] =
+{
 	0x0000000000000001, 0x0000000000008082, 0x800000000000808a,
 	0x8000000080008000, 0x000000000000808b, 0x0000000080000001,
 	0x8000000080008081, 0x8000000000008009, 0x000000000000008a,
@@ -33,8 +34,7 @@ __constant__ uint64_t keccakf_rndc[24] = {
 #define rotl64_2(x, y) rotl64_1(((x) >> 32) | ((x) << 32), (y))
 #define bitselect(a, b, c) ((a) ^ ((c) & ((b) ^ (a))))
 
-__device__ __forceinline__
-void cn_keccakf2(uint64_t *s)
+__device__ __forceinline__ void cn_keccakf2(uint64_t *s)
 {
 	uint8_t i;
 
@@ -91,8 +91,7 @@ void cn_keccakf2(uint64_t *s)
 	}
 }
 
-__device__ __forceinline__
-void cn_keccakf(uint64_t *s)
+__device__ __forceinline__ void cn_keccakf(uint64_t *s)
 {
 	uint64_t bc[5], tmpxor[5], tmp1, tmp2;
 
@@ -194,8 +193,7 @@ void cn_keccakf(uint64_t *s)
 	}
 }
 
-__device__ __forceinline__
-void cn_keccak(const uint8_t * __restrict__ in, uint8_t * __restrict__ md)
+__device__ __forceinline__ void cn_keccak(const uint32_t * __restrict__ in, uint64_t * __restrict__ md)
 {
 	uint64_t st[25];
 
@@ -208,4 +206,4 @@ void cn_keccak(const uint8_t * __restrict__ in, uint8_t * __restrict__ md)
 
 	MEMCPY8(md, st, 25);
 	return;
-}
+}
\ No newline at end of file
diff --git a/crypto/cn_skein.cuh b/crypto/cn_skein.cuh
index 2096467fa..860e9384e 100644
--- a/crypto/cn_skein.cuh
+++ b/crypto/cn_skein.cuh
@@ -58,37 +58,37 @@ typedef unsigned int    uint_t;             /* native unsigned integer */
 
 #define KW_TWK_BASE     (0)
 #define KW_KEY_BASE     (3)
-#define ks              (kw + KW_KEY_BASE)
+#define ks              (kw + KW_KEY_BASE)                
 #define ts              (kw + KW_TWK_BASE)
 
 #define R512(p0,p1,p2,p3,p4,p5,p6,p7,R512ROT,rNum) \
-	X##p0 += X##p1; X##p1 = ROTL64(X##p1,R512ROT##_0); X##p1 ^= X##p0; \
-	X##p2 += X##p3; X##p3 = ROTL64(X##p3,R512ROT##_1); X##p3 ^= X##p2; \
-	X##p4 += X##p5; X##p5 = ROTL64(X##p5,R512ROT##_2); X##p5 ^= X##p4; \
-	X##p6 += X##p7; X##p7 = ROTL64(X##p7,R512ROT##_3); X##p7 ^= X##p6;
+    X##p0 += X##p1; X##p1 = ROTL64(X##p1,R512ROT##_0); X##p1 ^= X##p0; \
+    X##p2 += X##p3; X##p3 = ROTL64(X##p3,R512ROT##_1); X##p3 ^= X##p2; \
+    X##p4 += X##p5; X##p5 = ROTL64(X##p5,R512ROT##_2); X##p5 ^= X##p4; \
+    X##p6 += X##p7; X##p7 = ROTL64(X##p7,R512ROT##_3); X##p7 ^= X##p6;
 
 #define I512(R) \
-	X0   += ks[((R)+1) % 9]; \
-	X1   += ks[((R)+2) % 9]; \
-	X2   += ks[((R)+3) % 9]; \
-	X3   += ks[((R)+4) % 9]; \
-	X4   += ks[((R)+5) % 9]; \
-	X5   += ks[((R)+6) % 9] + ts[((R)+1) % 3]; \
-	X6   += ks[((R)+7) % 9] + ts[((R)+2) % 3]; \
-	X7   += ks[((R)+8) % 9] + (R)+1;
-
-
+    X0   += ks[((R)+1) % 9]; \
+    X1   += ks[((R)+2) % 9]; \
+    X2   += ks[((R)+3) % 9]; \
+    X3   += ks[((R)+4) % 9]; \
+    X4   += ks[((R)+5) % 9]; \
+    X5   += ks[((R)+6) % 9] + ts[((R)+1) % 3]; \
+    X6   += ks[((R)+7) % 9] + ts[((R)+2) % 3]; \
+    X7   += ks[((R)+8) % 9] + (R)+1;
+
+        
 #define R512_8_rounds(R) \
-	R512(0,1,2,3,4,5,6,7,R_512_0,8*(R)+ 1); \
-	R512(2,1,4,7,6,5,0,3,R_512_1,8*(R)+ 2); \
-	R512(4,1,6,3,0,5,2,7,R_512_2,8*(R)+ 3); \
-	R512(6,1,0,7,2,5,4,3,R_512_3,8*(R)+ 4); \
-	I512(2*(R)); \
-	R512(0,1,2,3,4,5,6,7,R_512_4,8*(R)+ 5); \
-	R512(2,1,4,7,6,5,0,3,R_512_5,8*(R)+ 6); \
-	R512(4,1,6,3,0,5,2,7,R_512_6,8*(R)+ 7); \
-	R512(6,1,0,7,2,5,4,3,R_512_7,8*(R)+ 8); \
-	I512(2*(R)+1);
+        R512(0,1,2,3,4,5,6,7,R_512_0,8*(R)+ 1); \
+        R512(2,1,4,7,6,5,0,3,R_512_1,8*(R)+ 2); \
+        R512(4,1,6,3,0,5,2,7,R_512_2,8*(R)+ 3); \
+        R512(6,1,0,7,2,5,4,3,R_512_3,8*(R)+ 4); \
+        I512(2*(R)); \
+        R512(0,1,2,3,4,5,6,7,R_512_4,8*(R)+ 5); \
+        R512(2,1,4,7,6,5,0,3,R_512_5,8*(R)+ 6); \
+        R512(4,1,6,3,0,5,2,7,R_512_6,8*(R)+ 7); \
+        R512(6,1,0,7,2,5,4,3,R_512_7,8*(R)+ 8); \
+        I512(2*(R)+1);
 
 typedef struct
 {
@@ -109,217 +109,231 @@ typedef struct {
   uint8_t  b[SKEIN_512_BLOCK_BYTES];
 } Skein_512_Ctxt_t;
 
+typedef struct {
+  Skein_Ctxt_Hdr_t h;
+  uint64_t  X[SKEIN1024_STATE_WORDS];
+  uint8_t  b[SKEIN1024_BLOCK_BYTES];
+} Skein1024_Ctxt_t;
+
 typedef struct {
   uint_t  statebits;
   union {
-	Skein_Ctxt_Hdr_t h;
-	Skein_256_Ctxt_t ctx_256;
-	Skein_512_Ctxt_t ctx_512;
+    Skein_Ctxt_Hdr_t h;
+    Skein_256_Ctxt_t ctx_256;
+    Skein_512_Ctxt_t ctx_512;
+    Skein1024_Ctxt_t ctx1024;
   } u;
 } skeinHashState;
 
-__device__
-void cn_skein256_init(skeinHashState *state, size_t hashBitLen)
+__device__ void cn_skein_init(skeinHashState *state, size_t hashBitLen)
 {
-	const uint64_t SKEIN_512_IV_256[] =
-	{
-		SKEIN_MK_64(0xCCD044A1,0x2FDB3E13),
-		SKEIN_MK_64(0xE8359030,0x1A79A9EB),
-		SKEIN_MK_64(0x55AEA061,0x4F816E6F),
-		SKEIN_MK_64(0x2A2767A4,0xAE9B94DB),
-		SKEIN_MK_64(0xEC06025E,0x74DD7683),
-		SKEIN_MK_64(0xE7A436CD,0xC4746251),
-		SKEIN_MK_64(0xC36FBAF9,0x393AD185),
-		SKEIN_MK_64(0x3EEDBA18,0x33EDFC13)
-	};
-
-	Skein_512_Ctxt_t *ctx = &state->u.ctx_512;
-
-	ctx->h.hashBitLen = hashBitLen;
-
-	memcpy(ctx->X, SKEIN_512_IV_256, sizeof(ctx->X));
+    const uint64_t SKEIN_512_IV_256[] =
+    {
+        SKEIN_MK_64(0xCCD044A1,0x2FDB3E13),
+        SKEIN_MK_64(0xE8359030,0x1A79A9EB),
+        SKEIN_MK_64(0x55AEA061,0x4F816E6F),
+        SKEIN_MK_64(0x2A2767A4,0xAE9B94DB),
+        SKEIN_MK_64(0xEC06025E,0x74DD7683),
+        SKEIN_MK_64(0xE7A436CD,0xC4746251),
+        SKEIN_MK_64(0xC36FBAF9,0x393AD185),
+        SKEIN_MK_64(0x3EEDBA18,0x33EDFC13)
+    };
+    
+    Skein_512_Ctxt_t *ctx = &state->u.ctx_512;
+
+    ctx->h.hashBitLen = hashBitLen;
+
+    memcpy(ctx->X, SKEIN_512_IV_256, sizeof(ctx->X));
+
+    Skein_Start_New_Type(ctx, MSG);
+}
 
-	Skein_Start_New_Type(ctx, MSG);
+__device__ void cn_skein512_processblock(Skein_512_Ctxt_t * __restrict__ ctx, const uint8_t * __restrict__ blkPtr, size_t blkCnt, size_t byteCntAdd)
+{
+    enum {   
+        R_512_0_0=46, R_512_0_1=36, R_512_0_2=19, R_512_0_3=37,
+        R_512_1_0=33, R_512_1_1=27, R_512_1_2=14, R_512_1_3=42,
+        R_512_2_0=17, R_512_2_1=49, R_512_2_2=36, R_512_2_3=39,
+        R_512_3_0=44, R_512_3_1= 9, R_512_3_2=54, R_512_3_3=56,
+        R_512_4_0=39, R_512_4_1=30, R_512_4_2=34, R_512_4_3=24,
+        R_512_5_0=13, R_512_5_1=50, R_512_5_2=10, R_512_5_3=17,
+        R_512_6_0=25, R_512_6_1=29, R_512_6_2=39, R_512_6_3=43,
+        R_512_7_0= 8, R_512_7_1=35, R_512_7_2=56, R_512_7_3=22
+    };
+    uint64_t X0,X1,X2,X3,X4,X5,X6,X7;
+    uint64_t w[SKEIN_512_STATE_WORDS];
+    uint64_t kw[SKEIN_512_STATE_WORDS+4];
+
+    ts[0] = ctx->h.T[0];
+    ts[1] = ctx->h.T[1];
+
+    do  {
+
+        ts[0] += byteCntAdd;
+
+        ks[0] = ctx->X[0];
+        ks[1] = ctx->X[1];
+        ks[2] = ctx->X[2];
+        ks[3] = ctx->X[3];
+        ks[4] = ctx->X[4];
+        ks[5] = ctx->X[5];
+        ks[6] = ctx->X[6];
+        ks[7] = ctx->X[7];
+        ks[8] = ks[0] ^ ks[1] ^ ks[2] ^ ks[3] ^ 
+        ks[4] ^ ks[5] ^ ks[6] ^ ks[7] ^ SKEIN_KS_PARITY;
+
+        ts[2] = ts[0] ^ ts[1];
+
+        memcpy(w, blkPtr, SKEIN_512_STATE_WORDS << 3);
+
+        X0 = w[0] + ks[0];
+        X1 = w[1] + ks[1];
+        X2 = w[2] + ks[2];
+        X3 = w[3] + ks[3];
+        X4 = w[4] + ks[4];
+        X5 = w[5] + ks[5] + ts[0];
+        X6 = w[6] + ks[6] + ts[1];
+        X7 = w[7] + ks[7];
+
+        blkPtr += SKEIN_512_BLOCK_BYTES;
+
+        R512_8_rounds( 0);
+        R512_8_rounds( 1);
+        R512_8_rounds( 2);
+        R512_8_rounds( 3);
+        R512_8_rounds( 4);
+        R512_8_rounds( 5);
+        R512_8_rounds( 6);
+        R512_8_rounds( 7);
+        R512_8_rounds( 8);
+
+        ctx->X[0] = X0 ^ w[0];
+        ctx->X[1] = X1 ^ w[1];
+        ctx->X[2] = X2 ^ w[2];
+        ctx->X[3] = X3 ^ w[3];
+        ctx->X[4] = X4 ^ w[4];
+        ctx->X[5] = X5 ^ w[5];
+        ctx->X[6] = X6 ^ w[6];
+        ctx->X[7] = X7 ^ w[7];
+
+        ts[1] &= ~SKEIN_T1_FLAG_FIRST;
+    } while (--blkCnt);
+
+    ctx->h.T[0] = ts[0];
+    ctx->h.T[1] = ts[1];
 }
 
-__device__
-void cn_skein_processblock(Skein_512_Ctxt_t * __restrict__ ctx, const uint8_t * __restrict__ blkPtr, size_t blkCnt, size_t byteCntAdd)
+__device__ void cn_skein_final(skeinHashState * __restrict__ state, uint8_t * __restrict__ hashVal)
 {
-	enum {
-		R_512_0_0=46, R_512_0_1=36, R_512_0_2=19, R_512_0_3=37,
-		R_512_1_0=33, R_512_1_1=27, R_512_1_2=14, R_512_1_3=42,
-		R_512_2_0=17, R_512_2_1=49, R_512_2_2=36, R_512_2_3=39,
-		R_512_3_0=44, R_512_3_1= 9, R_512_3_2=54, R_512_3_3=56,
-		R_512_4_0=39, R_512_4_1=30, R_512_4_2=34, R_512_4_3=24,
-		R_512_5_0=13, R_512_5_1=50, R_512_5_2=10, R_512_5_3=17,
-		R_512_6_0=25, R_512_6_1=29, R_512_6_2=39, R_512_6_3=43,
-		R_512_7_0= 8, R_512_7_1=35, R_512_7_2=56, R_512_7_3=22
-	};
-	uint64_t X0,X1,X2,X3,X4,X5,X6,X7;
-	uint64_t w[SKEIN_512_STATE_WORDS];
-	uint64_t kw[SKEIN_512_STATE_WORDS+4];
-
-	ts[0] = ctx->h.T[0];
-	ts[1] = ctx->h.T[1];
-
-	do  {
-
-		ts[0] += byteCntAdd;
-
-		ks[0] = ctx->X[0];
-		ks[1] = ctx->X[1];
-		ks[2] = ctx->X[2];
-		ks[3] = ctx->X[3];
-		ks[4] = ctx->X[4];
-		ks[5] = ctx->X[5];
-		ks[6] = ctx->X[6];
-		ks[7] = ctx->X[7];
-		ks[8] = ks[0] ^ ks[1] ^ ks[2] ^ ks[3] ^
-		ks[4] ^ ks[5] ^ ks[6] ^ ks[7] ^ SKEIN_KS_PARITY;
-
-		ts[2] = ts[0] ^ ts[1];
-
-		memcpy(w, blkPtr, SKEIN_512_STATE_WORDS << 3);
-
-		X0 = w[0] + ks[0];
-		X1 = w[1] + ks[1];
-		X2 = w[2] + ks[2];
-		X3 = w[3] + ks[3];
-		X4 = w[4] + ks[4];
-		X5 = w[5] + ks[5] + ts[0];
-		X6 = w[6] + ks[6] + ts[1];
-		X7 = w[7] + ks[7];
-
-		blkPtr += SKEIN_512_BLOCK_BYTES;
-
-		R512_8_rounds( 0);
-		R512_8_rounds( 1);
-		R512_8_rounds( 2);
-		R512_8_rounds( 3);
-		R512_8_rounds( 4);
-		R512_8_rounds( 5);
-		R512_8_rounds( 6);
-		R512_8_rounds( 7);
-		R512_8_rounds( 8);
-
-		ctx->X[0] = X0 ^ w[0];
-		ctx->X[1] = X1 ^ w[1];
-		ctx->X[2] = X2 ^ w[2];
-		ctx->X[3] = X3 ^ w[3];
-		ctx->X[4] = X4 ^ w[4];
-		ctx->X[5] = X5 ^ w[5];
-		ctx->X[6] = X6 ^ w[6];
-		ctx->X[7] = X7 ^ w[7];
-
-		ts[1] &= ~SKEIN_T1_FLAG_FIRST;
-	} while (--blkCnt);
-
-	ctx->h.T[0] = ts[0];
-	ctx->h.T[1] = ts[1];
+    size_t i,n,byteCnt;
+    uint64_t X[SKEIN_512_STATE_WORDS];
+    Skein_512_Ctxt_t *ctx = (Skein_512_Ctxt_t *)&state->u.ctx_512;
+    //size_t tmp;
+    //uint8_t *p8;
+    //uint64_t *p64;
+
+    ctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;
+    
+    if (ctx->h.bCnt < SKEIN_512_BLOCK_BYTES) {
+
+        memset(&ctx->b[ctx->h.bCnt],0,SKEIN_512_BLOCK_BYTES - ctx->h.bCnt);
+        //p8 = &ctx->b[ctx->h.bCnt];
+        //tmp = SKEIN_512_BLOCK_BYTES - ctx->h.bCnt;
+        //for( i = 0; i < tmp; i++ ) *(p8+i) = 0;
+    }
+
+    cn_skein512_processblock(ctx,ctx->b,1,ctx->h.bCnt);
+
+    byteCnt = (ctx->h.hashBitLen + 7) >> 3;
+
+    //uint8_t  b[SKEIN_512_BLOCK_BYTES] == 64
+    memset(ctx->b,0,sizeof(ctx->b));
+    //p64 = (uint64_t *)ctx->b;
+    //for( i = 0; i < 8; i++ ) *(p64+i) = 0;
+
+    memcpy(X,ctx->X,sizeof(X));
+
+    for (i=0;i*SKEIN_512_BLOCK_BYTES < byteCnt;i++) {
+
+        ((uint64_t *)ctx->b)[0]= (uint64_t)i;
+        Skein_Start_New_Type(ctx,OUT_FINAL);
+        cn_skein512_processblock(ctx,ctx->b,1,sizeof(uint64_t));
+        n = byteCnt - i*SKEIN_512_BLOCK_BYTES;
+        if (n >= SKEIN_512_BLOCK_BYTES)
+        n  = SKEIN_512_BLOCK_BYTES;
+        memcpy(hashVal+i*SKEIN_512_BLOCK_BYTES,ctx->X,n);
+        memcpy(ctx->X,X,sizeof(X));   /* restore the counter mode key for next time */
+    }
 }
 
-__device__
-void cn_skein_block(Skein_512_Ctxt_t * __restrict__ ctx, const uint8_t * __restrict__ msg, size_t msgByteCnt)
+__device__ void cn_skein512_update(Skein_512_Ctxt_t * __restrict__ ctx, const uint8_t * __restrict__ msg, size_t msgByteCnt)
 {
-	size_t n;
+    size_t n;
 
-	if (msgByteCnt + ctx->h.bCnt > SKEIN_512_BLOCK_BYTES)
-	{
-		if (ctx->h.bCnt) {
+    if (msgByteCnt + ctx->h.bCnt > SKEIN_512_BLOCK_BYTES) {
 
-			n = SKEIN_512_BLOCK_BYTES - ctx->h.bCnt;
+        if (ctx->h.bCnt) {
 
-			if (n) {
+            n = SKEIN_512_BLOCK_BYTES - ctx->h.bCnt;
 
-				memcpy(&ctx->b[ctx->h.bCnt],msg,n);
-				msgByteCnt  -= n;
-				msg         += n;
-				ctx->h.bCnt += n;
-			}
+            if (n) {
 
-			cn_skein_processblock(ctx, ctx->b, 1, SKEIN_512_BLOCK_BYTES);
-			ctx->h.bCnt = 0;
-		}
+                memcpy(&ctx->b[ctx->h.bCnt],msg,n);
+                msgByteCnt  -= n;
+                msg         += n;
+                ctx->h.bCnt += n;
+            }
 
-		if (msgByteCnt > SKEIN_512_BLOCK_BYTES) {
+            cn_skein512_processblock(ctx,ctx->b,1,SKEIN_512_BLOCK_BYTES);
+            ctx->h.bCnt = 0;
+        }
 
-			n = (msgByteCnt - 1) / SKEIN_512_BLOCK_BYTES;
-			cn_skein_processblock(ctx, msg, n, SKEIN_512_BLOCK_BYTES);
-			msgByteCnt -= n * SKEIN_512_BLOCK_BYTES;
-			msg        += n * SKEIN_512_BLOCK_BYTES;
-		}
-	}
+        if (msgByteCnt > SKEIN_512_BLOCK_BYTES) {
+            
+            n = (msgByteCnt-1) / SKEIN_512_BLOCK_BYTES;
+            cn_skein512_processblock(ctx,msg,n,SKEIN_512_BLOCK_BYTES);
+            msgByteCnt -= n * SKEIN_512_BLOCK_BYTES;
+            msg        += n * SKEIN_512_BLOCK_BYTES;
+        }
+    }
 
-	if (msgByteCnt) {
+    if (msgByteCnt) {
 
-		memcpy(&ctx->b[ctx->h.bCnt],msg,msgByteCnt);
-		ctx->h.bCnt += msgByteCnt;
-	}
+        memcpy(&ctx->b[ctx->h.bCnt],msg,msgByteCnt);
+        ctx->h.bCnt += msgByteCnt;
+    }
 }
 
-__device__
-void cn_skein256_update(skeinHashState * __restrict__ state, const uint8_t * __restrict__ data, DataLength databitlen)
+__device__ void cn_skein_update(skeinHashState * __restrict__ state, const BitSequence * __restrict__ data, DataLength databitlen)
 {
-	if ((databitlen & 7) == 0) {
-
-		cn_skein_block(&state->u.ctx_512, data, databitlen >> 3);
-	}
-	else {
+    if ((databitlen & 7) == 0) {
 
-		size_t bCnt = (databitlen >> 3) + 1;
-		uint8_t b,mask;
+        cn_skein512_update(&state->u.ctx_512,data,databitlen >> 3);
+    }
+    else {
+    
+        size_t bCnt = (databitlen >> 3) + 1;
+        uint8_t b,mask;
 
-		mask = (uint8_t) (1u << (7 - (databitlen & 7)));
-		b    = (uint8_t) ((data[bCnt-1] & (0-mask)) | mask);
+        mask = (uint8_t) (1u << (7 - (databitlen & 7)));
+        b    = (uint8_t) ((data[bCnt-1] & (0-mask)) | mask);
 
-		cn_skein_block(&state->u.ctx_512, data, bCnt - 1);
-		cn_skein_block(&state->u.ctx_512, &b, 1);
-
-		Skein_Set_Bit_Pad_Flag(state->u.h);
-	}
-}
+        cn_skein512_update(&state->u.ctx_512,data,bCnt-1);
+        cn_skein512_update(&state->u.ctx_512,&b  ,  1   );
 
-__device__
-void cn_skein256_final(skeinHashState * __restrict__ state, uint32_t * __restrict__ hashVal)
-{
-	uint64_t X[SKEIN_512_STATE_WORDS];
-	Skein_512_Ctxt_t *ctx = (Skein_512_Ctxt_t *)&state->u.ctx_512;
-	const int byteCnt = (ctx->h.hashBitLen + 7) >> 3;
-
-	ctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;
-
-	if (ctx->h.bCnt < SKEIN_512_BLOCK_BYTES)
-	{
-		memset(&ctx->b[ctx->h.bCnt], 0, SKEIN_512_BLOCK_BYTES - ctx->h.bCnt);
-	}
-
-	cn_skein_processblock(ctx, ctx->b, 1, ctx->h.bCnt);
-
-	memset(ctx->b, 0, sizeof(ctx->b));
-	memcpy(X, ctx->X, sizeof(X));
-
-	for (int i = 0; i*SKEIN_512_BLOCK_BYTES < byteCnt; i++)
-	{
-		int n = byteCnt - i*SKEIN_512_BLOCK_BYTES;
-		if (n > SKEIN_512_BLOCK_BYTES) n = SKEIN_512_BLOCK_BYTES;
-		((uint64_t *)ctx->b)[0] = (uint64_t)i;
-		Skein_Start_New_Type(ctx, OUT_FINAL);
-		cn_skein_processblock(ctx, ctx->b, 1, sizeof(uint64_t));
-		memcpy(hashVal + (i*SKEIN_512_BLOCK_BYTES/sizeof(uint32_t)), ctx->X, n);
-		memcpy(ctx->X, X, sizeof(X)); // restore the counter mode key for next time
-	}
+        Skein_Set_Bit_Pad_Flag(state->u.h);
+    }
 }
 
-__device__
-void cn_skein(const uint8_t * __restrict__ data, DataLength len, uint32_t * __restrict__ hashval)
+__device__ void cn_skein(const BitSequence * __restrict__ data, DataLength len, BitSequence * __restrict__ hashval)
 {
-	int hashbitlen = 256;
-	DataLength databitlen = len << 3;
-	skeinHashState state;
-
-	state.statebits = 64*SKEIN_512_STATE_WORDS;
-
-	cn_skein256_init(&state, hashbitlen);
-	cn_skein256_update(&state, data, databitlen);
-	cn_skein256_final(&state, hashval);
-}
+    int hashbitlen = 256;
+    DataLength databitlen = len << 3;
+    skeinHashState state;
+
+    state.statebits = 64*SKEIN_512_STATE_WORDS;
+    
+    cn_skein_init(&state, hashbitlen);
+    cn_skein_update(&state, data, databitlen);
+    cn_skein_final(&state, hashval);
+}
\ No newline at end of file
diff --git a/crypto/cryptolight-core.cu b/crypto/cryptolight-core.cu
index 3891768db..3022e4e10 100644
--- a/crypto/cryptolight-core.cu
+++ b/crypto/cryptolight-core.cu
@@ -8,7 +8,7 @@
 #define LONG_SHL_IDX 18
 #define LONG_LOOPS32 0x40000
 
-#include "cn_aes.cuh"
+#include "cl_aes.cuh"
 
 #define MUL_SUM_XOR_DST(a,c,dst) { \
 	uint64_t hi, lo = cuda_mul128(((uint64_t *)a)[0], ((uint64_t *)dst)[0], &hi) + ((uint64_t *)c)[1]; \
@@ -251,7 +251,7 @@ void cryptolight_core_gpu_phase3(int threads, const uint32_t * long_state, uint3
 extern int device_bfactor[MAX_GPUS];
 
 __host__
-void cryptolight_core_cpu_hash(int thr_id, int blocks, int threads, uint32_t *d_long_state, uint64_t *d_ctx_state,
+void cryptolight_core_cpu_hash(int thr_id, int blocks, int threads, uint32_t *d_long_state, uint32_t *d_ctx_state,
 	uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2)
 {
 	dim3 grid(blocks);
@@ -265,7 +265,7 @@ void cryptolight_core_cpu_hash(int thr_id, int blocks, int threads, uint32_t *d_
 	int i, partcount = 1 << bfactor;
 	int dev_id = device_map[thr_id];
 
-	cryptolight_core_gpu_phase1 <<<grid, block8 >>>(blocks*threads, d_long_state, (uint32_t*)d_ctx_state, d_ctx_key1);
+	cryptolight_core_gpu_phase1 <<<grid, block8 >>>(blocks*threads, d_long_state, d_ctx_state, d_ctx_key1);
 	exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
 	if(partcount > 1) usleep(bsleep);
 
@@ -276,6 +276,6 @@ void cryptolight_core_cpu_hash(int thr_id, int blocks, int threads, uint32_t *d_
 		if(partcount > 1) usleep(bsleep);
 	}
 
-	cryptolight_core_gpu_phase3 <<<grid, block8 >>>(blocks*threads, d_long_state, (uint32_t*)d_ctx_state, d_ctx_key2);
+	cryptolight_core_gpu_phase3 <<<grid, block8 >>>(blocks*threads, d_long_state, d_ctx_state, d_ctx_key2);
 	exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
 }
diff --git a/crypto/cryptolight.cu b/crypto/cryptolight.cu
index c8ab8ea40..67b405301 100644
--- a/crypto/cryptolight.cu
+++ b/crypto/cryptolight.cu
@@ -7,7 +7,7 @@ static __thread uint32_t cn_blocks  = 32;
 static __thread uint32_t cn_threads = 16;
 
 static uint32_t *d_long_state[MAX_GPUS];
-static uint64_t *d_ctx_state[MAX_GPUS];
+static uint32_t *d_ctx_state[MAX_GPUS];
 static uint32_t *d_ctx_key1[MAX_GPUS];
 static uint32_t *d_ctx_key2[MAX_GPUS];
 static uint32_t *d_ctx_text[MAX_GPUS];
@@ -63,11 +63,11 @@ extern "C" int scanhash_cryptolight(int thr_id, struct work* work, uint32_t max_
 		}
 
 		const size_t alloc = MEMORY * throughput;
-		cryptonight_extra_cpu_init(thr_id, throughput);
+		cryptonight_extra_cpu_init(thr_id/*, throughput*/);
 
 		cudaMalloc(&d_long_state[thr_id], alloc);
 		exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
-		cudaMalloc(&d_ctx_state[thr_id], 26 * sizeof(uint64_t) * throughput);
+		cudaMalloc(&d_ctx_state[thr_id], 52 * sizeof(uint32_t) * throughput);
 		exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
 		cudaMalloc(&d_ctx_key1[thr_id], 40 * sizeof(uint32_t) * throughput);
 		exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
@@ -91,7 +91,7 @@ extern "C" int scanhash_cryptolight(int thr_id, struct work* work, uint32_t max_
 		uint32_t resNonces[2] = { UINT32_MAX, UINT32_MAX };
 
 		cryptonight_extra_cpu_setData(thr_id, pdata, ptarget);
-		cryptonight_extra_cpu_prepare(thr_id, throughput, nonce, d_ctx_state[thr_id], d_ctx_a[thr_id], d_ctx_b[thr_id], d_ctx_key1[thr_id], d_ctx_key2[thr_id]);
+		cryptonight_extra_cpu_prepare(thr_id, throughput, nonce, d_ctx_state[thr_id], d_ctx_a[thr_id], d_ctx_b[thr_id], d_ctx_key1[thr_id], d_ctx_key2[thr_id], 0, 0);
 		cryptolight_core_cpu_hash(thr_id, cn_blocks, cn_threads, d_long_state[thr_id], d_ctx_state[thr_id], d_ctx_a[thr_id], d_ctx_b[thr_id], d_ctx_key1[thr_id], d_ctx_key2[thr_id]);
 		cryptonight_extra_cpu_final(thr_id, throughput, nonce, resNonces, d_ctx_state[thr_id]);
 
diff --git a/crypto/cryptolight.h b/crypto/cryptolight.h
index 443cf5b3c..3b8425ab1 100644
--- a/crypto/cryptolight.h
+++ b/crypto/cryptolight.h
@@ -134,10 +134,11 @@ static inline void exit_if_cudaerror(int thr_id, const char *src, int line)
 		exit(1);
 	}
 }
-void cryptolight_core_cpu_hash(int thr_id, int blocks, int threads, uint32_t *d_long_state, uint64_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2);
+
+void cryptolight_core_cpu_hash(int thr_id, int blocks, int threads, uint32_t *d_long_state, uint32_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2);
 
 void cryptonight_extra_cpu_setData(int thr_id, const void *data, const void *pTargetIn);
-void cryptonight_extra_cpu_init(int thr_id, uint32_t threads);
+void cryptonight_extra_cpu_init(int thr_id/*, uint32_t threads*/);
 void cryptonight_extra_cpu_free(int thr_id);
-void cryptonight_extra_cpu_prepare(int thr_id, uint32_t threads, uint32_t startNonce, uint64_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2);
-void cryptonight_extra_cpu_final(int thr_id, uint32_t threads, uint32_t startNonce, uint32_t *nonce, uint64_t *d_ctx_state);
+void cryptonight_extra_cpu_prepare(int thr_id, int threads, uint32_t startNonce, uint32_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2, int variant, uint32_t *d_ctx_tweak1_2);
+void cryptonight_extra_cpu_final(int thr_id, int threads, uint32_t startNonce, uint32_t *resnonce, uint32_t *d_ctx_state);
diff --git a/crypto/cryptonight-core.cu b/crypto/cryptonight-core.cu
index 24adf37fd..9ba8ea006 100644
--- a/crypto/cryptonight-core.cu
+++ b/crypto/cryptonight-core.cu
@@ -10,9 +10,9 @@
 #include <unistd.h>
 #endif
 
-extern int device_arch[MAX_GPU][2];
-extern int device_bfactor[MAX_GPU];
-extern int device_bsleep[MAX_GPU];
+extern int device_arch[MAX_GPUS][2];
+extern int device_bfactor[MAX_GPUS];
+extern int device_bsleep[MAX_GPUS];
 
 #include "cn_aes.cuh"
 
diff --git a/crypto/cryptonight-extra.cu b/crypto/cryptonight-extra.cu
index 1cad0e177..6ba818688 100644
--- a/crypto/cryptonight-extra.cu
+++ b/crypto/cryptonight-extra.cu
@@ -9,12 +9,12 @@
 #include <cuda_helper.h>
 #include "cryptonight.h"
 
-typedef uint8_t BitSequence;
-typedef uint64_t DataLength;
+typedef unsigned char BitSequence;
+typedef unsigned long long DataLength;
 
-static uint32_t *d_input[MAX_GPUS] = { 0 };
+static uint32_t *d_input[MAX_GPUS];
 static uint32_t *d_target[MAX_GPUS];
-static uint32_t *d_result[MAX_GPUS];
+static uint32_t *d_resultNonce[MAX_GPUS];
 
 #include "cn_keccak.cuh"
 #include "cn_blake.cuh"
diff --git a/crypto/cryptonight.cu b/crypto/cryptonight.cu
index 6b3b92358..2b82468d0 100644
--- a/crypto/cryptonight.cu
+++ b/crypto/cryptonight.cu
@@ -11,8 +11,8 @@ static __thread bool gpu_init_shown = false;
 #define gpulog_init(p,thr,fmt, ...) if (!gpu_init_shown) \
 	gpulog(p, thr, fmt, ##__VA_ARGS__)
 
-static uint64_t *d_long_state[MAX_GPUS];
-static uint64_t *d_ctx_state[MAX_GPUS];
+static uint32_t *d_long_state[MAX_GPUS];
+static uint32_t *d_ctx_state[MAX_GPUS];
 static uint32_t *d_ctx_key1[MAX_GPUS];
 static uint32_t *d_ctx_key2[MAX_GPUS];
 static uint32_t *d_ctx_text[MAX_GPUS];
@@ -80,11 +80,11 @@ extern "C" int scanhash_cryptonight(int thr_id, struct work* work, uint32_t max_
 		}
 
 		const size_t alloc = MEMORY * throughput;
-		cryptonight_extra_cpu_init(thr_id, throughput);
+		cryptonight_extra_cpu_init(thr_id/*, throughput*/);
 
 		cudaMalloc(&d_long_state[thr_id], alloc);
 		exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
-		cudaMalloc(&d_ctx_state[thr_id], 208 * throughput); // 52*4 (200 is not aligned 16)
+		cudaMalloc(&d_ctx_state[thr_id], 52 * sizeof(uint32_t) * throughput);
 		exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
 		cudaMalloc(&d_ctx_key1[thr_id], 40 * sizeof(uint32_t) * throughput);
 		exit_if_cudaerror(thr_id, __FUNCTION__, __LINE__);
diff --git a/crypto/cryptonight.h b/crypto/cryptonight.h
index 39c2a61cc..443e01259 100644
--- a/crypto/cryptonight.h
+++ b/crypto/cryptonight.h
@@ -136,10 +136,10 @@ static inline void exit_if_cudaerror(int thr_id, const char *src, int line)
 		exit(1);
 	}
 }
-void cryptonight_core_cpu_hash(int thr_id, int blocks, int threads, uint64_t *d_long_state, uint64_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2, int variant, uint32_t *d_ctx_tweak1_2);
+void cryptonight_core_cpu_hash(int thr_id, int blocks, int threads, uint32_t *d_long_state, uint32_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2, int variant, uint32_t *d_ctx_tweak1_2);
 
 void cryptonight_extra_cpu_setData(int thr_id, const void *data, const void *pTargetIn);
-void cryptonight_extra_cpu_init(int thr_id, uint32_t threads);
+void cryptonight_extra_cpu_init(int thr_id);
 void cryptonight_extra_cpu_free(int thr_id);
-void cryptonight_extra_cpu_prepare(int thr_id, uint32_t threads, uint32_t startNonce, uint64_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2, int variant, uint32_t *d_ctx_tweak1_2);
-void cryptonight_extra_cpu_final(int thr_id, uint32_t threads, uint32_t startNonce, uint32_t *nonce, uint64_t *d_ctx_state);
+void cryptonight_extra_cpu_prepare(int thr_id, int threads, uint32_t startNonce, uint32_t *d_ctx_state, uint32_t *d_ctx_a, uint32_t *d_ctx_b, uint32_t *d_ctx_key1, uint32_t *d_ctx_key2, int variant, uint32_t *d_ctx_tweak1_2);
+void cryptonight_extra_cpu_final(int thr_id, int threads, uint32_t startNonce, uint32_t *resnonce, uint32_t *d_ctx_state);
diff --git a/crypto/xmr-rpc.cpp b/crypto/xmr-rpc.cpp
index 82b7845f2..3c6118c44 100644
--- a/crypto/xmr-rpc.cpp
+++ b/crypto/xmr-rpc.cpp
@@ -561,7 +561,13 @@ bool rpc2_stratum_submit(struct pool_infos *pool, struct work *work)
 		uint32_t nonce = work->nonces[idnonce];
 		noncestr = bin2hex((unsigned char*) &nonce, 4);
 		last_found_nonce = nonce;
-		cryptonight_hash(hash, data, 76);
+		int variant = 0;
+
+		if (cryptonight_fork > 1) {
+			variant = ((((unsigned char*)work->data)[0] >= cryptonight_fork) ? ((unsigned char*)work->data)[0] - cryptonight_fork + 1 : 0 );
+		}
+
+		cryptonight_hash(hash, data, 76, variant);
 		work_set_target_ratio(work, (uint32_t*) hash);
 	}
 
diff --git a/miner.h b/miner.h
index 246e5b94d..109069b78 100644
--- a/miner.h
+++ b/miner.h
@@ -279,7 +279,7 @@ extern int scanhash_blake2s(int thr_id, struct work *work, uint32_t max_nonce, u
 extern int scanhash_bmw(int thr_id, struct work* work, uint32_t max_nonce, unsigned long *hashes_done);
 extern int scanhash_c11(int thr_id, struct work* work, uint32_t max_nonce, unsigned long *hashes_done);
 extern int scanhash_cryptolight(int thr_id, struct work* work, uint32_t max_nonce, unsigned long *hashes_done);
-extern int scanhash_cryptonight(int thr_id, struct work* work, uint32_t max_nonce, unsigned long *hashes_done);
+extern int scanhash_cryptonight(int thr_id, struct work* work, uint32_t max_nonce, unsigned long *hashes_done, int variant);
 extern int scanhash_decred(int thr_id, struct work* work, uint32_t max_nonce, unsigned long *hashes_done);
 extern int scanhash_deep(int thr_id, struct work* work, uint32_t max_nonce, unsigned long *hashes_done);
 extern int scanhash_equihash(int thr_id, struct work* work, uint32_t max_nonce, unsigned long *hashes_done);
@@ -571,6 +571,8 @@ extern uint32_t device_plimit[MAX_GPUS];
 extern uint32_t gpus_intensity[MAX_GPUS];
 extern int opt_cudaschedule;
 
+extern int cryptonight_fork;
+
 // cuda.cpp
 int cuda_num_devices();
 void cuda_devicenames();
diff --git a/util.cpp b/util.cpp
index dc20c2adc..14033bbd9 100644
--- a/util.cpp
+++ b/util.cpp
@@ -2185,7 +2185,7 @@ void print_hash_tests(void)
 	cryptolight_hash(&hash[0], &buf[0], 76);
 	printpfx("cryptolight", hash);
 
-	cryptonight_hash(&hash[0], &buf[0], 76);
+	cryptonight_hash(&hash[0], &buf[0], 76, 0);
 	printpfx("cryptonight", hash);
 
 	memset(buf, 0, 180);

From 4e5bd591992c29bd1b6b00e3c8291ce1538f3d76 Mon Sep 17 00:00:00 2001
From: ystarnaud <ystarnaud@gmail.com>
Date: Fri, 6 Apr 2018 15:06:37 -0400
Subject: [PATCH 5/5] More cryptonight kernel fixes

---
 crypto/cryptonight-core.cu  | 22 +++++++++++++---------
 crypto/cryptonight-extra.cu | 12 +++++++++++-
 2 files changed, 24 insertions(+), 10 deletions(-)

diff --git a/crypto/cryptonight-core.cu b/crypto/cryptonight-core.cu
index 9ba8ea006..6480a8050 100644
--- a/crypto/cryptonight-core.cu
+++ b/crypto/cryptonight-core.cu
@@ -10,9 +10,7 @@
 #include <unistd.h>
 #endif
 
-extern int device_arch[MAX_GPUS][2];
 extern int device_bfactor[MAX_GPUS];
-extern int device_bsleep[MAX_GPUS];
 
 #include "cn_aes.cuh"
 
@@ -221,20 +219,26 @@ __host__ void cryptonight_core_cpu_hash(int thr_id, int blocks, int threads, uin
 	dim3 block4(threads << 2);
 	dim3 block8(threads << 3);
 
-	int i, partcount = 1 << device_bfactor[thr_id];
+	uint32_t i;
+	const uint32_t bfactor = (uint32_t) device_bfactor[thr_id];
+	const uint32_t partcount = 1 << bfactor;
+	const uint32_t throughput = (uint32_t) (blocks*threads);
 
-	cryptonight_core_gpu_phase1 <<< grid, block8 >>>(blocks*threads, d_long_state, d_ctx_state, d_ctx_key1);
+	const int bsleep = bfactor ? 100 : 0;
+	//const int dev_id = device_map[thr_id];
+
+	cryptonight_core_gpu_phase1 <<< grid, block8 >>>(throughput, d_long_state, d_ctx_state, d_ctx_key1);
 	exit_if_cudaerror(thr_id, __FILE__, __LINE__);
-	if(partcount > 1) usleep(device_bsleep[thr_id]);
+	if(partcount > 1) usleep(bsleep);
 
 	for(i = 0; i < partcount; i++)
 	{
-		cryptonight_core_gpu_phase2 <<< grid, block4 >>>(blocks*threads, device_bfactor[thr_id], i, d_long_state, d_ctx_a, d_ctx_b, variant, d_ctx_tweak1_2);
+		cryptonight_core_gpu_phase2 <<< grid, block4 >>>(throughput, bfactor, i, d_long_state, d_ctx_a, d_ctx_b, variant, d_ctx_tweak1_2);
 		exit_if_cudaerror(thr_id, __FILE__, __LINE__);
-		if(partcount > 1) usleep(device_bsleep[thr_id]);
+		if(partcount > 1) usleep(bsleep);
 	}
 	cudaDeviceSynchronize();
 	exit_if_cudaerror(thr_id, __FILE__, __LINE__);
-	cryptonight_core_gpu_phase3 <<< grid, block8 >>>(blocks*threads, d_long_state, d_ctx_state, d_ctx_key2);
+	cryptonight_core_gpu_phase3 <<< grid, block8 >>>(throughput, d_long_state, d_ctx_state, d_ctx_key2);
 	exit_if_cudaerror(thr_id, __FILE__, __LINE__);
-}
\ No newline at end of file
+}
diff --git a/crypto/cryptonight-extra.cu b/crypto/cryptonight-extra.cu
index 6ba818688..31eaf4ed8 100644
--- a/crypto/cryptonight-extra.cu
+++ b/crypto/cryptonight-extra.cu
@@ -217,4 +217,14 @@ __host__ void cryptonight_extra_cpu_final(int thr_id, int threads, uint32_t star
 	exit_if_cudaerror(thr_id, __FILE__, __LINE__);
 	cudaMemcpy(resnonce, d_resultNonce[thr_id], 2 * sizeof(uint32_t), cudaMemcpyDeviceToHost);
 	exit_if_cudaerror(thr_id, __FILE__, __LINE__);
-}
\ No newline at end of file
+}
+
+__host__ void cryptonight_extra_cpu_free(int thr_id)
+{
+	if (d_input[thr_id]) {
+		cudaFree(d_input[thr_id]);
+		cudaFree(d_target[thr_id]);
+		cudaFree(d_resultNonce[thr_id]);
+		d_input[thr_id] = NULL;
+	}
+}
